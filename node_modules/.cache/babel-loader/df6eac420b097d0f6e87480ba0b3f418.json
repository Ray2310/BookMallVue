{"ast":null,"code":"import \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.match.js\";\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport { each, isObject, isArray, createHashMap, map, assert, isString, indexOf, isStringSafe, isNumber } from 'zrender/lib/core/util.js';\nimport env from 'zrender/lib/core/env.js';\nimport { isNumeric, getRandomIdBase, getPrecision, round } from './number.js';\nimport { warn } from './log.js';\n\nfunction interpolateNumber(p0, p1, percent) {\n  return (p1 - p0) * percent + p0;\n}\n/**\r\n * Make the name displayable. But we should\r\n * make sure it is not duplicated with user\r\n * specified name, so use '\\0';\r\n */\n\n\nvar DUMMY_COMPONENT_NAME_PREFIX = 'series\\0';\nvar INTERNAL_COMPONENT_ID_PREFIX = '\\0_ec_\\0';\n/**\r\n * If value is not array, then translate it to array.\r\n * @param  {*} value\r\n * @return {Array} [value] or value\r\n */\n\nexport function normalizeToArray(value) {\n  return value instanceof Array ? value : value == null ? [] : [value];\n}\n/**\r\n * Sync default option between normal and emphasis like `position` and `show`\r\n * In case some one will write code like\r\n *     label: {\r\n *          show: false,\r\n *          position: 'outside',\r\n *          fontSize: 18\r\n *     },\r\n *     emphasis: {\r\n *          label: { show: true }\r\n *     }\r\n */\n\nexport function defaultEmphasis(opt, key, subOpts) {\n  // Caution: performance sensitive.\n  if (opt) {\n    opt[key] = opt[key] || {};\n    opt.emphasis = opt.emphasis || {};\n    opt.emphasis[key] = opt.emphasis[key] || {}; // Default emphasis option from normal\n\n    for (var i = 0, len = subOpts.length; i < len; i++) {\n      var subOptName = subOpts[i];\n\n      if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {\n        opt.emphasis[key][subOptName] = opt[key][subOptName];\n      }\n    }\n  }\n}\nexport var TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding']; // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([\n//     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',\n//     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',\n//     // FIXME: deprecated, check and remove it.\n//     'textStyle'\n// ]);\n\n/**\r\n * The method do not ensure performance.\r\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\r\n * This helper method retieves value from data.\r\n */\n\nexport function getDataItemValue(dataItem) {\n  return isObject(dataItem) && !isArray(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;\n}\n/**\r\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\r\n * This helper method determine if dataItem has extra option besides value\r\n */\n\nexport function isDataItemOption(dataItem) {\n  return isObject(dataItem) && !(dataItem instanceof Array); // // markLine data can be array\n  // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n}\n;\n/**\r\n * Mapping to existings for merge.\r\n *\r\n * Mode \"normalMege\":\r\n *     The mapping result (merge result) will keep the order of the existing\r\n *     component, rather than the order of new option. Because we should ensure\r\n *     some specified index reference (like xAxisIndex) keep work.\r\n *     And in most cases, \"merge option\" is used to update partial option but not\r\n *     be expected to change the order.\r\n *\r\n * Mode \"replaceMege\":\r\n *     (1) Only the id mapped components will be merged.\r\n *     (2) Other existing components (except internal compoonets) will be removed.\r\n *     (3) Other new options will be used to create new component.\r\n *     (4) The index of the existing compoents will not be modified.\r\n *     That means their might be \"hole\" after the removal.\r\n *     The new components are created first at those available index.\r\n *\r\n * Mode \"replaceAll\":\r\n *     This mode try to support that reproduce an echarts instance from another\r\n *     echarts instance (via `getOption`) in some simple cases.\r\n *     In this senario, the `result` index are exactly the consistent with the `newCmptOptions`,\r\n *     which ensures the compoennt index referring (like `xAxisIndex: ?`) corrent. That is,\r\n *     the \"hole\" in `newCmptOptions` will also be kept.\r\n *     On the contrary, other modes try best to eliminate holes.\r\n *     PENDING: This is an experimental mode yet.\r\n *\r\n * @return See the comment of <MappingResult>.\r\n */\n\nexport function mappingToExists(existings, newCmptOptions, mode) {\n  var isNormalMergeMode = mode === 'normalMerge';\n  var isReplaceMergeMode = mode === 'replaceMerge';\n  var isReplaceAllMode = mode === 'replaceAll';\n  existings = existings || [];\n  newCmptOptions = (newCmptOptions || []).slice();\n  var existingIdIdxMap = createHashMap(); // Validate id and name on user input option.\n\n  each(newCmptOptions, function (cmptOption, index) {\n    if (!isObject(cmptOption)) {\n      newCmptOptions[index] = null;\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // There is some legacy case that name is set as `false`.\n      // But should work normally rather than throw error.\n      if (cmptOption.id != null && !isValidIdOrName(cmptOption.id)) {\n        warnInvalidateIdOrName(cmptOption.id);\n      }\n\n      if (cmptOption.name != null && !isValidIdOrName(cmptOption.name)) {\n        warnInvalidateIdOrName(cmptOption.name);\n      }\n    }\n  });\n  var result = prepareResult(existings, existingIdIdxMap, mode);\n\n  if (isNormalMergeMode || isReplaceMergeMode) {\n    mappingById(result, existings, existingIdIdxMap, newCmptOptions);\n  }\n\n  if (isNormalMergeMode) {\n    mappingByName(result, newCmptOptions);\n  }\n\n  if (isNormalMergeMode || isReplaceMergeMode) {\n    mappingByIndex(result, newCmptOptions, isReplaceMergeMode);\n  } else if (isReplaceAllMode) {\n    mappingInReplaceAllMode(result, newCmptOptions);\n  }\n\n  makeIdAndName(result); // The array `result` MUST NOT contain elided items, otherwise the\n  // forEach will ommit those items and result in incorrect result.\n\n  return result;\n}\n\nfunction prepareResult(existings, existingIdIdxMap, mode) {\n  var result = [];\n\n  if (mode === 'replaceAll') {\n    return result;\n  } // Do not use native `map` to in case that the array `existings`\n  // contains elided items, which will be ommited.\n\n\n  for (var index = 0; index < existings.length; index++) {\n    var existing = existings[index]; // Because of replaceMerge, `existing` may be null/undefined.\n\n    if (existing && existing.id != null) {\n      existingIdIdxMap.set(existing.id, index);\n    } // For non-internal-componnets:\n    //     Mode \"normalMerge\": all existings kept.\n    //     Mode \"replaceMerge\": all existing removed unless mapped by id.\n    // For internal-components:\n    //     go with \"replaceMerge\" approach in both mode.\n\n\n    result.push({\n      existing: mode === 'replaceMerge' || isComponentIdInternal(existing) ? null : existing,\n      newOption: null,\n      keyInfo: null,\n      brandNew: null\n    });\n  }\n\n  return result;\n}\n\nfunction mappingById(result, existings, existingIdIdxMap, newCmptOptions) {\n  // Mapping by id if specified.\n  each(newCmptOptions, function (cmptOption, index) {\n    if (!cmptOption || cmptOption.id == null) {\n      return;\n    }\n\n    var optionId = makeComparableKey(cmptOption.id);\n    var existingIdx = existingIdIdxMap.get(optionId);\n\n    if (existingIdx != null) {\n      var resultItem = result[existingIdx];\n      assert(!resultItem.newOption, 'Duplicated option on id \"' + optionId + '\".');\n      resultItem.newOption = cmptOption; // In both mode, if id matched, new option will be merged to\n      // the existings rather than creating new component model.\n\n      resultItem.existing = existings[existingIdx];\n      newCmptOptions[index] = null;\n    }\n  });\n}\n\nfunction mappingByName(result, newCmptOptions) {\n  // Mapping by name if specified.\n  each(newCmptOptions, function (cmptOption, index) {\n    if (!cmptOption || cmptOption.name == null) {\n      return;\n    }\n\n    for (var i = 0; i < result.length; i++) {\n      var existing = result[i].existing;\n\n      if (!result[i].newOption // Consider name: two map to one.\n      // Can not match when both ids existing but different.\n      && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual('name', existing, cmptOption)) {\n        result[i].newOption = cmptOption;\n        newCmptOptions[index] = null;\n        return;\n      }\n    }\n  });\n}\n\nfunction mappingByIndex(result, newCmptOptions, brandNew) {\n  each(newCmptOptions, function (cmptOption) {\n    if (!cmptOption) {\n      return;\n    } // Find the first place that not mapped by id and not internal component (consider the \"hole\").\n\n\n    var resultItem;\n    var nextIdx = 0;\n\n    while ( // Be `!resultItem` only when `nextIdx >= result.length`.\n    (resultItem = result[nextIdx]) && ( // (1) Existing models that already have id should be able to mapped to. Because\n    // after mapping performed, model will always be assigned with an id if user not given.\n    // After that all models have id.\n    // (2) If new option has id, it can only set to a hole or append to the last. It should\n    // not be merged to the existings with different id. Because id should not be overwritten.\n    // (3) Name can be overwritten, because axis use name as 'show label text'.\n    resultItem.newOption || isComponentIdInternal(resultItem.existing) || // In mode \"replaceMerge\", here no not-mapped-non-internal-existing.\n    resultItem.existing && cmptOption.id != null && !keyExistAndEqual('id', cmptOption, resultItem.existing))) {\n      nextIdx++;\n    }\n\n    if (resultItem) {\n      resultItem.newOption = cmptOption;\n      resultItem.brandNew = brandNew;\n    } else {\n      result.push({\n        newOption: cmptOption,\n        brandNew: brandNew,\n        existing: null,\n        keyInfo: null\n      });\n    }\n\n    nextIdx++;\n  });\n}\n\nfunction mappingInReplaceAllMode(result, newCmptOptions) {\n  each(newCmptOptions, function (cmptOption) {\n    // The feature \"reproduce\" requires \"hole\" will also reproduced\n    // in case that compoennt index referring are broken.\n    result.push({\n      newOption: cmptOption,\n      brandNew: true,\n      existing: null,\n      keyInfo: null\n    });\n  });\n}\n/**\r\n * Make id and name for mapping result (result of mappingToExists)\r\n * into `keyInfo` field.\r\n */\n\n\nfunction makeIdAndName(mapResult) {\n  // We use this id to hash component models and view instances\n  // in echarts. id can be specified by user, or auto generated.\n  // The id generation rule ensures new view instance are able\n  // to mapped to old instance when setOption are called in\n  // no-merge mode. So we generate model id by name and plus\n  // type in view id.\n  // name can be duplicated among components, which is convenient\n  // to specify multi components (like series) by one name.\n  // Ensure that each id is distinct.\n  var idMap = createHashMap();\n  each(mapResult, function (item) {\n    var existing = item.existing;\n    existing && idMap.set(existing.id, item);\n  });\n  each(mapResult, function (item) {\n    var opt = item.newOption; // Force ensure id not duplicated.\n\n    assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));\n    opt && opt.id != null && idMap.set(opt.id, item);\n    !item.keyInfo && (item.keyInfo = {});\n  }); // Make name and id.\n\n  each(mapResult, function (item, index) {\n    var existing = item.existing;\n    var opt = item.newOption;\n    var keyInfo = item.keyInfo;\n\n    if (!isObject(opt)) {\n      return;\n    } // name can be overwitten. Consider case: axis.name = '20km'.\n    // But id generated by name will not be changed, which affect\n    // only in that case: setOption with 'not merge mode' and view\n    // instance will be recreated, which can be accepted.\n\n\n    keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name // Avoid diffferent series has the same name,\n    // because name may be used like in color pallet.\n    : DUMMY_COMPONENT_NAME_PREFIX + index;\n\n    if (existing) {\n      keyInfo.id = makeComparableKey(existing.id);\n    } else if (opt.id != null) {\n      keyInfo.id = makeComparableKey(opt.id);\n    } else {\n      // Consider this situatoin:\n      //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n      //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n      // Series with the same name between optionA and optionB\n      // should be mapped.\n      var idNum = 0;\n\n      do {\n        keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n      } while (idMap.get(keyInfo.id));\n    }\n\n    idMap.set(keyInfo.id, item);\n  });\n}\n\nfunction keyExistAndEqual(attr, obj1, obj2) {\n  var key1 = convertOptionIdName(obj1[attr], null);\n  var key2 = convertOptionIdName(obj2[attr], null); // See `MappingExistingItem`. `id` and `name` trade string equals to number.\n\n  return key1 != null && key2 != null && key1 === key2;\n}\n/**\r\n * @return return null if not exist.\r\n */\n\n\nfunction makeComparableKey(val) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (val == null) {\n      throw new Error();\n    }\n  }\n\n  return convertOptionIdName(val, '');\n}\n\nexport function convertOptionIdName(idOrName, defaultValue) {\n  if (idOrName == null) {\n    return defaultValue;\n  }\n\n  return isString(idOrName) ? idOrName : isNumber(idOrName) || isStringSafe(idOrName) ? idOrName + '' : defaultValue;\n}\n\nfunction warnInvalidateIdOrName(idOrName) {\n  if (process.env.NODE_ENV !== 'production') {\n    warn('`' + idOrName + '` is invalid id or name. Must be a string or number.');\n  }\n}\n\nfunction isValidIdOrName(idOrName) {\n  return isStringSafe(idOrName) || isNumeric(idOrName);\n}\n\nexport function isNameSpecified(componentModel) {\n  var name = componentModel.name; // Is specified when `indexOf` get -1 or > 0.\n\n  return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));\n}\n/**\r\n * @public\r\n * @param {Object} cmptOption\r\n * @return {boolean}\r\n */\n\nexport function isComponentIdInternal(cmptOption) {\n  return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;\n}\nexport function makeInternalComponentId(idSuffix) {\n  return INTERNAL_COMPONENT_ID_PREFIX + idSuffix;\n}\nexport function setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {\n  // Set mainType and complete subType.\n  each(mappingResult, function (item) {\n    var newOption = item.newOption;\n\n    if (isObject(newOption)) {\n      item.keyInfo.mainType = mainType;\n      item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);\n    }\n  });\n}\n\nfunction determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {\n  var subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.\n  : componentModelCtor.determineSubType(mainType, newCmptOption); // tooltip, markline, markpoint may always has no subType\n\n  return subType;\n}\n/**\r\n * A helper for removing duplicate items between batchA and batchB,\r\n * and in themselves, and categorize by series.\r\n *\r\n * @param batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\r\n * @param batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\r\n * @return result: [resultBatchA, resultBatchB]\r\n */\n\n\nexport function compressBatches(batchA, batchB) {\n  var mapA = {};\n  var mapB = {};\n  makeMap(batchA || [], mapA);\n  makeMap(batchB || [], mapB, mapA);\n  return [mapToArray(mapA), mapToArray(mapB)];\n\n  function makeMap(sourceBatch, map, otherMap) {\n    for (var i = 0, len = sourceBatch.length; i < len; i++) {\n      var seriesId = convertOptionIdName(sourceBatch[i].seriesId, null);\n\n      if (seriesId == null) {\n        return;\n      }\n\n      var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);\n      var otherDataIndices = otherMap && otherMap[seriesId];\n\n      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n        var dataIndex = dataIndices[j];\n\n        if (otherDataIndices && otherDataIndices[dataIndex]) {\n          otherDataIndices[dataIndex] = null;\n        } else {\n          (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n        }\n      }\n    }\n  }\n\n  function mapToArray(map, isData) {\n    var result = [];\n\n    for (var i in map) {\n      if (map.hasOwnProperty(i) && map[i] != null) {\n        if (isData) {\n          result.push(+i);\n        } else {\n          var dataIndices = mapToArray(map[i], true);\n          dataIndices.length && result.push({\n            seriesId: i,\n            dataIndex: dataIndices\n          });\n        }\n      }\n    }\n\n    return result;\n  }\n}\n/**\r\n * @param payload Contains dataIndex (means rawIndex) / dataIndexInside / name\r\n *                         each of which can be Array or primary type.\r\n * @return dataIndex If not found, return undefined/null.\r\n */\n\nexport function queryDataIndex(data, payload) {\n  if (payload.dataIndexInside != null) {\n    return payload.dataIndexInside;\n  } else if (payload.dataIndex != null) {\n    return isArray(payload.dataIndex) ? map(payload.dataIndex, function (value) {\n      return data.indexOfRawIndex(value);\n    }) : data.indexOfRawIndex(payload.dataIndex);\n  } else if (payload.name != null) {\n    return isArray(payload.name) ? map(payload.name, function (value) {\n      return data.indexOfName(value);\n    }) : data.indexOfName(payload.name);\n  }\n}\n/**\r\n * Enable property storage to any host object.\r\n * Notice: Serialization is not supported.\r\n *\r\n * For example:\r\n * let inner = zrUitl.makeInner();\r\n *\r\n * function some1(hostObj) {\r\n *      inner(hostObj).someProperty = 1212;\r\n *      ...\r\n * }\r\n * function some2() {\r\n *      let fields = inner(this);\r\n *      fields.someProperty1 = 1212;\r\n *      fields.someProperty2 = 'xx';\r\n *      ...\r\n * }\r\n *\r\n * @return {Function}\r\n */\n\nexport function makeInner() {\n  var key = '__ec_inner_' + innerUniqueIndex++;\n  return function (hostObj) {\n    return hostObj[key] || (hostObj[key] = {});\n  };\n}\nvar innerUniqueIndex = getRandomIdBase();\n/**\r\n * The same behavior as `component.getReferringComponents`.\r\n */\n\nexport function parseFinder(ecModel, finderInput, opt) {\n  var _a = preParseFinder(finderInput, opt),\n      mainTypeSpecified = _a.mainTypeSpecified,\n      queryOptionMap = _a.queryOptionMap,\n      others = _a.others;\n\n  var result = others;\n  var defaultMainType = opt ? opt.defaultMainType : null;\n\n  if (!mainTypeSpecified && defaultMainType) {\n    queryOptionMap.set(defaultMainType, {});\n  }\n\n  queryOptionMap.each(function (queryOption, mainType) {\n    var queryResult = queryReferringComponents(ecModel, mainType, queryOption, {\n      useDefault: defaultMainType === mainType,\n      enableAll: opt && opt.enableAll != null ? opt.enableAll : true,\n      enableNone: opt && opt.enableNone != null ? opt.enableNone : true\n    });\n    result[mainType + 'Models'] = queryResult.models;\n    result[mainType + 'Model'] = queryResult.models[0];\n  });\n  return result;\n}\nexport function preParseFinder(finderInput, opt) {\n  var finder;\n\n  if (isString(finderInput)) {\n    var obj = {};\n    obj[finderInput + 'Index'] = 0;\n    finder = obj;\n  } else {\n    finder = finderInput;\n  }\n\n  var queryOptionMap = createHashMap();\n  var others = {};\n  var mainTypeSpecified = false;\n  each(finder, function (value, key) {\n    // Exclude 'dataIndex' and other illgal keys.\n    if (key === 'dataIndex' || key === 'dataIndexInside') {\n      others[key] = value;\n      return;\n    }\n\n    var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n    var mainType = parsedKey[1];\n    var queryType = (parsedKey[2] || '').toLowerCase();\n\n    if (!mainType || !queryType || opt && opt.includeMainTypes && indexOf(opt.includeMainTypes, mainType) < 0) {\n      return;\n    }\n\n    mainTypeSpecified = mainTypeSpecified || !!mainType;\n    var queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});\n    queryOption[queryType] = value;\n  });\n  return {\n    mainTypeSpecified: mainTypeSpecified,\n    queryOptionMap: queryOptionMap,\n    others: others\n  };\n}\nexport var SINGLE_REFERRING = {\n  useDefault: true,\n  enableAll: false,\n  enableNone: false\n};\nexport var MULTIPLE_REFERRING = {\n  useDefault: false,\n  enableAll: true,\n  enableNone: true\n};\nexport function queryReferringComponents(ecModel, mainType, userOption, opt) {\n  opt = opt || SINGLE_REFERRING;\n  var indexOption = userOption.index;\n  var idOption = userOption.id;\n  var nameOption = userOption.name;\n  var result = {\n    models: null,\n    specified: indexOption != null || idOption != null || nameOption != null\n  };\n\n  if (!result.specified) {\n    // Use the first as default if `useDefault`.\n    var firstCmpt = void 0;\n    result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];\n    return result;\n  }\n\n  if (indexOption === 'none' || indexOption === false) {\n    assert(opt.enableNone, '`\"none\"` or `false` is not a valid value on index option.');\n    result.models = [];\n    return result;\n  } // `queryComponents` will return all components if\n  // both all of index/id/name are null/undefined.\n\n\n  if (indexOption === 'all') {\n    assert(opt.enableAll, '`\"all\"` is not a valid value on index option.');\n    indexOption = idOption = nameOption = null;\n  }\n\n  result.models = ecModel.queryComponents({\n    mainType: mainType,\n    index: indexOption,\n    id: idOption,\n    name: nameOption\n  });\n  return result;\n}\nexport function setAttribute(dom, key, value) {\n  dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;\n}\nexport function getAttribute(dom, key) {\n  return dom.getAttribute ? dom.getAttribute(key) : dom[key];\n}\nexport function getTooltipRenderMode(renderModeOption) {\n  if (renderModeOption === 'auto') {\n    // Using html when `document` exists, use richText otherwise\n    return env.domSupported ? 'html' : 'richText';\n  } else {\n    return renderModeOption || 'html';\n  }\n}\n/**\r\n * Group a list by key.\r\n */\n\nexport function groupData(array, getKey // return key\n) {\n  var buckets = createHashMap();\n  var keys = [];\n  each(array, function (item) {\n    var key = getKey(item);\n    (buckets.get(key) || (keys.push(key), buckets.set(key, []))).push(item);\n  });\n  return {\n    keys: keys,\n    buckets: buckets\n  };\n}\n/**\r\n * Interpolate raw values of a series with percent\r\n *\r\n * @param data         data\r\n * @param labelModel   label model of the text element\r\n * @param sourceValue  start value. May be null/undefined when init.\r\n * @param targetValue  end value\r\n * @param percent      0~1 percentage; 0 uses start value while 1 uses end value\r\n * @return             interpolated values\r\n *                     If `sourceValue` and `targetValue` are `number`, return `number`.\r\n *                     If `sourceValue` and `targetValue` are `string`, return `string`.\r\n *                     If `sourceValue` and `targetValue` are `(string | number)[]`, return `(string | number)[]`.\r\n *                     Other cases do not supported.\r\n */\n\nexport function interpolateRawValues(data, precision, sourceValue, targetValue, percent) {\n  var isAutoPrecision = precision == null || precision === 'auto';\n\n  if (targetValue == null) {\n    return targetValue;\n  }\n\n  if (isNumber(targetValue)) {\n    var value = interpolateNumber(sourceValue || 0, targetValue, percent);\n    return round(value, isAutoPrecision ? Math.max(getPrecision(sourceValue || 0), getPrecision(targetValue)) : precision);\n  } else if (isString(targetValue)) {\n    return percent < 1 ? sourceValue : targetValue;\n  } else {\n    var interpolated = [];\n    var leftArr = sourceValue;\n    var rightArr = targetValue;\n    var length_1 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);\n\n    for (var i = 0; i < length_1; ++i) {\n      var info = data.getDimensionInfo(i); // Don't interpolate ordinal dims\n\n      if (info && info.type === 'ordinal') {\n        // In init, there is no `sourceValue`, but should better not to get undefined result.\n        interpolated[i] = (percent < 1 && leftArr ? leftArr : rightArr)[i];\n      } else {\n        var leftVal = leftArr && leftArr[i] ? leftArr[i] : 0;\n        var rightVal = rightArr[i];\n        var value = interpolateNumber(leftVal, rightVal, percent);\n        interpolated[i] = round(value, isAutoPrecision ? Math.max(getPrecision(leftVal), getPrecision(rightVal)) : precision);\n      }\n    }\n\n    return interpolated;\n  }\n}","map":{"version":3,"sources":["D:/Work/WorkSpace/GitWorkSpace/TenShop/resource/ElectronicMall/src/qingge-Market/qingge-vue/node_modules/echarts/lib/util/model.js"],"names":["each","isObject","isArray","createHashMap","map","assert","isString","indexOf","isStringSafe","isNumber","env","isNumeric","getRandomIdBase","getPrecision","round","warn","interpolateNumber","p0","p1","percent","DUMMY_COMPONENT_NAME_PREFIX","INTERNAL_COMPONENT_ID_PREFIX","normalizeToArray","value","Array","defaultEmphasis","opt","key","subOpts","emphasis","i","len","length","subOptName","hasOwnProperty","TEXT_STYLE_OPTIONS","getDataItemValue","dataItem","Date","isDataItemOption","mappingToExists","existings","newCmptOptions","mode","isNormalMergeMode","isReplaceMergeMode","isReplaceAllMode","slice","existingIdIdxMap","cmptOption","index","process","NODE_ENV","id","isValidIdOrName","warnInvalidateIdOrName","name","result","prepareResult","mappingById","mappingByName","mappingByIndex","mappingInReplaceAllMode","makeIdAndName","existing","set","push","isComponentIdInternal","newOption","keyInfo","brandNew","optionId","makeComparableKey","existingIdx","get","resultItem","keyExistAndEqual","nextIdx","mapResult","idMap","item","idNum","attr","obj1","obj2","key1","convertOptionIdName","key2","val","Error","idOrName","defaultValue","isNameSpecified","componentModel","makeInternalComponentId","idSuffix","setComponentTypeToKeyInfo","mappingResult","mainType","componentModelCtor","subType","determineSubType","newCmptOption","existComponent","type","compressBatches","batchA","batchB","mapA","mapB","makeMap","mapToArray","sourceBatch","otherMap","seriesId","dataIndices","dataIndex","otherDataIndices","j","lenj","isData","queryDataIndex","data","payload","dataIndexInside","indexOfRawIndex","indexOfName","makeInner","innerUniqueIndex","hostObj","parseFinder","ecModel","finderInput","_a","preParseFinder","mainTypeSpecified","queryOptionMap","others","defaultMainType","queryOption","queryResult","queryReferringComponents","useDefault","enableAll","enableNone","models","finder","obj","parsedKey","match","queryType","toLowerCase","includeMainTypes","SINGLE_REFERRING","MULTIPLE_REFERRING","userOption","indexOption","idOption","nameOption","specified","firstCmpt","getComponent","queryComponents","setAttribute","dom","getAttribute","getTooltipRenderMode","renderModeOption","domSupported","groupData","array","getKey","buckets","keys","interpolateRawValues","precision","sourceValue","targetValue","isAutoPrecision","Math","max","interpolated","leftArr","rightArr","length_1","info","getDimensionInfo","leftVal","rightVal"],"mappings":"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","sourcesContent":["\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n\r\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\nimport { each, isObject, isArray, createHashMap, map, assert, isString, indexOf, isStringSafe, isNumber } from 'zrender/lib/core/util.js';\r\nimport env from 'zrender/lib/core/env.js';\r\nimport { isNumeric, getRandomIdBase, getPrecision, round } from './number.js';\r\nimport { warn } from './log.js';\r\n\r\nfunction interpolateNumber(p0, p1, percent) {\r\n  return (p1 - p0) * percent + p0;\r\n}\r\n/**\r\n * Make the name displayable. But we should\r\n * make sure it is not duplicated with user\r\n * specified name, so use '\\0';\r\n */\r\n\r\n\r\nvar DUMMY_COMPONENT_NAME_PREFIX = 'series\\0';\r\nvar INTERNAL_COMPONENT_ID_PREFIX = '\\0_ec_\\0';\r\n/**\r\n * If value is not array, then translate it to array.\r\n * @param  {*} value\r\n * @return {Array} [value] or value\r\n */\r\n\r\nexport function normalizeToArray(value) {\r\n  return value instanceof Array ? value : value == null ? [] : [value];\r\n}\r\n/**\r\n * Sync default option between normal and emphasis like `position` and `show`\r\n * In case some one will write code like\r\n *     label: {\r\n *          show: false,\r\n *          position: 'outside',\r\n *          fontSize: 18\r\n *     },\r\n *     emphasis: {\r\n *          label: { show: true }\r\n *     }\r\n */\r\n\r\nexport function defaultEmphasis(opt, key, subOpts) {\r\n  // Caution: performance sensitive.\r\n  if (opt) {\r\n    opt[key] = opt[key] || {};\r\n    opt.emphasis = opt.emphasis || {};\r\n    opt.emphasis[key] = opt.emphasis[key] || {}; // Default emphasis option from normal\r\n\r\n    for (var i = 0, len = subOpts.length; i < len; i++) {\r\n      var subOptName = subOpts[i];\r\n\r\n      if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {\r\n        opt.emphasis[key][subOptName] = opt[key][subOptName];\r\n      }\r\n    }\r\n  }\r\n}\r\nexport var TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding']; // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([\r\n//     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',\r\n//     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',\r\n//     // FIXME: deprecated, check and remove it.\r\n//     'textStyle'\r\n// ]);\r\n\r\n/**\r\n * The method do not ensure performance.\r\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\r\n * This helper method retieves value from data.\r\n */\r\n\r\nexport function getDataItemValue(dataItem) {\r\n  return isObject(dataItem) && !isArray(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;\r\n}\r\n/**\r\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\r\n * This helper method determine if dataItem has extra option besides value\r\n */\r\n\r\nexport function isDataItemOption(dataItem) {\r\n  return isObject(dataItem) && !(dataItem instanceof Array); // // markLine data can be array\r\n  // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\r\n}\r\n;\r\n/**\r\n * Mapping to existings for merge.\r\n *\r\n * Mode \"normalMege\":\r\n *     The mapping result (merge result) will keep the order of the existing\r\n *     component, rather than the order of new option. Because we should ensure\r\n *     some specified index reference (like xAxisIndex) keep work.\r\n *     And in most cases, \"merge option\" is used to update partial option but not\r\n *     be expected to change the order.\r\n *\r\n * Mode \"replaceMege\":\r\n *     (1) Only the id mapped components will be merged.\r\n *     (2) Other existing components (except internal compoonets) will be removed.\r\n *     (3) Other new options will be used to create new component.\r\n *     (4) The index of the existing compoents will not be modified.\r\n *     That means their might be \"hole\" after the removal.\r\n *     The new components are created first at those available index.\r\n *\r\n * Mode \"replaceAll\":\r\n *     This mode try to support that reproduce an echarts instance from another\r\n *     echarts instance (via `getOption`) in some simple cases.\r\n *     In this senario, the `result` index are exactly the consistent with the `newCmptOptions`,\r\n *     which ensures the compoennt index referring (like `xAxisIndex: ?`) corrent. That is,\r\n *     the \"hole\" in `newCmptOptions` will also be kept.\r\n *     On the contrary, other modes try best to eliminate holes.\r\n *     PENDING: This is an experimental mode yet.\r\n *\r\n * @return See the comment of <MappingResult>.\r\n */\r\n\r\nexport function mappingToExists(existings, newCmptOptions, mode) {\r\n  var isNormalMergeMode = mode === 'normalMerge';\r\n  var isReplaceMergeMode = mode === 'replaceMerge';\r\n  var isReplaceAllMode = mode === 'replaceAll';\r\n  existings = existings || [];\r\n  newCmptOptions = (newCmptOptions || []).slice();\r\n  var existingIdIdxMap = createHashMap(); // Validate id and name on user input option.\r\n\r\n  each(newCmptOptions, function (cmptOption, index) {\r\n    if (!isObject(cmptOption)) {\r\n      newCmptOptions[index] = null;\r\n      return;\r\n    }\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      // There is some legacy case that name is set as `false`.\r\n      // But should work normally rather than throw error.\r\n      if (cmptOption.id != null && !isValidIdOrName(cmptOption.id)) {\r\n        warnInvalidateIdOrName(cmptOption.id);\r\n      }\r\n\r\n      if (cmptOption.name != null && !isValidIdOrName(cmptOption.name)) {\r\n        warnInvalidateIdOrName(cmptOption.name);\r\n      }\r\n    }\r\n  });\r\n  var result = prepareResult(existings, existingIdIdxMap, mode);\r\n\r\n  if (isNormalMergeMode || isReplaceMergeMode) {\r\n    mappingById(result, existings, existingIdIdxMap, newCmptOptions);\r\n  }\r\n\r\n  if (isNormalMergeMode) {\r\n    mappingByName(result, newCmptOptions);\r\n  }\r\n\r\n  if (isNormalMergeMode || isReplaceMergeMode) {\r\n    mappingByIndex(result, newCmptOptions, isReplaceMergeMode);\r\n  } else if (isReplaceAllMode) {\r\n    mappingInReplaceAllMode(result, newCmptOptions);\r\n  }\r\n\r\n  makeIdAndName(result); // The array `result` MUST NOT contain elided items, otherwise the\r\n  // forEach will ommit those items and result in incorrect result.\r\n\r\n  return result;\r\n}\r\n\r\nfunction prepareResult(existings, existingIdIdxMap, mode) {\r\n  var result = [];\r\n\r\n  if (mode === 'replaceAll') {\r\n    return result;\r\n  } // Do not use native `map` to in case that the array `existings`\r\n  // contains elided items, which will be ommited.\r\n\r\n\r\n  for (var index = 0; index < existings.length; index++) {\r\n    var existing = existings[index]; // Because of replaceMerge, `existing` may be null/undefined.\r\n\r\n    if (existing && existing.id != null) {\r\n      existingIdIdxMap.set(existing.id, index);\r\n    } // For non-internal-componnets:\r\n    //     Mode \"normalMerge\": all existings kept.\r\n    //     Mode \"replaceMerge\": all existing removed unless mapped by id.\r\n    // For internal-components:\r\n    //     go with \"replaceMerge\" approach in both mode.\r\n\r\n\r\n    result.push({\r\n      existing: mode === 'replaceMerge' || isComponentIdInternal(existing) ? null : existing,\r\n      newOption: null,\r\n      keyInfo: null,\r\n      brandNew: null\r\n    });\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction mappingById(result, existings, existingIdIdxMap, newCmptOptions) {\r\n  // Mapping by id if specified.\r\n  each(newCmptOptions, function (cmptOption, index) {\r\n    if (!cmptOption || cmptOption.id == null) {\r\n      return;\r\n    }\r\n\r\n    var optionId = makeComparableKey(cmptOption.id);\r\n    var existingIdx = existingIdIdxMap.get(optionId);\r\n\r\n    if (existingIdx != null) {\r\n      var resultItem = result[existingIdx];\r\n      assert(!resultItem.newOption, 'Duplicated option on id \"' + optionId + '\".');\r\n      resultItem.newOption = cmptOption; // In both mode, if id matched, new option will be merged to\r\n      // the existings rather than creating new component model.\r\n\r\n      resultItem.existing = existings[existingIdx];\r\n      newCmptOptions[index] = null;\r\n    }\r\n  });\r\n}\r\n\r\nfunction mappingByName(result, newCmptOptions) {\r\n  // Mapping by name if specified.\r\n  each(newCmptOptions, function (cmptOption, index) {\r\n    if (!cmptOption || cmptOption.name == null) {\r\n      return;\r\n    }\r\n\r\n    for (var i = 0; i < result.length; i++) {\r\n      var existing = result[i].existing;\r\n\r\n      if (!result[i].newOption // Consider name: two map to one.\r\n      // Can not match when both ids existing but different.\r\n      && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual('name', existing, cmptOption)) {\r\n        result[i].newOption = cmptOption;\r\n        newCmptOptions[index] = null;\r\n        return;\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nfunction mappingByIndex(result, newCmptOptions, brandNew) {\r\n  each(newCmptOptions, function (cmptOption) {\r\n    if (!cmptOption) {\r\n      return;\r\n    } // Find the first place that not mapped by id and not internal component (consider the \"hole\").\r\n\r\n\r\n    var resultItem;\r\n    var nextIdx = 0;\r\n\r\n    while ( // Be `!resultItem` only when `nextIdx >= result.length`.\r\n    (resultItem = result[nextIdx]) && ( // (1) Existing models that already have id should be able to mapped to. Because\r\n    // after mapping performed, model will always be assigned with an id if user not given.\r\n    // After that all models have id.\r\n    // (2) If new option has id, it can only set to a hole or append to the last. It should\r\n    // not be merged to the existings with different id. Because id should not be overwritten.\r\n    // (3) Name can be overwritten, because axis use name as 'show label text'.\r\n    resultItem.newOption || isComponentIdInternal(resultItem.existing) || // In mode \"replaceMerge\", here no not-mapped-non-internal-existing.\r\n    resultItem.existing && cmptOption.id != null && !keyExistAndEqual('id', cmptOption, resultItem.existing))) {\r\n      nextIdx++;\r\n    }\r\n\r\n    if (resultItem) {\r\n      resultItem.newOption = cmptOption;\r\n      resultItem.brandNew = brandNew;\r\n    } else {\r\n      result.push({\r\n        newOption: cmptOption,\r\n        brandNew: brandNew,\r\n        existing: null,\r\n        keyInfo: null\r\n      });\r\n    }\r\n\r\n    nextIdx++;\r\n  });\r\n}\r\n\r\nfunction mappingInReplaceAllMode(result, newCmptOptions) {\r\n  each(newCmptOptions, function (cmptOption) {\r\n    // The feature \"reproduce\" requires \"hole\" will also reproduced\r\n    // in case that compoennt index referring are broken.\r\n    result.push({\r\n      newOption: cmptOption,\r\n      brandNew: true,\r\n      existing: null,\r\n      keyInfo: null\r\n    });\r\n  });\r\n}\r\n/**\r\n * Make id and name for mapping result (result of mappingToExists)\r\n * into `keyInfo` field.\r\n */\r\n\r\n\r\nfunction makeIdAndName(mapResult) {\r\n  // We use this id to hash component models and view instances\r\n  // in echarts. id can be specified by user, or auto generated.\r\n  // The id generation rule ensures new view instance are able\r\n  // to mapped to old instance when setOption are called in\r\n  // no-merge mode. So we generate model id by name and plus\r\n  // type in view id.\r\n  // name can be duplicated among components, which is convenient\r\n  // to specify multi components (like series) by one name.\r\n  // Ensure that each id is distinct.\r\n  var idMap = createHashMap();\r\n  each(mapResult, function (item) {\r\n    var existing = item.existing;\r\n    existing && idMap.set(existing.id, item);\r\n  });\r\n  each(mapResult, function (item) {\r\n    var opt = item.newOption; // Force ensure id not duplicated.\r\n\r\n    assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));\r\n    opt && opt.id != null && idMap.set(opt.id, item);\r\n    !item.keyInfo && (item.keyInfo = {});\r\n  }); // Make name and id.\r\n\r\n  each(mapResult, function (item, index) {\r\n    var existing = item.existing;\r\n    var opt = item.newOption;\r\n    var keyInfo = item.keyInfo;\r\n\r\n    if (!isObject(opt)) {\r\n      return;\r\n    } // name can be overwitten. Consider case: axis.name = '20km'.\r\n    // But id generated by name will not be changed, which affect\r\n    // only in that case: setOption with 'not merge mode' and view\r\n    // instance will be recreated, which can be accepted.\r\n\r\n\r\n    keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name // Avoid diffferent series has the same name,\r\n    // because name may be used like in color pallet.\r\n    : DUMMY_COMPONENT_NAME_PREFIX + index;\r\n\r\n    if (existing) {\r\n      keyInfo.id = makeComparableKey(existing.id);\r\n    } else if (opt.id != null) {\r\n      keyInfo.id = makeComparableKey(opt.id);\r\n    } else {\r\n      // Consider this situatoin:\r\n      //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\r\n      //  optionB [{..}, {name: 'a'}, {name: 'a'}]\r\n      // Series with the same name between optionA and optionB\r\n      // should be mapped.\r\n      var idNum = 0;\r\n\r\n      do {\r\n        keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\r\n      } while (idMap.get(keyInfo.id));\r\n    }\r\n\r\n    idMap.set(keyInfo.id, item);\r\n  });\r\n}\r\n\r\nfunction keyExistAndEqual(attr, obj1, obj2) {\r\n  var key1 = convertOptionIdName(obj1[attr], null);\r\n  var key2 = convertOptionIdName(obj2[attr], null); // See `MappingExistingItem`. `id` and `name` trade string equals to number.\r\n\r\n  return key1 != null && key2 != null && key1 === key2;\r\n}\r\n/**\r\n * @return return null if not exist.\r\n */\r\n\r\n\r\nfunction makeComparableKey(val) {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (val == null) {\r\n      throw new Error();\r\n    }\r\n  }\r\n\r\n  return convertOptionIdName(val, '');\r\n}\r\n\r\nexport function convertOptionIdName(idOrName, defaultValue) {\r\n  if (idOrName == null) {\r\n    return defaultValue;\r\n  }\r\n\r\n  return isString(idOrName) ? idOrName : isNumber(idOrName) || isStringSafe(idOrName) ? idOrName + '' : defaultValue;\r\n}\r\n\r\nfunction warnInvalidateIdOrName(idOrName) {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    warn('`' + idOrName + '` is invalid id or name. Must be a string or number.');\r\n  }\r\n}\r\n\r\nfunction isValidIdOrName(idOrName) {\r\n  return isStringSafe(idOrName) || isNumeric(idOrName);\r\n}\r\n\r\nexport function isNameSpecified(componentModel) {\r\n  var name = componentModel.name; // Is specified when `indexOf` get -1 or > 0.\r\n\r\n  return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));\r\n}\r\n/**\r\n * @public\r\n * @param {Object} cmptOption\r\n * @return {boolean}\r\n */\r\n\r\nexport function isComponentIdInternal(cmptOption) {\r\n  return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;\r\n}\r\nexport function makeInternalComponentId(idSuffix) {\r\n  return INTERNAL_COMPONENT_ID_PREFIX + idSuffix;\r\n}\r\nexport function setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {\r\n  // Set mainType and complete subType.\r\n  each(mappingResult, function (item) {\r\n    var newOption = item.newOption;\r\n\r\n    if (isObject(newOption)) {\r\n      item.keyInfo.mainType = mainType;\r\n      item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);\r\n    }\r\n  });\r\n}\r\n\r\nfunction determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {\r\n  var subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.\r\n  : componentModelCtor.determineSubType(mainType, newCmptOption); // tooltip, markline, markpoint may always has no subType\r\n\r\n  return subType;\r\n}\r\n/**\r\n * A helper for removing duplicate items between batchA and batchB,\r\n * and in themselves, and categorize by series.\r\n *\r\n * @param batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\r\n * @param batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\r\n * @return result: [resultBatchA, resultBatchB]\r\n */\r\n\r\n\r\nexport function compressBatches(batchA, batchB) {\r\n  var mapA = {};\r\n  var mapB = {};\r\n  makeMap(batchA || [], mapA);\r\n  makeMap(batchB || [], mapB, mapA);\r\n  return [mapToArray(mapA), mapToArray(mapB)];\r\n\r\n  function makeMap(sourceBatch, map, otherMap) {\r\n    for (var i = 0, len = sourceBatch.length; i < len; i++) {\r\n      var seriesId = convertOptionIdName(sourceBatch[i].seriesId, null);\r\n\r\n      if (seriesId == null) {\r\n        return;\r\n      }\r\n\r\n      var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);\r\n      var otherDataIndices = otherMap && otherMap[seriesId];\r\n\r\n      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\r\n        var dataIndex = dataIndices[j];\r\n\r\n        if (otherDataIndices && otherDataIndices[dataIndex]) {\r\n          otherDataIndices[dataIndex] = null;\r\n        } else {\r\n          (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function mapToArray(map, isData) {\r\n    var result = [];\r\n\r\n    for (var i in map) {\r\n      if (map.hasOwnProperty(i) && map[i] != null) {\r\n        if (isData) {\r\n          result.push(+i);\r\n        } else {\r\n          var dataIndices = mapToArray(map[i], true);\r\n          dataIndices.length && result.push({\r\n            seriesId: i,\r\n            dataIndex: dataIndices\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n/**\r\n * @param payload Contains dataIndex (means rawIndex) / dataIndexInside / name\r\n *                         each of which can be Array or primary type.\r\n * @return dataIndex If not found, return undefined/null.\r\n */\r\n\r\nexport function queryDataIndex(data, payload) {\r\n  if (payload.dataIndexInside != null) {\r\n    return payload.dataIndexInside;\r\n  } else if (payload.dataIndex != null) {\r\n    return isArray(payload.dataIndex) ? map(payload.dataIndex, function (value) {\r\n      return data.indexOfRawIndex(value);\r\n    }) : data.indexOfRawIndex(payload.dataIndex);\r\n  } else if (payload.name != null) {\r\n    return isArray(payload.name) ? map(payload.name, function (value) {\r\n      return data.indexOfName(value);\r\n    }) : data.indexOfName(payload.name);\r\n  }\r\n}\r\n/**\r\n * Enable property storage to any host object.\r\n * Notice: Serialization is not supported.\r\n *\r\n * For example:\r\n * let inner = zrUitl.makeInner();\r\n *\r\n * function some1(hostObj) {\r\n *      inner(hostObj).someProperty = 1212;\r\n *      ...\r\n * }\r\n * function some2() {\r\n *      let fields = inner(this);\r\n *      fields.someProperty1 = 1212;\r\n *      fields.someProperty2 = 'xx';\r\n *      ...\r\n * }\r\n *\r\n * @return {Function}\r\n */\r\n\r\nexport function makeInner() {\r\n  var key = '__ec_inner_' + innerUniqueIndex++;\r\n  return function (hostObj) {\r\n    return hostObj[key] || (hostObj[key] = {});\r\n  };\r\n}\r\nvar innerUniqueIndex = getRandomIdBase();\r\n/**\r\n * The same behavior as `component.getReferringComponents`.\r\n */\r\n\r\nexport function parseFinder(ecModel, finderInput, opt) {\r\n  var _a = preParseFinder(finderInput, opt),\r\n      mainTypeSpecified = _a.mainTypeSpecified,\r\n      queryOptionMap = _a.queryOptionMap,\r\n      others = _a.others;\r\n\r\n  var result = others;\r\n  var defaultMainType = opt ? opt.defaultMainType : null;\r\n\r\n  if (!mainTypeSpecified && defaultMainType) {\r\n    queryOptionMap.set(defaultMainType, {});\r\n  }\r\n\r\n  queryOptionMap.each(function (queryOption, mainType) {\r\n    var queryResult = queryReferringComponents(ecModel, mainType, queryOption, {\r\n      useDefault: defaultMainType === mainType,\r\n      enableAll: opt && opt.enableAll != null ? opt.enableAll : true,\r\n      enableNone: opt && opt.enableNone != null ? opt.enableNone : true\r\n    });\r\n    result[mainType + 'Models'] = queryResult.models;\r\n    result[mainType + 'Model'] = queryResult.models[0];\r\n  });\r\n  return result;\r\n}\r\nexport function preParseFinder(finderInput, opt) {\r\n  var finder;\r\n\r\n  if (isString(finderInput)) {\r\n    var obj = {};\r\n    obj[finderInput + 'Index'] = 0;\r\n    finder = obj;\r\n  } else {\r\n    finder = finderInput;\r\n  }\r\n\r\n  var queryOptionMap = createHashMap();\r\n  var others = {};\r\n  var mainTypeSpecified = false;\r\n  each(finder, function (value, key) {\r\n    // Exclude 'dataIndex' and other illgal keys.\r\n    if (key === 'dataIndex' || key === 'dataIndexInside') {\r\n      others[key] = value;\r\n      return;\r\n    }\r\n\r\n    var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\r\n    var mainType = parsedKey[1];\r\n    var queryType = (parsedKey[2] || '').toLowerCase();\r\n\r\n    if (!mainType || !queryType || opt && opt.includeMainTypes && indexOf(opt.includeMainTypes, mainType) < 0) {\r\n      return;\r\n    }\r\n\r\n    mainTypeSpecified = mainTypeSpecified || !!mainType;\r\n    var queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});\r\n    queryOption[queryType] = value;\r\n  });\r\n  return {\r\n    mainTypeSpecified: mainTypeSpecified,\r\n    queryOptionMap: queryOptionMap,\r\n    others: others\r\n  };\r\n}\r\nexport var SINGLE_REFERRING = {\r\n  useDefault: true,\r\n  enableAll: false,\r\n  enableNone: false\r\n};\r\nexport var MULTIPLE_REFERRING = {\r\n  useDefault: false,\r\n  enableAll: true,\r\n  enableNone: true\r\n};\r\nexport function queryReferringComponents(ecModel, mainType, userOption, opt) {\r\n  opt = opt || SINGLE_REFERRING;\r\n  var indexOption = userOption.index;\r\n  var idOption = userOption.id;\r\n  var nameOption = userOption.name;\r\n  var result = {\r\n    models: null,\r\n    specified: indexOption != null || idOption != null || nameOption != null\r\n  };\r\n\r\n  if (!result.specified) {\r\n    // Use the first as default if `useDefault`.\r\n    var firstCmpt = void 0;\r\n    result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];\r\n    return result;\r\n  }\r\n\r\n  if (indexOption === 'none' || indexOption === false) {\r\n    assert(opt.enableNone, '`\"none\"` or `false` is not a valid value on index option.');\r\n    result.models = [];\r\n    return result;\r\n  } // `queryComponents` will return all components if\r\n  // both all of index/id/name are null/undefined.\r\n\r\n\r\n  if (indexOption === 'all') {\r\n    assert(opt.enableAll, '`\"all\"` is not a valid value on index option.');\r\n    indexOption = idOption = nameOption = null;\r\n  }\r\n\r\n  result.models = ecModel.queryComponents({\r\n    mainType: mainType,\r\n    index: indexOption,\r\n    id: idOption,\r\n    name: nameOption\r\n  });\r\n  return result;\r\n}\r\nexport function setAttribute(dom, key, value) {\r\n  dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;\r\n}\r\nexport function getAttribute(dom, key) {\r\n  return dom.getAttribute ? dom.getAttribute(key) : dom[key];\r\n}\r\nexport function getTooltipRenderMode(renderModeOption) {\r\n  if (renderModeOption === 'auto') {\r\n    // Using html when `document` exists, use richText otherwise\r\n    return env.domSupported ? 'html' : 'richText';\r\n  } else {\r\n    return renderModeOption || 'html';\r\n  }\r\n}\r\n/**\r\n * Group a list by key.\r\n */\r\n\r\nexport function groupData(array, getKey // return key\r\n) {\r\n  var buckets = createHashMap();\r\n  var keys = [];\r\n  each(array, function (item) {\r\n    var key = getKey(item);\r\n    (buckets.get(key) || (keys.push(key), buckets.set(key, []))).push(item);\r\n  });\r\n  return {\r\n    keys: keys,\r\n    buckets: buckets\r\n  };\r\n}\r\n/**\r\n * Interpolate raw values of a series with percent\r\n *\r\n * @param data         data\r\n * @param labelModel   label model of the text element\r\n * @param sourceValue  start value. May be null/undefined when init.\r\n * @param targetValue  end value\r\n * @param percent      0~1 percentage; 0 uses start value while 1 uses end value\r\n * @return             interpolated values\r\n *                     If `sourceValue` and `targetValue` are `number`, return `number`.\r\n *                     If `sourceValue` and `targetValue` are `string`, return `string`.\r\n *                     If `sourceValue` and `targetValue` are `(string | number)[]`, return `(string | number)[]`.\r\n *                     Other cases do not supported.\r\n */\r\n\r\nexport function interpolateRawValues(data, precision, sourceValue, targetValue, percent) {\r\n  var isAutoPrecision = precision == null || precision === 'auto';\r\n\r\n  if (targetValue == null) {\r\n    return targetValue;\r\n  }\r\n\r\n  if (isNumber(targetValue)) {\r\n    var value = interpolateNumber(sourceValue || 0, targetValue, percent);\r\n    return round(value, isAutoPrecision ? Math.max(getPrecision(sourceValue || 0), getPrecision(targetValue)) : precision);\r\n  } else if (isString(targetValue)) {\r\n    return percent < 1 ? sourceValue : targetValue;\r\n  } else {\r\n    var interpolated = [];\r\n    var leftArr = sourceValue;\r\n    var rightArr = targetValue;\r\n    var length_1 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);\r\n\r\n    for (var i = 0; i < length_1; ++i) {\r\n      var info = data.getDimensionInfo(i); // Don't interpolate ordinal dims\r\n\r\n      if (info && info.type === 'ordinal') {\r\n        // In init, there is no `sourceValue`, but should better not to get undefined result.\r\n        interpolated[i] = (percent < 1 && leftArr ? leftArr : rightArr)[i];\r\n      } else {\r\n        var leftVal = leftArr && leftArr[i] ? leftArr[i] : 0;\r\n        var rightVal = rightArr[i];\r\n        var value = interpolateNumber(leftVal, rightVal, percent);\r\n        interpolated[i] = round(value, isAutoPrecision ? Math.max(getPrecision(leftVal), getPrecision(rightVal)) : precision);\r\n      }\r\n    }\r\n\r\n    return interpolated;\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}