{"ast":null,"code":"import \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.array.fill.js\";\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport PointerPath from './PointerPath.js';\nimport * as graphic from '../../util/graphic.js';\nimport { setStatesStylesFromModel, toggleHoverEmphasis } from '../../util/states.js';\nimport { createTextStyle, setLabelValueAnimation, animateLabelValue } from '../../label/labelStyle.js';\nimport ChartView from '../../view/Chart.js';\nimport { parsePercent, round, linearMap } from '../../util/number.js';\nimport Sausage from '../../util/shape/sausage.js';\nimport { createSymbol } from '../../util/symbol.js';\nimport ZRImage from 'zrender/lib/graphic/Image.js';\nimport { extend, isFunction, isString, isNumber, each } from 'zrender/lib/core/util.js';\nimport { setCommonECData } from '../../util/innerStore.js';\nimport { normalizeArcAngles } from 'zrender/lib/core/PathProxy.js';\n\nfunction parsePosition(seriesModel, api) {\n  var center = seriesModel.get('center');\n  var width = api.getWidth();\n  var height = api.getHeight();\n  var size = Math.min(width, height);\n  var cx = parsePercent(center[0], api.getWidth());\n  var cy = parsePercent(center[1], api.getHeight());\n  var r = parsePercent(seriesModel.get('radius'), size / 2);\n  return {\n    cx: cx,\n    cy: cy,\n    r: r\n  };\n}\n\nfunction formatLabel(value, labelFormatter) {\n  var label = value == null ? '' : value + '';\n\n  if (labelFormatter) {\n    if (isString(labelFormatter)) {\n      label = labelFormatter.replace('{value}', label);\n    } else if (isFunction(labelFormatter)) {\n      label = labelFormatter(value);\n    }\n  }\n\n  return label;\n}\n\nvar GaugeView =\n/** @class */\nfunction (_super) {\n  __extends(GaugeView, _super);\n\n  function GaugeView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = GaugeView.type;\n    return _this;\n  }\n\n  GaugeView.prototype.render = function (seriesModel, ecModel, api) {\n    this.group.removeAll();\n    var colorList = seriesModel.get(['axisLine', 'lineStyle', 'color']);\n    var posInfo = parsePosition(seriesModel, api);\n\n    this._renderMain(seriesModel, ecModel, api, colorList, posInfo);\n\n    this._data = seriesModel.getData();\n  };\n\n  GaugeView.prototype.dispose = function () {};\n\n  GaugeView.prototype._renderMain = function (seriesModel, ecModel, api, colorList, posInfo) {\n    var group = this.group;\n    var clockwise = seriesModel.get('clockwise');\n    var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;\n    var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;\n    var axisLineModel = seriesModel.getModel('axisLine');\n    var roundCap = axisLineModel.get('roundCap');\n    var MainPath = roundCap ? Sausage : graphic.Sector;\n    var showAxis = axisLineModel.get('show');\n    var lineStyleModel = axisLineModel.getModel('lineStyle');\n    var axisLineWidth = lineStyleModel.get('width');\n    var angles = [startAngle, endAngle];\n    normalizeArcAngles(angles, !clockwise);\n    startAngle = angles[0];\n    endAngle = angles[1];\n    var angleRangeSpan = endAngle - startAngle;\n    var prevEndAngle = startAngle;\n    var sectors = [];\n\n    for (var i = 0; showAxis && i < colorList.length; i++) {\n      // Clamp\n      var percent = Math.min(Math.max(colorList[i][0], 0), 1);\n      endAngle = startAngle + angleRangeSpan * percent;\n      var sector = new MainPath({\n        shape: {\n          startAngle: prevEndAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: posInfo.r - axisLineWidth,\n          r: posInfo.r\n        },\n        silent: true\n      });\n      sector.setStyle({\n        fill: colorList[i][1]\n      });\n      sector.setStyle(lineStyleModel.getLineStyle( // Because we use sector to simulate arc\n      // so the properties for stroking are useless\n      ['color', 'width']));\n      sectors.push(sector);\n      prevEndAngle = endAngle;\n    }\n\n    sectors.reverse();\n    each(sectors, function (sector) {\n      return group.add(sector);\n    });\n\n    var getColor = function getColor(percent) {\n      // Less than 0\n      if (percent <= 0) {\n        return colorList[0][1];\n      }\n\n      var i;\n\n      for (i = 0; i < colorList.length; i++) {\n        if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {\n          return colorList[i][1];\n        }\n      } // More than 1\n\n\n      return colorList[i - 1][1];\n    };\n\n    this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);\n\n    this._renderTitleAndDetail(seriesModel, ecModel, api, getColor, posInfo);\n\n    this._renderAnchor(seriesModel, posInfo);\n\n    this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);\n  };\n\n  GaugeView.prototype._renderTicks = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {\n    var group = this.group;\n    var cx = posInfo.cx;\n    var cy = posInfo.cy;\n    var r = posInfo.r;\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var splitLineModel = seriesModel.getModel('splitLine');\n    var tickModel = seriesModel.getModel('axisTick');\n    var labelModel = seriesModel.getModel('axisLabel');\n    var splitNumber = seriesModel.get('splitNumber');\n    var subSplitNumber = tickModel.get('splitNumber');\n    var splitLineLen = parsePercent(splitLineModel.get('length'), r);\n    var tickLen = parsePercent(tickModel.get('length'), r);\n    var angle = startAngle;\n    var step = (endAngle - startAngle) / splitNumber;\n    var subStep = step / subSplitNumber;\n    var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();\n    var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();\n    var splitLineDistance = splitLineModel.get('distance');\n    var unitX;\n    var unitY;\n\n    for (var i = 0; i <= splitNumber; i++) {\n      unitX = Math.cos(angle);\n      unitY = Math.sin(angle); // Split line\n\n      if (splitLineModel.get('show')) {\n        var distance = splitLineDistance ? splitLineDistance + axisLineWidth : axisLineWidth;\n        var splitLine = new graphic.Line({\n          shape: {\n            x1: unitX * (r - distance) + cx,\n            y1: unitY * (r - distance) + cy,\n            x2: unitX * (r - splitLineLen - distance) + cx,\n            y2: unitY * (r - splitLineLen - distance) + cy\n          },\n          style: splitLineStyle,\n          silent: true\n        });\n\n        if (splitLineStyle.stroke === 'auto') {\n          splitLine.setStyle({\n            stroke: getColor(i / splitNumber)\n          });\n        }\n\n        group.add(splitLine);\n      } // Label\n\n\n      if (labelModel.get('show')) {\n        var distance = labelModel.get('distance') + splitLineDistance;\n        var label = formatLabel(round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get('formatter'));\n        var autoColor = getColor(i / splitNumber);\n        var textStyleX = unitX * (r - splitLineLen - distance) + cx;\n        var textStyleY = unitY * (r - splitLineLen - distance) + cy;\n        var rotateType = labelModel.get('rotate');\n        var rotate = 0;\n\n        if (rotateType === 'radial') {\n          rotate = -angle + 2 * Math.PI;\n\n          if (rotate > Math.PI / 2) {\n            rotate += Math.PI;\n          }\n        } else if (rotateType === 'tangential') {\n          rotate = -angle - Math.PI / 2;\n        } else if (isNumber(rotateType)) {\n          rotate = rotateType * Math.PI / 180;\n        }\n\n        if (rotate === 0) {\n          group.add(new graphic.Text({\n            style: createTextStyle(labelModel, {\n              text: label,\n              x: textStyleX,\n              y: textStyleY,\n              verticalAlign: unitY < -0.8 ? 'top' : unitY > 0.8 ? 'bottom' : 'middle',\n              align: unitX < -0.4 ? 'left' : unitX > 0.4 ? 'right' : 'center'\n            }, {\n              inheritColor: autoColor\n            }),\n            silent: true\n          }));\n        } else {\n          group.add(new graphic.Text({\n            style: createTextStyle(labelModel, {\n              text: label,\n              x: textStyleX,\n              y: textStyleY,\n              verticalAlign: 'middle',\n              align: 'center'\n            }, {\n              inheritColor: autoColor\n            }),\n            silent: true,\n            originX: textStyleX,\n            originY: textStyleY,\n            rotation: rotate\n          }));\n        }\n      } // Axis tick\n\n\n      if (tickModel.get('show') && i !== splitNumber) {\n        var distance = tickModel.get('distance');\n        distance = distance ? distance + axisLineWidth : axisLineWidth;\n\n        for (var j = 0; j <= subSplitNumber; j++) {\n          unitX = Math.cos(angle);\n          unitY = Math.sin(angle);\n          var tickLine = new graphic.Line({\n            shape: {\n              x1: unitX * (r - distance) + cx,\n              y1: unitY * (r - distance) + cy,\n              x2: unitX * (r - tickLen - distance) + cx,\n              y2: unitY * (r - tickLen - distance) + cy\n            },\n            silent: true,\n            style: tickLineStyle\n          });\n\n          if (tickLineStyle.stroke === 'auto') {\n            tickLine.setStyle({\n              stroke: getColor((i + j / subSplitNumber) / splitNumber)\n            });\n          }\n\n          group.add(tickLine);\n          angle += subStep;\n        }\n\n        angle -= subStep;\n      } else {\n        angle += step;\n      }\n    }\n  };\n\n  GaugeView.prototype._renderPointer = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {\n    var group = this.group;\n    var oldData = this._data;\n    var oldProgressData = this._progressEls;\n    var progressList = [];\n    var showPointer = seriesModel.get(['pointer', 'show']);\n    var progressModel = seriesModel.getModel('progress');\n    var showProgress = progressModel.get('show');\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var valueExtent = [minVal, maxVal];\n    var angleExtent = [startAngle, endAngle];\n\n    function createPointer(idx, angle) {\n      var itemModel = data.getItemModel(idx);\n      var pointerModel = itemModel.getModel('pointer');\n      var pointerWidth = parsePercent(pointerModel.get('width'), posInfo.r);\n      var pointerLength = parsePercent(pointerModel.get('length'), posInfo.r);\n      var pointerStr = seriesModel.get(['pointer', 'icon']);\n      var pointerOffset = pointerModel.get('offsetCenter');\n      var pointerOffsetX = parsePercent(pointerOffset[0], posInfo.r);\n      var pointerOffsetY = parsePercent(pointerOffset[1], posInfo.r);\n      var pointerKeepAspect = pointerModel.get('keepAspect');\n      var pointer; // not exist icon type will be set 'rect'\n\n      if (pointerStr) {\n        pointer = createSymbol(pointerStr, pointerOffsetX - pointerWidth / 2, pointerOffsetY - pointerLength, pointerWidth, pointerLength, null, pointerKeepAspect);\n      } else {\n        pointer = new PointerPath({\n          shape: {\n            angle: -Math.PI / 2,\n            width: pointerWidth,\n            r: pointerLength,\n            x: pointerOffsetX,\n            y: pointerOffsetY\n          }\n        });\n      }\n\n      pointer.rotation = -(angle + Math.PI / 2);\n      pointer.x = posInfo.cx;\n      pointer.y = posInfo.cy;\n      return pointer;\n    }\n\n    function createProgress(idx, endAngle) {\n      var roundCap = progressModel.get('roundCap');\n      var ProgressPath = roundCap ? Sausage : graphic.Sector;\n      var isOverlap = progressModel.get('overlap');\n      var progressWidth = isOverlap ? progressModel.get('width') : axisLineWidth / data.count();\n      var r0 = isOverlap ? posInfo.r - progressWidth : posInfo.r - (idx + 1) * progressWidth;\n      var r = isOverlap ? posInfo.r : posInfo.r - idx * progressWidth;\n      var progress = new ProgressPath({\n        shape: {\n          startAngle: startAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: r0,\n          r: r\n        }\n      });\n      isOverlap && (progress.z2 = maxVal - data.get(valueDim, idx) % maxVal);\n      return progress;\n    }\n\n    if (showProgress || showPointer) {\n      data.diff(oldData).add(function (idx) {\n        var val = data.get(valueDim, idx);\n\n        if (showPointer) {\n          var pointer = createPointer(idx, startAngle); // TODO hide pointer on NaN value?\n\n          graphic.initProps(pointer, {\n            rotation: -((isNaN(+val) ? angleExtent[0] : linearMap(val, valueExtent, angleExtent, true)) + Math.PI / 2)\n          }, seriesModel);\n          group.add(pointer);\n          data.setItemGraphicEl(idx, pointer);\n        }\n\n        if (showProgress) {\n          var progress = createProgress(idx, startAngle);\n          var isClip = progressModel.get('clip');\n          graphic.initProps(progress, {\n            shape: {\n              endAngle: linearMap(val, valueExtent, angleExtent, isClip)\n            }\n          }, seriesModel);\n          group.add(progress); // Add data index and series index for indexing the data by element\n          // Useful in tooltip\n\n          setCommonECData(seriesModel.seriesIndex, data.dataType, idx, progress);\n          progressList[idx] = progress;\n        }\n      }).update(function (newIdx, oldIdx) {\n        var val = data.get(valueDim, newIdx);\n\n        if (showPointer) {\n          var previousPointer = oldData.getItemGraphicEl(oldIdx);\n          var previousRotate = previousPointer ? previousPointer.rotation : startAngle;\n          var pointer = createPointer(newIdx, previousRotate);\n          pointer.rotation = previousRotate;\n          graphic.updateProps(pointer, {\n            rotation: -((isNaN(+val) ? angleExtent[0] : linearMap(val, valueExtent, angleExtent, true)) + Math.PI / 2)\n          }, seriesModel);\n          group.add(pointer);\n          data.setItemGraphicEl(newIdx, pointer);\n        }\n\n        if (showProgress) {\n          var previousProgress = oldProgressData[oldIdx];\n          var previousEndAngle = previousProgress ? previousProgress.shape.endAngle : startAngle;\n          var progress = createProgress(newIdx, previousEndAngle);\n          var isClip = progressModel.get('clip');\n          graphic.updateProps(progress, {\n            shape: {\n              endAngle: linearMap(val, valueExtent, angleExtent, isClip)\n            }\n          }, seriesModel);\n          group.add(progress); // Add data index and series index for indexing the data by element\n          // Useful in tooltip\n\n          setCommonECData(seriesModel.seriesIndex, data.dataType, newIdx, progress);\n          progressList[newIdx] = progress;\n        }\n      }).execute();\n      data.each(function (idx) {\n        var itemModel = data.getItemModel(idx);\n        var emphasisModel = itemModel.getModel('emphasis');\n        var focus = emphasisModel.get('focus');\n        var blurScope = emphasisModel.get('blurScope');\n        var emphasisDisabled = emphasisModel.get('disabled');\n\n        if (showPointer) {\n          var pointer = data.getItemGraphicEl(idx);\n          var symbolStyle = data.getItemVisual(idx, 'style');\n          var visualColor = symbolStyle.fill;\n\n          if (pointer instanceof ZRImage) {\n            var pathStyle = pointer.style;\n            pointer.useStyle(extend({\n              image: pathStyle.image,\n              x: pathStyle.x,\n              y: pathStyle.y,\n              width: pathStyle.width,\n              height: pathStyle.height\n            }, symbolStyle));\n          } else {\n            pointer.useStyle(symbolStyle);\n            pointer.type !== 'pointer' && pointer.setColor(visualColor);\n          }\n\n          pointer.setStyle(itemModel.getModel(['pointer', 'itemStyle']).getItemStyle());\n\n          if (pointer.style.fill === 'auto') {\n            pointer.setStyle('fill', getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));\n          }\n\n          pointer.z2EmphasisLift = 0;\n          setStatesStylesFromModel(pointer, itemModel);\n          toggleHoverEmphasis(pointer, focus, blurScope, emphasisDisabled);\n        }\n\n        if (showProgress) {\n          var progress = progressList[idx];\n          progress.useStyle(data.getItemVisual(idx, 'style'));\n          progress.setStyle(itemModel.getModel(['progress', 'itemStyle']).getItemStyle());\n          progress.z2EmphasisLift = 0;\n          setStatesStylesFromModel(progress, itemModel);\n          toggleHoverEmphasis(progress, focus, blurScope, emphasisDisabled);\n        }\n      });\n      this._progressEls = progressList;\n    }\n  };\n\n  GaugeView.prototype._renderAnchor = function (seriesModel, posInfo) {\n    var anchorModel = seriesModel.getModel('anchor');\n    var showAnchor = anchorModel.get('show');\n\n    if (showAnchor) {\n      var anchorSize = anchorModel.get('size');\n      var anchorType = anchorModel.get('icon');\n      var offsetCenter = anchorModel.get('offsetCenter');\n      var anchorKeepAspect = anchorModel.get('keepAspect');\n      var anchor = createSymbol(anchorType, posInfo.cx - anchorSize / 2 + parsePercent(offsetCenter[0], posInfo.r), posInfo.cy - anchorSize / 2 + parsePercent(offsetCenter[1], posInfo.r), anchorSize, anchorSize, null, anchorKeepAspect);\n      anchor.z2 = anchorModel.get('showAbove') ? 1 : 0;\n      anchor.setStyle(anchorModel.getModel('itemStyle').getItemStyle());\n      this.group.add(anchor);\n    }\n  };\n\n  GaugeView.prototype._renderTitleAndDetail = function (seriesModel, ecModel, api, getColor, posInfo) {\n    var _this = this;\n\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var contentGroup = new graphic.Group();\n    var newTitleEls = [];\n    var newDetailEls = [];\n    var hasAnimation = seriesModel.isAnimationEnabled();\n    var showPointerAbove = seriesModel.get(['pointer', 'showAbove']);\n    data.diff(this._data).add(function (idx) {\n      newTitleEls[idx] = new graphic.Text({\n        silent: true\n      });\n      newDetailEls[idx] = new graphic.Text({\n        silent: true\n      });\n    }).update(function (idx, oldIdx) {\n      newTitleEls[idx] = _this._titleEls[oldIdx];\n      newDetailEls[idx] = _this._detailEls[oldIdx];\n    }).execute();\n    data.each(function (idx) {\n      var itemModel = data.getItemModel(idx);\n      var value = data.get(valueDim, idx);\n      var itemGroup = new graphic.Group();\n      var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));\n      var itemTitleModel = itemModel.getModel('title');\n\n      if (itemTitleModel.get('show')) {\n        var titleOffsetCenter = itemTitleModel.get('offsetCenter');\n        var titleX = posInfo.cx + parsePercent(titleOffsetCenter[0], posInfo.r);\n        var titleY = posInfo.cy + parsePercent(titleOffsetCenter[1], posInfo.r);\n        var labelEl = newTitleEls[idx];\n        labelEl.attr({\n          z2: showPointerAbove ? 0 : 2,\n          style: createTextStyle(itemTitleModel, {\n            x: titleX,\n            y: titleY,\n            text: data.getName(idx),\n            align: 'center',\n            verticalAlign: 'middle'\n          }, {\n            inheritColor: autoColor\n          })\n        });\n        itemGroup.add(labelEl);\n      }\n\n      var itemDetailModel = itemModel.getModel('detail');\n\n      if (itemDetailModel.get('show')) {\n        var detailOffsetCenter = itemDetailModel.get('offsetCenter');\n        var detailX = posInfo.cx + parsePercent(detailOffsetCenter[0], posInfo.r);\n        var detailY = posInfo.cy + parsePercent(detailOffsetCenter[1], posInfo.r);\n        var width = parsePercent(itemDetailModel.get('width'), posInfo.r);\n        var height = parsePercent(itemDetailModel.get('height'), posInfo.r);\n        var detailColor = seriesModel.get(['progress', 'show']) ? data.getItemVisual(idx, 'style').fill : autoColor;\n        var labelEl = newDetailEls[idx];\n        var formatter_1 = itemDetailModel.get('formatter');\n        labelEl.attr({\n          z2: showPointerAbove ? 0 : 2,\n          style: createTextStyle(itemDetailModel, {\n            x: detailX,\n            y: detailY,\n            text: formatLabel(value, formatter_1),\n            width: isNaN(width) ? null : width,\n            height: isNaN(height) ? null : height,\n            align: 'center',\n            verticalAlign: 'middle'\n          }, {\n            inheritColor: detailColor\n          })\n        });\n        setLabelValueAnimation(labelEl, {\n          normal: itemDetailModel\n        }, value, function (value) {\n          return formatLabel(value, formatter_1);\n        });\n        hasAnimation && animateLabelValue(labelEl, idx, data, seriesModel, {\n          getFormattedLabel: function getFormattedLabel(labelDataIndex, status, dataType, labelDimIndex, fmt, extendParams) {\n            return formatLabel(extendParams ? extendParams.interpolatedValue : value, formatter_1);\n          }\n        });\n        itemGroup.add(labelEl);\n      }\n\n      contentGroup.add(itemGroup);\n    });\n    this.group.add(contentGroup);\n    this._titleEls = newTitleEls;\n    this._detailEls = newDetailEls;\n  };\n\n  GaugeView.type = 'gauge';\n  return GaugeView;\n}(ChartView);\n\nexport default GaugeView;","map":{"version":3,"sources":["/home/rayce/Udatabase/study/ElectronicMall/BookVue/node_modules/echarts/lib/chart/gauge/GaugeView.js"],"names":["__extends","PointerPath","graphic","setStatesStylesFromModel","toggleHoverEmphasis","createTextStyle","setLabelValueAnimation","animateLabelValue","ChartView","parsePercent","round","linearMap","Sausage","createSymbol","ZRImage","extend","isFunction","isString","isNumber","each","setCommonECData","normalizeArcAngles","parsePosition","seriesModel","api","center","get","width","getWidth","height","getHeight","size","Math","min","cx","cy","r","formatLabel","value","labelFormatter","label","replace","GaugeView","_super","_this","apply","arguments","type","prototype","render","ecModel","group","removeAll","colorList","posInfo","_renderMain","_data","getData","dispose","clockwise","startAngle","PI","endAngle","axisLineModel","getModel","roundCap","MainPath","Sector","showAxis","lineStyleModel","axisLineWidth","angles","angleRangeSpan","prevEndAngle","sectors","i","length","percent","max","sector","shape","r0","silent","setStyle","fill","getLineStyle","push","reverse","add","getColor","_renderTicks","_renderTitleAndDetail","_renderAnchor","_renderPointer","minVal","maxVal","splitLineModel","tickModel","labelModel","splitNumber","subSplitNumber","splitLineLen","tickLen","angle","step","subStep","splitLineStyle","tickLineStyle","splitLineDistance","unitX","unitY","cos","sin","distance","splitLine","Line","x1","y1","x2","y2","style","stroke","autoColor","textStyleX","textStyleY","rotateType","rotate","Text","text","x","y","verticalAlign","align","inheritColor","originX","originY","rotation","j","tickLine","oldData","oldProgressData","_progressEls","progressList","showPointer","progressModel","showProgress","data","valueDim","mapDimension","valueExtent","angleExtent","createPointer","idx","itemModel","getItemModel","pointerModel","pointerWidth","pointerLength","pointerStr","pointerOffset","pointerOffsetX","pointerOffsetY","pointerKeepAspect","pointer","createProgress","ProgressPath","isOverlap","progressWidth","count","progress","z2","diff","val","initProps","isNaN","setItemGraphicEl","isClip","seriesIndex","dataType","update","newIdx","oldIdx","previousPointer","getItemGraphicEl","previousRotate","updateProps","previousProgress","previousEndAngle","execute","emphasisModel","focus","blurScope","emphasisDisabled","symbolStyle","getItemVisual","visualColor","pathStyle","useStyle","image","setColor","getItemStyle","z2EmphasisLift","anchorModel","showAnchor","anchorSize","anchorType","offsetCenter","anchorKeepAspect","anchor","contentGroup","Group","newTitleEls","newDetailEls","hasAnimation","isAnimationEnabled","showPointerAbove","_titleEls","_detailEls","itemGroup","itemTitleModel","titleOffsetCenter","titleX","titleY","labelEl","attr","getName","itemDetailModel","detailOffsetCenter","detailX","detailY","detailColor","formatter_1","normal","getFormattedLabel","labelDataIndex","status","labelDimIndex","fmt","extendParams","interpolatedValue"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport PointerPath from './PointerPath.js';\nimport * as graphic from '../../util/graphic.js';\nimport { setStatesStylesFromModel, toggleHoverEmphasis } from '../../util/states.js';\nimport { createTextStyle, setLabelValueAnimation, animateLabelValue } from '../../label/labelStyle.js';\nimport ChartView from '../../view/Chart.js';\nimport { parsePercent, round, linearMap } from '../../util/number.js';\nimport Sausage from '../../util/shape/sausage.js';\nimport { createSymbol } from '../../util/symbol.js';\nimport ZRImage from 'zrender/lib/graphic/Image.js';\nimport { extend, isFunction, isString, isNumber, each } from 'zrender/lib/core/util.js';\nimport { setCommonECData } from '../../util/innerStore.js';\nimport { normalizeArcAngles } from 'zrender/lib/core/PathProxy.js';\n\nfunction parsePosition(seriesModel, api) {\n  var center = seriesModel.get('center');\n  var width = api.getWidth();\n  var height = api.getHeight();\n  var size = Math.min(width, height);\n  var cx = parsePercent(center[0], api.getWidth());\n  var cy = parsePercent(center[1], api.getHeight());\n  var r = parsePercent(seriesModel.get('radius'), size / 2);\n  return {\n    cx: cx,\n    cy: cy,\n    r: r\n  };\n}\n\nfunction formatLabel(value, labelFormatter) {\n  var label = value == null ? '' : value + '';\n\n  if (labelFormatter) {\n    if (isString(labelFormatter)) {\n      label = labelFormatter.replace('{value}', label);\n    } else if (isFunction(labelFormatter)) {\n      label = labelFormatter(value);\n    }\n  }\n\n  return label;\n}\n\nvar GaugeView =\n/** @class */\nfunction (_super) {\n  __extends(GaugeView, _super);\n\n  function GaugeView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = GaugeView.type;\n    return _this;\n  }\n\n  GaugeView.prototype.render = function (seriesModel, ecModel, api) {\n    this.group.removeAll();\n    var colorList = seriesModel.get(['axisLine', 'lineStyle', 'color']);\n    var posInfo = parsePosition(seriesModel, api);\n\n    this._renderMain(seriesModel, ecModel, api, colorList, posInfo);\n\n    this._data = seriesModel.getData();\n  };\n\n  GaugeView.prototype.dispose = function () {};\n\n  GaugeView.prototype._renderMain = function (seriesModel, ecModel, api, colorList, posInfo) {\n    var group = this.group;\n    var clockwise = seriesModel.get('clockwise');\n    var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;\n    var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;\n    var axisLineModel = seriesModel.getModel('axisLine');\n    var roundCap = axisLineModel.get('roundCap');\n    var MainPath = roundCap ? Sausage : graphic.Sector;\n    var showAxis = axisLineModel.get('show');\n    var lineStyleModel = axisLineModel.getModel('lineStyle');\n    var axisLineWidth = lineStyleModel.get('width');\n    var angles = [startAngle, endAngle];\n    normalizeArcAngles(angles, !clockwise);\n    startAngle = angles[0];\n    endAngle = angles[1];\n    var angleRangeSpan = endAngle - startAngle;\n    var prevEndAngle = startAngle;\n    var sectors = [];\n\n    for (var i = 0; showAxis && i < colorList.length; i++) {\n      // Clamp\n      var percent = Math.min(Math.max(colorList[i][0], 0), 1);\n      endAngle = startAngle + angleRangeSpan * percent;\n      var sector = new MainPath({\n        shape: {\n          startAngle: prevEndAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: posInfo.r - axisLineWidth,\n          r: posInfo.r\n        },\n        silent: true\n      });\n      sector.setStyle({\n        fill: colorList[i][1]\n      });\n      sector.setStyle(lineStyleModel.getLineStyle( // Because we use sector to simulate arc\n      // so the properties for stroking are useless\n      ['color', 'width']));\n      sectors.push(sector);\n      prevEndAngle = endAngle;\n    }\n\n    sectors.reverse();\n    each(sectors, function (sector) {\n      return group.add(sector);\n    });\n\n    var getColor = function (percent) {\n      // Less than 0\n      if (percent <= 0) {\n        return colorList[0][1];\n      }\n\n      var i;\n\n      for (i = 0; i < colorList.length; i++) {\n        if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {\n          return colorList[i][1];\n        }\n      } // More than 1\n\n\n      return colorList[i - 1][1];\n    };\n\n    this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);\n\n    this._renderTitleAndDetail(seriesModel, ecModel, api, getColor, posInfo);\n\n    this._renderAnchor(seriesModel, posInfo);\n\n    this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);\n  };\n\n  GaugeView.prototype._renderTicks = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {\n    var group = this.group;\n    var cx = posInfo.cx;\n    var cy = posInfo.cy;\n    var r = posInfo.r;\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var splitLineModel = seriesModel.getModel('splitLine');\n    var tickModel = seriesModel.getModel('axisTick');\n    var labelModel = seriesModel.getModel('axisLabel');\n    var splitNumber = seriesModel.get('splitNumber');\n    var subSplitNumber = tickModel.get('splitNumber');\n    var splitLineLen = parsePercent(splitLineModel.get('length'), r);\n    var tickLen = parsePercent(tickModel.get('length'), r);\n    var angle = startAngle;\n    var step = (endAngle - startAngle) / splitNumber;\n    var subStep = step / subSplitNumber;\n    var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();\n    var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();\n    var splitLineDistance = splitLineModel.get('distance');\n    var unitX;\n    var unitY;\n\n    for (var i = 0; i <= splitNumber; i++) {\n      unitX = Math.cos(angle);\n      unitY = Math.sin(angle); // Split line\n\n      if (splitLineModel.get('show')) {\n        var distance = splitLineDistance ? splitLineDistance + axisLineWidth : axisLineWidth;\n        var splitLine = new graphic.Line({\n          shape: {\n            x1: unitX * (r - distance) + cx,\n            y1: unitY * (r - distance) + cy,\n            x2: unitX * (r - splitLineLen - distance) + cx,\n            y2: unitY * (r - splitLineLen - distance) + cy\n          },\n          style: splitLineStyle,\n          silent: true\n        });\n\n        if (splitLineStyle.stroke === 'auto') {\n          splitLine.setStyle({\n            stroke: getColor(i / splitNumber)\n          });\n        }\n\n        group.add(splitLine);\n      } // Label\n\n\n      if (labelModel.get('show')) {\n        var distance = labelModel.get('distance') + splitLineDistance;\n        var label = formatLabel(round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get('formatter'));\n        var autoColor = getColor(i / splitNumber);\n        var textStyleX = unitX * (r - splitLineLen - distance) + cx;\n        var textStyleY = unitY * (r - splitLineLen - distance) + cy;\n        var rotateType = labelModel.get('rotate');\n        var rotate = 0;\n\n        if (rotateType === 'radial') {\n          rotate = -angle + 2 * Math.PI;\n\n          if (rotate > Math.PI / 2) {\n            rotate += Math.PI;\n          }\n        } else if (rotateType === 'tangential') {\n          rotate = -angle - Math.PI / 2;\n        } else if (isNumber(rotateType)) {\n          rotate = rotateType * Math.PI / 180;\n        }\n\n        if (rotate === 0) {\n          group.add(new graphic.Text({\n            style: createTextStyle(labelModel, {\n              text: label,\n              x: textStyleX,\n              y: textStyleY,\n              verticalAlign: unitY < -0.8 ? 'top' : unitY > 0.8 ? 'bottom' : 'middle',\n              align: unitX < -0.4 ? 'left' : unitX > 0.4 ? 'right' : 'center'\n            }, {\n              inheritColor: autoColor\n            }),\n            silent: true\n          }));\n        } else {\n          group.add(new graphic.Text({\n            style: createTextStyle(labelModel, {\n              text: label,\n              x: textStyleX,\n              y: textStyleY,\n              verticalAlign: 'middle',\n              align: 'center'\n            }, {\n              inheritColor: autoColor\n            }),\n            silent: true,\n            originX: textStyleX,\n            originY: textStyleY,\n            rotation: rotate\n          }));\n        }\n      } // Axis tick\n\n\n      if (tickModel.get('show') && i !== splitNumber) {\n        var distance = tickModel.get('distance');\n        distance = distance ? distance + axisLineWidth : axisLineWidth;\n\n        for (var j = 0; j <= subSplitNumber; j++) {\n          unitX = Math.cos(angle);\n          unitY = Math.sin(angle);\n          var tickLine = new graphic.Line({\n            shape: {\n              x1: unitX * (r - distance) + cx,\n              y1: unitY * (r - distance) + cy,\n              x2: unitX * (r - tickLen - distance) + cx,\n              y2: unitY * (r - tickLen - distance) + cy\n            },\n            silent: true,\n            style: tickLineStyle\n          });\n\n          if (tickLineStyle.stroke === 'auto') {\n            tickLine.setStyle({\n              stroke: getColor((i + j / subSplitNumber) / splitNumber)\n            });\n          }\n\n          group.add(tickLine);\n          angle += subStep;\n        }\n\n        angle -= subStep;\n      } else {\n        angle += step;\n      }\n    }\n  };\n\n  GaugeView.prototype._renderPointer = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {\n    var group = this.group;\n    var oldData = this._data;\n    var oldProgressData = this._progressEls;\n    var progressList = [];\n    var showPointer = seriesModel.get(['pointer', 'show']);\n    var progressModel = seriesModel.getModel('progress');\n    var showProgress = progressModel.get('show');\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var valueExtent = [minVal, maxVal];\n    var angleExtent = [startAngle, endAngle];\n\n    function createPointer(idx, angle) {\n      var itemModel = data.getItemModel(idx);\n      var pointerModel = itemModel.getModel('pointer');\n      var pointerWidth = parsePercent(pointerModel.get('width'), posInfo.r);\n      var pointerLength = parsePercent(pointerModel.get('length'), posInfo.r);\n      var pointerStr = seriesModel.get(['pointer', 'icon']);\n      var pointerOffset = pointerModel.get('offsetCenter');\n      var pointerOffsetX = parsePercent(pointerOffset[0], posInfo.r);\n      var pointerOffsetY = parsePercent(pointerOffset[1], posInfo.r);\n      var pointerKeepAspect = pointerModel.get('keepAspect');\n      var pointer; // not exist icon type will be set 'rect'\n\n      if (pointerStr) {\n        pointer = createSymbol(pointerStr, pointerOffsetX - pointerWidth / 2, pointerOffsetY - pointerLength, pointerWidth, pointerLength, null, pointerKeepAspect);\n      } else {\n        pointer = new PointerPath({\n          shape: {\n            angle: -Math.PI / 2,\n            width: pointerWidth,\n            r: pointerLength,\n            x: pointerOffsetX,\n            y: pointerOffsetY\n          }\n        });\n      }\n\n      pointer.rotation = -(angle + Math.PI / 2);\n      pointer.x = posInfo.cx;\n      pointer.y = posInfo.cy;\n      return pointer;\n    }\n\n    function createProgress(idx, endAngle) {\n      var roundCap = progressModel.get('roundCap');\n      var ProgressPath = roundCap ? Sausage : graphic.Sector;\n      var isOverlap = progressModel.get('overlap');\n      var progressWidth = isOverlap ? progressModel.get('width') : axisLineWidth / data.count();\n      var r0 = isOverlap ? posInfo.r - progressWidth : posInfo.r - (idx + 1) * progressWidth;\n      var r = isOverlap ? posInfo.r : posInfo.r - idx * progressWidth;\n      var progress = new ProgressPath({\n        shape: {\n          startAngle: startAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: r0,\n          r: r\n        }\n      });\n      isOverlap && (progress.z2 = maxVal - data.get(valueDim, idx) % maxVal);\n      return progress;\n    }\n\n    if (showProgress || showPointer) {\n      data.diff(oldData).add(function (idx) {\n        var val = data.get(valueDim, idx);\n\n        if (showPointer) {\n          var pointer = createPointer(idx, startAngle); // TODO hide pointer on NaN value?\n\n          graphic.initProps(pointer, {\n            rotation: -((isNaN(+val) ? angleExtent[0] : linearMap(val, valueExtent, angleExtent, true)) + Math.PI / 2)\n          }, seriesModel);\n          group.add(pointer);\n          data.setItemGraphicEl(idx, pointer);\n        }\n\n        if (showProgress) {\n          var progress = createProgress(idx, startAngle);\n          var isClip = progressModel.get('clip');\n          graphic.initProps(progress, {\n            shape: {\n              endAngle: linearMap(val, valueExtent, angleExtent, isClip)\n            }\n          }, seriesModel);\n          group.add(progress); // Add data index and series index for indexing the data by element\n          // Useful in tooltip\n\n          setCommonECData(seriesModel.seriesIndex, data.dataType, idx, progress);\n          progressList[idx] = progress;\n        }\n      }).update(function (newIdx, oldIdx) {\n        var val = data.get(valueDim, newIdx);\n\n        if (showPointer) {\n          var previousPointer = oldData.getItemGraphicEl(oldIdx);\n          var previousRotate = previousPointer ? previousPointer.rotation : startAngle;\n          var pointer = createPointer(newIdx, previousRotate);\n          pointer.rotation = previousRotate;\n          graphic.updateProps(pointer, {\n            rotation: -((isNaN(+val) ? angleExtent[0] : linearMap(val, valueExtent, angleExtent, true)) + Math.PI / 2)\n          }, seriesModel);\n          group.add(pointer);\n          data.setItemGraphicEl(newIdx, pointer);\n        }\n\n        if (showProgress) {\n          var previousProgress = oldProgressData[oldIdx];\n          var previousEndAngle = previousProgress ? previousProgress.shape.endAngle : startAngle;\n          var progress = createProgress(newIdx, previousEndAngle);\n          var isClip = progressModel.get('clip');\n          graphic.updateProps(progress, {\n            shape: {\n              endAngle: linearMap(val, valueExtent, angleExtent, isClip)\n            }\n          }, seriesModel);\n          group.add(progress); // Add data index and series index for indexing the data by element\n          // Useful in tooltip\n\n          setCommonECData(seriesModel.seriesIndex, data.dataType, newIdx, progress);\n          progressList[newIdx] = progress;\n        }\n      }).execute();\n      data.each(function (idx) {\n        var itemModel = data.getItemModel(idx);\n        var emphasisModel = itemModel.getModel('emphasis');\n        var focus = emphasisModel.get('focus');\n        var blurScope = emphasisModel.get('blurScope');\n        var emphasisDisabled = emphasisModel.get('disabled');\n\n        if (showPointer) {\n          var pointer = data.getItemGraphicEl(idx);\n          var symbolStyle = data.getItemVisual(idx, 'style');\n          var visualColor = symbolStyle.fill;\n\n          if (pointer instanceof ZRImage) {\n            var pathStyle = pointer.style;\n            pointer.useStyle(extend({\n              image: pathStyle.image,\n              x: pathStyle.x,\n              y: pathStyle.y,\n              width: pathStyle.width,\n              height: pathStyle.height\n            }, symbolStyle));\n          } else {\n            pointer.useStyle(symbolStyle);\n            pointer.type !== 'pointer' && pointer.setColor(visualColor);\n          }\n\n          pointer.setStyle(itemModel.getModel(['pointer', 'itemStyle']).getItemStyle());\n\n          if (pointer.style.fill === 'auto') {\n            pointer.setStyle('fill', getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));\n          }\n\n          pointer.z2EmphasisLift = 0;\n          setStatesStylesFromModel(pointer, itemModel);\n          toggleHoverEmphasis(pointer, focus, blurScope, emphasisDisabled);\n        }\n\n        if (showProgress) {\n          var progress = progressList[idx];\n          progress.useStyle(data.getItemVisual(idx, 'style'));\n          progress.setStyle(itemModel.getModel(['progress', 'itemStyle']).getItemStyle());\n          progress.z2EmphasisLift = 0;\n          setStatesStylesFromModel(progress, itemModel);\n          toggleHoverEmphasis(progress, focus, blurScope, emphasisDisabled);\n        }\n      });\n      this._progressEls = progressList;\n    }\n  };\n\n  GaugeView.prototype._renderAnchor = function (seriesModel, posInfo) {\n    var anchorModel = seriesModel.getModel('anchor');\n    var showAnchor = anchorModel.get('show');\n\n    if (showAnchor) {\n      var anchorSize = anchorModel.get('size');\n      var anchorType = anchorModel.get('icon');\n      var offsetCenter = anchorModel.get('offsetCenter');\n      var anchorKeepAspect = anchorModel.get('keepAspect');\n      var anchor = createSymbol(anchorType, posInfo.cx - anchorSize / 2 + parsePercent(offsetCenter[0], posInfo.r), posInfo.cy - anchorSize / 2 + parsePercent(offsetCenter[1], posInfo.r), anchorSize, anchorSize, null, anchorKeepAspect);\n      anchor.z2 = anchorModel.get('showAbove') ? 1 : 0;\n      anchor.setStyle(anchorModel.getModel('itemStyle').getItemStyle());\n      this.group.add(anchor);\n    }\n  };\n\n  GaugeView.prototype._renderTitleAndDetail = function (seriesModel, ecModel, api, getColor, posInfo) {\n    var _this = this;\n\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var contentGroup = new graphic.Group();\n    var newTitleEls = [];\n    var newDetailEls = [];\n    var hasAnimation = seriesModel.isAnimationEnabled();\n    var showPointerAbove = seriesModel.get(['pointer', 'showAbove']);\n    data.diff(this._data).add(function (idx) {\n      newTitleEls[idx] = new graphic.Text({\n        silent: true\n      });\n      newDetailEls[idx] = new graphic.Text({\n        silent: true\n      });\n    }).update(function (idx, oldIdx) {\n      newTitleEls[idx] = _this._titleEls[oldIdx];\n      newDetailEls[idx] = _this._detailEls[oldIdx];\n    }).execute();\n    data.each(function (idx) {\n      var itemModel = data.getItemModel(idx);\n      var value = data.get(valueDim, idx);\n      var itemGroup = new graphic.Group();\n      var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));\n      var itemTitleModel = itemModel.getModel('title');\n\n      if (itemTitleModel.get('show')) {\n        var titleOffsetCenter = itemTitleModel.get('offsetCenter');\n        var titleX = posInfo.cx + parsePercent(titleOffsetCenter[0], posInfo.r);\n        var titleY = posInfo.cy + parsePercent(titleOffsetCenter[1], posInfo.r);\n        var labelEl = newTitleEls[idx];\n        labelEl.attr({\n          z2: showPointerAbove ? 0 : 2,\n          style: createTextStyle(itemTitleModel, {\n            x: titleX,\n            y: titleY,\n            text: data.getName(idx),\n            align: 'center',\n            verticalAlign: 'middle'\n          }, {\n            inheritColor: autoColor\n          })\n        });\n        itemGroup.add(labelEl);\n      }\n\n      var itemDetailModel = itemModel.getModel('detail');\n\n      if (itemDetailModel.get('show')) {\n        var detailOffsetCenter = itemDetailModel.get('offsetCenter');\n        var detailX = posInfo.cx + parsePercent(detailOffsetCenter[0], posInfo.r);\n        var detailY = posInfo.cy + parsePercent(detailOffsetCenter[1], posInfo.r);\n        var width = parsePercent(itemDetailModel.get('width'), posInfo.r);\n        var height = parsePercent(itemDetailModel.get('height'), posInfo.r);\n        var detailColor = seriesModel.get(['progress', 'show']) ? data.getItemVisual(idx, 'style').fill : autoColor;\n        var labelEl = newDetailEls[idx];\n        var formatter_1 = itemDetailModel.get('formatter');\n        labelEl.attr({\n          z2: showPointerAbove ? 0 : 2,\n          style: createTextStyle(itemDetailModel, {\n            x: detailX,\n            y: detailY,\n            text: formatLabel(value, formatter_1),\n            width: isNaN(width) ? null : width,\n            height: isNaN(height) ? null : height,\n            align: 'center',\n            verticalAlign: 'middle'\n          }, {\n            inheritColor: detailColor\n          })\n        });\n        setLabelValueAnimation(labelEl, {\n          normal: itemDetailModel\n        }, value, function (value) {\n          return formatLabel(value, formatter_1);\n        });\n        hasAnimation && animateLabelValue(labelEl, idx, data, seriesModel, {\n          getFormattedLabel: function (labelDataIndex, status, dataType, labelDimIndex, fmt, extendParams) {\n            return formatLabel(extendParams ? extendParams.interpolatedValue : value, formatter_1);\n          }\n        });\n        itemGroup.add(labelEl);\n      }\n\n      contentGroup.add(itemGroup);\n    });\n    this.group.add(contentGroup);\n    this._titleEls = newTitleEls;\n    this._detailEls = newDetailEls;\n  };\n\n  GaugeView.type = 'gauge';\n  return GaugeView;\n}(ChartView);\n\nexport default GaugeView;"]},"metadata":{},"sourceType":"module"}