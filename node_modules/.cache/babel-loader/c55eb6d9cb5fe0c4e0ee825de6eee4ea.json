{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { retrieve, defaults, extend, each, isObject, map, isString, isNumber, isFunction } from 'zrender/lib/core/util.js';\nimport * as graphic from '../../util/graphic.js';\nimport { getECData } from '../../util/innerStore.js';\nimport { createTextStyle } from '../../label/labelStyle.js';\nimport Model from '../../model/Model.js';\nimport { isRadianAroundZero, remRadian } from '../../util/number.js';\nimport { createSymbol, normalizeSymbolOffset } from '../../util/symbol.js';\nimport * as matrixUtil from 'zrender/lib/core/matrix.js';\nimport { applyTransform as v2ApplyTransform } from 'zrender/lib/core/vector.js';\nimport { shouldShowAllLabels } from '../../coord/axisHelper.js';\nimport { prepareLayoutList, hideOverlap } from '../../label/labelLayoutHelper.js';\nvar PI = Math.PI;\n/**\n * A final axis is translated and rotated from a \"standard axis\".\n * So opt.position and opt.rotation is required.\n *\n * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n * for example: (0, 0) ------------> (0, 50)\n *\n * nameDirection or tickDirection or labelDirection is 1 means tick\n * or label is below the standard axis, whereas is -1 means above\n * the standard axis. labelOffset means offset between label and axis,\n * which is useful when 'onZero', where axisLabel is in the grid and\n * label in outside grid.\n *\n * Tips: like always,\n * positive rotation represents anticlockwise, and negative rotation\n * represents clockwise.\n * The direction of position coordinate is the same as the direction\n * of screen coordinate.\n *\n * Do not need to consider axis 'inverse', which is auto processed by\n * axis extent.\n */\n\nvar AxisBuilder =\n/** @class */\nfunction () {\n  function AxisBuilder(axisModel, opt) {\n    this.group = new graphic.Group();\n    this.opt = opt;\n    this.axisModel = axisModel; // Default value\n\n    defaults(opt, {\n      labelOffset: 0,\n      nameDirection: 1,\n      tickDirection: 1,\n      labelDirection: 1,\n      silent: true,\n      handleAutoShown: function handleAutoShown() {\n        return true;\n      }\n    }); // FIXME Not use a separate text group?\n\n    var transformGroup = new graphic.Group({\n      x: opt.position[0],\n      y: opt.position[1],\n      rotation: opt.rotation\n    }); // this.group.add(transformGroup);\n    // this._transformGroup = transformGroup;\n\n    transformGroup.updateTransform();\n    this._transformGroup = transformGroup;\n  }\n\n  AxisBuilder.prototype.hasBuilder = function (name) {\n    return !!builders[name];\n  };\n\n  AxisBuilder.prototype.add = function (name) {\n    builders[name](this.opt, this.axisModel, this.group, this._transformGroup);\n  };\n\n  AxisBuilder.prototype.getGroup = function () {\n    return this.group;\n  };\n\n  AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n    var rotationDiff = remRadian(textRotation - axisRotation);\n    var textAlign;\n    var textVerticalAlign;\n\n    if (isRadianAroundZero(rotationDiff)) {\n      // Label is parallel with axis line.\n      textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n      textAlign = 'center';\n    } else if (isRadianAroundZero(rotationDiff - PI)) {\n      // Label is inverse parallel with axis line.\n      textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n      textAlign = 'center';\n    } else {\n      textVerticalAlign = 'middle';\n\n      if (rotationDiff > 0 && rotationDiff < PI) {\n        textAlign = direction > 0 ? 'right' : 'left';\n      } else {\n        textAlign = direction > 0 ? 'left' : 'right';\n      }\n    }\n\n    return {\n      rotation: rotationDiff,\n      textAlign: textAlign,\n      textVerticalAlign: textVerticalAlign\n    };\n  };\n\n  AxisBuilder.makeAxisEventDataBase = function (axisModel) {\n    var eventData = {\n      componentType: axisModel.mainType,\n      componentIndex: axisModel.componentIndex\n    };\n    eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n    return eventData;\n  };\n\n  AxisBuilder.isLabelSilent = function (axisModel) {\n    var tooltipOpt = axisModel.get('tooltip');\n    return axisModel.get('silent') // Consider mouse cursor, add these restrictions.\n    || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n  };\n\n  return AxisBuilder;\n}();\n\n;\nvar builders = {\n  axisLine: function axisLine(opt, axisModel, group, transformGroup) {\n    var shown = axisModel.get(['axisLine', 'show']);\n\n    if (shown === 'auto' && opt.handleAutoShown) {\n      shown = opt.handleAutoShown('axisLine');\n    }\n\n    if (!shown) {\n      return;\n    }\n\n    var extent = axisModel.axis.getExtent();\n    var matrix = transformGroup.transform;\n    var pt1 = [extent[0], 0];\n    var pt2 = [extent[1], 0];\n    var inverse = pt1[0] > pt2[0];\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    }\n\n    var lineStyle = extend({\n      lineCap: 'round'\n    }, axisModel.getModel(['axisLine', 'lineStyle']).getLineStyle());\n    var line = new graphic.Line({\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: lineStyle,\n      strokeContainThreshold: opt.strokeContainThreshold || 5,\n      silent: true,\n      z2: 1\n    });\n    graphic.subPixelOptimizeLine(line.shape, line.style.lineWidth);\n    line.anid = 'line';\n    group.add(line);\n    var arrows = axisModel.get(['axisLine', 'symbol']);\n\n    if (arrows != null) {\n      var arrowSize = axisModel.get(['axisLine', 'symbolSize']);\n\n      if (isString(arrows)) {\n        // Use the same arrow for start and end point\n        arrows = [arrows, arrows];\n      }\n\n      if (isString(arrowSize) || isNumber(arrowSize)) {\n        // Use the same size for width and height\n        arrowSize = [arrowSize, arrowSize];\n      }\n\n      var arrowOffset = normalizeSymbolOffset(axisModel.get(['axisLine', 'symbolOffset']) || 0, arrowSize);\n      var symbolWidth_1 = arrowSize[0];\n      var symbolHeight_1 = arrowSize[1];\n      each([{\n        rotate: opt.rotation + Math.PI / 2,\n        offset: arrowOffset[0],\n        r: 0\n      }, {\n        rotate: opt.rotation - Math.PI / 2,\n        offset: arrowOffset[1],\n        r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))\n      }], function (point, index) {\n        if (arrows[index] !== 'none' && arrows[index] != null) {\n          var symbol = createSymbol(arrows[index], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true); // Calculate arrow position with offset\n\n          var r = point.r + point.offset;\n          var pt = inverse ? pt2 : pt1;\n          symbol.attr({\n            rotation: point.rotate,\n            x: pt[0] + r * Math.cos(opt.rotation),\n            y: pt[1] - r * Math.sin(opt.rotation),\n            silent: true,\n            z2: 11\n          });\n          group.add(symbol);\n        }\n      });\n    }\n  },\n  axisTickLabel: function axisTickLabel(opt, axisModel, group, transformGroup) {\n    var ticksEls = buildAxisMajorTicks(group, transformGroup, axisModel, opt);\n    var labelEls = buildAxisLabel(group, transformGroup, axisModel, opt);\n    fixMinMaxLabelShow(axisModel, labelEls, ticksEls);\n    buildAxisMinorTicks(group, transformGroup, axisModel, opt.tickDirection); // This bit fixes the label overlap issue for the time chart.\n    // See https://github.com/apache/echarts/issues/14266 for more.\n\n    if (axisModel.get(['axisLabel', 'hideOverlap'])) {\n      var labelList = prepareLayoutList(map(labelEls, function (label) {\n        return {\n          label: label,\n          priority: label.z2,\n          defaultAttr: {\n            ignore: label.ignore\n          }\n        };\n      }));\n      hideOverlap(labelList);\n    }\n  },\n  axisName: function axisName(opt, axisModel, group, transformGroup) {\n    var name = retrieve(opt.axisName, axisModel.get('name'));\n\n    if (!name) {\n      return;\n    }\n\n    var nameLocation = axisModel.get('nameLocation');\n    var nameDirection = opt.nameDirection;\n    var textStyleModel = axisModel.getModel('nameTextStyle');\n    var gap = axisModel.get('nameGap') || 0;\n    var extent = axisModel.axis.getExtent();\n    var gapSignal = extent[0] > extent[1] ? -1 : 1;\n    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // Reuse labelOffset.\n    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n    var labelLayout;\n    var nameRotation = axisModel.get('nameRotate');\n\n    if (nameRotation != null) {\n      nameRotation = nameRotation * PI / 180; // To radian.\n    }\n\n    var axisNameAvailableWidth;\n\n    if (isNameLocationCenter(nameLocation)) {\n      labelLayout = AxisBuilder.innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n      nameDirection);\n    } else {\n      labelLayout = endTextLayout(opt.rotation, nameLocation, nameRotation || 0, extent);\n      axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\n      if (axisNameAvailableWidth != null) {\n        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n      }\n    }\n\n    var textFont = textStyleModel.getFont();\n    var truncateOpt = axisModel.get('nameTruncate', true) || {};\n    var ellipsis = truncateOpt.ellipsis;\n    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);\n    var textEl = new graphic.Text({\n      x: pos[0],\n      y: pos[1],\n      rotation: labelLayout.rotation,\n      silent: AxisBuilder.isLabelSilent(axisModel),\n      style: createTextStyle(textStyleModel, {\n        text: name,\n        font: textFont,\n        overflow: 'truncate',\n        width: maxWidth,\n        ellipsis: ellipsis,\n        fill: textStyleModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']),\n        align: textStyleModel.get('align') || labelLayout.textAlign,\n        verticalAlign: textStyleModel.get('verticalAlign') || labelLayout.textVerticalAlign\n      }),\n      z2: 1\n    });\n    graphic.setTooltipConfig({\n      el: textEl,\n      componentModel: axisModel,\n      itemName: name\n    });\n    textEl.__fullText = name; // Id for animation\n\n    textEl.anid = 'name';\n\n    if (axisModel.get('triggerEvent')) {\n      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);\n      eventData.targetType = 'axisName';\n      eventData.name = name;\n      getECData(textEl).eventData = eventData;\n    } // FIXME\n\n\n    transformGroup.add(textEl);\n    textEl.updateTransform();\n    group.add(textEl);\n    textEl.decomposeTransform();\n  }\n};\n\nfunction endTextLayout(rotation, textPosition, textRotate, extent) {\n  var rotationDiff = remRadian(textRotate - rotation);\n  var textAlign;\n  var textVerticalAlign;\n  var inverse = extent[0] > extent[1];\n  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\n  if (isRadianAroundZero(rotationDiff - PI / 2)) {\n    textVerticalAlign = onLeft ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n    textVerticalAlign = onLeft ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n      textAlign = onLeft ? 'left' : 'right';\n    } else {\n      textAlign = onLeft ? 'right' : 'left';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n  if (shouldShowAllLabels(axisModel.axis)) {\n    return;\n  } // If min or max are user set, we need to check\n  // If the tick on min(max) are overlap on their neighbour tick\n  // If they are overlapped, we need to hide the min(max) tick label\n\n\n  var showMinLabel = axisModel.get(['axisLabel', 'showMinLabel']);\n  var showMaxLabel = axisModel.get(['axisLabel', 'showMaxLabel']); // FIXME\n  // Have not consider onBand yet, where tick els is more than label els.\n\n  labelEls = labelEls || [];\n  tickEls = tickEls || [];\n  var firstLabel = labelEls[0];\n  var nextLabel = labelEls[1];\n  var lastLabel = labelEls[labelEls.length - 1];\n  var prevLabel = labelEls[labelEls.length - 2];\n  var firstTick = tickEls[0];\n  var nextTick = tickEls[1];\n  var lastTick = tickEls[tickEls.length - 1];\n  var prevTick = tickEls[tickEls.length - 2];\n\n  if (showMinLabel === false) {\n    ignoreEl(firstLabel);\n    ignoreEl(firstTick);\n  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n    if (showMinLabel) {\n      ignoreEl(nextLabel);\n      ignoreEl(nextTick);\n    } else {\n      ignoreEl(firstLabel);\n      ignoreEl(firstTick);\n    }\n  }\n\n  if (showMaxLabel === false) {\n    ignoreEl(lastLabel);\n    ignoreEl(lastTick);\n  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n    if (showMaxLabel) {\n      ignoreEl(prevLabel);\n      ignoreEl(prevTick);\n    } else {\n      ignoreEl(lastLabel);\n      ignoreEl(lastTick);\n    }\n  }\n}\n\nfunction ignoreEl(el) {\n  el && (el.ignore = true);\n}\n\nfunction isTwoLabelOverlapped(current, next) {\n  // current and next has the same rotation.\n  var firstRect = current && current.getBoundingRect().clone();\n  var nextRect = next && next.getBoundingRect().clone();\n\n  if (!firstRect || !nextRect) {\n    return;\n  } // When checking intersect of two rotated labels, we use mRotationBack\n  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n\n\n  var mRotationBack = matrixUtil.identity([]);\n  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);\n  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));\n  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));\n  return firstRect.intersect(nextRect);\n}\n\nfunction isNameLocationCenter(nameLocation) {\n  return nameLocation === 'middle' || nameLocation === 'center';\n}\n\nfunction createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {\n  var tickEls = [];\n  var pt1 = [];\n  var pt2 = [];\n\n  for (var i = 0; i < ticksCoords.length; i++) {\n    var tickCoord = ticksCoords[i].coord;\n    pt1[0] = tickCoord;\n    pt1[1] = 0;\n    pt2[0] = tickCoord;\n    pt2[1] = tickEndCoord;\n\n    if (tickTransform) {\n      v2ApplyTransform(pt1, pt1, tickTransform);\n      v2ApplyTransform(pt2, pt2, tickTransform);\n    } // Tick line, Not use group transform to have better line draw\n\n\n    var tickEl = new graphic.Line({\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: tickLineStyle,\n      z2: 2,\n      autoBatch: true,\n      silent: true\n    });\n    graphic.subPixelOptimizeLine(tickEl.shape, tickEl.style.lineWidth);\n    tickEl.anid = anidPrefix + '_' + ticksCoords[i].tickValue;\n    tickEls.push(tickEl);\n  }\n\n  return tickEls;\n}\n\nfunction buildAxisMajorTicks(group, transformGroup, axisModel, opt) {\n  var axis = axisModel.axis;\n  var tickModel = axisModel.getModel('axisTick');\n  var shown = tickModel.get('show');\n\n  if (shown === 'auto' && opt.handleAutoShown) {\n    shown = opt.handleAutoShown('axisTick');\n  }\n\n  if (!shown || axis.scale.isBlank()) {\n    return;\n  }\n\n  var lineStyleModel = tickModel.getModel('lineStyle');\n  var tickEndCoord = opt.tickDirection * tickModel.get('length');\n  var ticksCoords = axis.getTicksCoords();\n  var ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, defaults(lineStyleModel.getLineStyle(), {\n    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])\n  }), 'ticks');\n\n  for (var i = 0; i < ticksEls.length; i++) {\n    group.add(ticksEls[i]);\n  }\n\n  return ticksEls;\n}\n\nfunction buildAxisMinorTicks(group, transformGroup, axisModel, tickDirection) {\n  var axis = axisModel.axis;\n  var minorTickModel = axisModel.getModel('minorTick');\n\n  if (!minorTickModel.get('show') || axis.scale.isBlank()) {\n    return;\n  }\n\n  var minorTicksCoords = axis.getMinorTicksCoords();\n\n  if (!minorTicksCoords.length) {\n    return;\n  }\n\n  var lineStyleModel = minorTickModel.getModel('lineStyle');\n  var tickEndCoord = tickDirection * minorTickModel.get('length');\n  var minorTickLineStyle = defaults(lineStyleModel.getLineStyle(), defaults(axisModel.getModel('axisTick').getLineStyle(), {\n    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])\n  }));\n\n  for (var i = 0; i < minorTicksCoords.length; i++) {\n    var minorTicksEls = createTicks(minorTicksCoords[i], transformGroup.transform, tickEndCoord, minorTickLineStyle, 'minorticks_' + i);\n\n    for (var k = 0; k < minorTicksEls.length; k++) {\n      group.add(minorTicksEls[k]);\n    }\n  }\n}\n\nfunction buildAxisLabel(group, transformGroup, axisModel, opt) {\n  var axis = axisModel.axis;\n  var show = retrieve(opt.axisLabelShow, axisModel.get(['axisLabel', 'show']));\n\n  if (!show || axis.scale.isBlank()) {\n    return;\n  }\n\n  var labelModel = axisModel.getModel('axisLabel');\n  var labelMargin = labelModel.get('margin');\n  var labels = axis.getViewLabels(); // Special label rotate.\n\n  var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;\n  var labelLayout = AxisBuilder.innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n  var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);\n  var labelEls = [];\n  var silent = AxisBuilder.isLabelSilent(axisModel);\n  var triggerEvent = axisModel.get('triggerEvent');\n  each(labels, function (labelItem, index) {\n    var tickValue = axis.scale.type === 'ordinal' ? axis.scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;\n    var formattedLabel = labelItem.formattedLabel;\n    var rawLabel = labelItem.rawLabel;\n    var itemLabelModel = labelModel;\n\n    if (rawCategoryData && rawCategoryData[tickValue]) {\n      var rawCategoryItem = rawCategoryData[tickValue];\n\n      if (isObject(rawCategoryItem) && rawCategoryItem.textStyle) {\n        itemLabelModel = new Model(rawCategoryItem.textStyle, labelModel, axisModel.ecModel);\n      }\n    }\n\n    var textColor = itemLabelModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']);\n    var tickCoord = axis.dataToCoord(tickValue);\n    var textEl = new graphic.Text({\n      x: tickCoord,\n      y: opt.labelOffset + opt.labelDirection * labelMargin,\n      rotation: labelLayout.rotation,\n      silent: silent,\n      z2: 10 + (labelItem.level || 0),\n      style: createTextStyle(itemLabelModel, {\n        text: formattedLabel,\n        align: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,\n        verticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,\n        fill: isFunction(textColor) ? textColor( // (1) In category axis with data zoom, tick is not the original\n        // index of axis.data. So tick should not be exposed to user\n        // in category axis.\n        // (2) Compatible with previous version, which always use formatted label as\n        // input. But in interval scale the formatted label is like '223,445', which\n        // maked user replace ','. So we modify it to return original val but remain\n        // it as 'string' to avoid error in replacing.\n        axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor\n      })\n    });\n    textEl.anid = 'label_' + tickValue; // Pack data for mouse event\n\n    if (triggerEvent) {\n      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);\n      eventData.targetType = 'axisLabel';\n      eventData.value = rawLabel;\n      eventData.tickIndex = index;\n\n      if (axis.type === 'category') {\n        eventData.dataIndex = tickValue;\n      }\n\n      getECData(textEl).eventData = eventData;\n    } // FIXME\n\n\n    transformGroup.add(textEl);\n    textEl.updateTransform();\n    labelEls.push(textEl);\n    group.add(textEl);\n    textEl.decomposeTransform();\n  });\n  return labelEls;\n}\n\nexport default AxisBuilder;","map":{"version":3,"sources":["D:/Work/WorkSpace/GitWorkSpace/TenShop/resource/ElectronicMall/src/ElectronicMallVue/node_modules/echarts/lib/component/axis/AxisBuilder.js"],"names":["retrieve","defaults","extend","each","isObject","map","isString","isNumber","isFunction","graphic","getECData","createTextStyle","Model","isRadianAroundZero","remRadian","createSymbol","normalizeSymbolOffset","matrixUtil","applyTransform","v2ApplyTransform","shouldShowAllLabels","prepareLayoutList","hideOverlap","PI","Math","AxisBuilder","axisModel","opt","group","Group","labelOffset","nameDirection","tickDirection","labelDirection","silent","handleAutoShown","transformGroup","x","position","y","rotation","updateTransform","_transformGroup","prototype","hasBuilder","name","builders","add","getGroup","innerTextLayout","axisRotation","textRotation","direction","rotationDiff","textAlign","textVerticalAlign","makeAxisEventDataBase","eventData","componentType","mainType","componentIndex","isLabelSilent","tooltipOpt","get","show","axisLine","shown","extent","axis","getExtent","matrix","transform","pt1","pt2","inverse","lineStyle","lineCap","getModel","getLineStyle","line","Line","shape","x1","y1","x2","y2","style","strokeContainThreshold","z2","subPixelOptimizeLine","lineWidth","anid","arrows","arrowSize","arrowOffset","symbolWidth_1","symbolHeight_1","rotate","offset","r","sqrt","point","index","symbol","stroke","pt","attr","cos","sin","axisTickLabel","ticksEls","buildAxisMajorTicks","labelEls","buildAxisLabel","fixMinMaxLabelShow","buildAxisMinorTicks","labelList","label","priority","defaultAttr","ignore","axisName","nameLocation","textStyleModel","gap","gapSignal","pos","isNameLocationCenter","labelLayout","nameRotation","axisNameAvailableWidth","endTextLayout","abs","isFinite","textFont","getFont","truncateOpt","ellipsis","maxWidth","nameTruncateMaxWidth","textEl","Text","text","font","overflow","width","fill","getTextColor","align","verticalAlign","setTooltipConfig","el","componentModel","itemName","__fullText","targetType","decomposeTransform","textPosition","textRotate","onLeft","tickEls","showMinLabel","showMaxLabel","firstLabel","nextLabel","lastLabel","length","prevLabel","firstTick","nextTick","lastTick","prevTick","ignoreEl","isTwoLabelOverlapped","current","next","firstRect","getBoundingRect","clone","nextRect","mRotationBack","identity","mul","getLocalTransform","intersect","createTicks","ticksCoords","tickTransform","tickEndCoord","tickLineStyle","anidPrefix","i","tickCoord","coord","tickEl","autoBatch","tickValue","push","tickModel","scale","isBlank","lineStyleModel","getTicksCoords","minorTickModel","minorTicksCoords","getMinorTicksCoords","minorTickLineStyle","minorTicksEls","k","axisLabelShow","labelModel","labelMargin","labels","getViewLabels","labelRotation","labelRotate","rawCategoryData","getCategories","triggerEvent","labelItem","type","getRawOrdinalNumber","formattedLabel","rawLabel","itemLabelModel","rawCategoryItem","textStyle","ecModel","textColor","dataToCoord","level","getShallow","value","tickIndex","dataIndex"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { retrieve, defaults, extend, each, isObject, map, isString, isNumber, isFunction } from 'zrender/lib/core/util.js';\nimport * as graphic from '../../util/graphic.js';\nimport { getECData } from '../../util/innerStore.js';\nimport { createTextStyle } from '../../label/labelStyle.js';\nimport Model from '../../model/Model.js';\nimport { isRadianAroundZero, remRadian } from '../../util/number.js';\nimport { createSymbol, normalizeSymbolOffset } from '../../util/symbol.js';\nimport * as matrixUtil from 'zrender/lib/core/matrix.js';\nimport { applyTransform as v2ApplyTransform } from 'zrender/lib/core/vector.js';\nimport { shouldShowAllLabels } from '../../coord/axisHelper.js';\nimport { prepareLayoutList, hideOverlap } from '../../label/labelLayoutHelper.js';\nvar PI = Math.PI;\n/**\n * A final axis is translated and rotated from a \"standard axis\".\n * So opt.position and opt.rotation is required.\n *\n * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n * for example: (0, 0) ------------> (0, 50)\n *\n * nameDirection or tickDirection or labelDirection is 1 means tick\n * or label is below the standard axis, whereas is -1 means above\n * the standard axis. labelOffset means offset between label and axis,\n * which is useful when 'onZero', where axisLabel is in the grid and\n * label in outside grid.\n *\n * Tips: like always,\n * positive rotation represents anticlockwise, and negative rotation\n * represents clockwise.\n * The direction of position coordinate is the same as the direction\n * of screen coordinate.\n *\n * Do not need to consider axis 'inverse', which is auto processed by\n * axis extent.\n */\n\nvar AxisBuilder =\n/** @class */\nfunction () {\n  function AxisBuilder(axisModel, opt) {\n    this.group = new graphic.Group();\n    this.opt = opt;\n    this.axisModel = axisModel; // Default value\n\n    defaults(opt, {\n      labelOffset: 0,\n      nameDirection: 1,\n      tickDirection: 1,\n      labelDirection: 1,\n      silent: true,\n      handleAutoShown: function () {\n        return true;\n      }\n    }); // FIXME Not use a separate text group?\n\n    var transformGroup = new graphic.Group({\n      x: opt.position[0],\n      y: opt.position[1],\n      rotation: opt.rotation\n    }); // this.group.add(transformGroup);\n    // this._transformGroup = transformGroup;\n\n    transformGroup.updateTransform();\n    this._transformGroup = transformGroup;\n  }\n\n  AxisBuilder.prototype.hasBuilder = function (name) {\n    return !!builders[name];\n  };\n\n  AxisBuilder.prototype.add = function (name) {\n    builders[name](this.opt, this.axisModel, this.group, this._transformGroup);\n  };\n\n  AxisBuilder.prototype.getGroup = function () {\n    return this.group;\n  };\n\n  AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n    var rotationDiff = remRadian(textRotation - axisRotation);\n    var textAlign;\n    var textVerticalAlign;\n\n    if (isRadianAroundZero(rotationDiff)) {\n      // Label is parallel with axis line.\n      textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n      textAlign = 'center';\n    } else if (isRadianAroundZero(rotationDiff - PI)) {\n      // Label is inverse parallel with axis line.\n      textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n      textAlign = 'center';\n    } else {\n      textVerticalAlign = 'middle';\n\n      if (rotationDiff > 0 && rotationDiff < PI) {\n        textAlign = direction > 0 ? 'right' : 'left';\n      } else {\n        textAlign = direction > 0 ? 'left' : 'right';\n      }\n    }\n\n    return {\n      rotation: rotationDiff,\n      textAlign: textAlign,\n      textVerticalAlign: textVerticalAlign\n    };\n  };\n\n  AxisBuilder.makeAxisEventDataBase = function (axisModel) {\n    var eventData = {\n      componentType: axisModel.mainType,\n      componentIndex: axisModel.componentIndex\n    };\n    eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n    return eventData;\n  };\n\n  AxisBuilder.isLabelSilent = function (axisModel) {\n    var tooltipOpt = axisModel.get('tooltip');\n    return axisModel.get('silent') // Consider mouse cursor, add these restrictions.\n    || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n  };\n\n  return AxisBuilder;\n}();\n\n;\nvar builders = {\n  axisLine: function (opt, axisModel, group, transformGroup) {\n    var shown = axisModel.get(['axisLine', 'show']);\n\n    if (shown === 'auto' && opt.handleAutoShown) {\n      shown = opt.handleAutoShown('axisLine');\n    }\n\n    if (!shown) {\n      return;\n    }\n\n    var extent = axisModel.axis.getExtent();\n    var matrix = transformGroup.transform;\n    var pt1 = [extent[0], 0];\n    var pt2 = [extent[1], 0];\n    var inverse = pt1[0] > pt2[0];\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    }\n\n    var lineStyle = extend({\n      lineCap: 'round'\n    }, axisModel.getModel(['axisLine', 'lineStyle']).getLineStyle());\n    var line = new graphic.Line({\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: lineStyle,\n      strokeContainThreshold: opt.strokeContainThreshold || 5,\n      silent: true,\n      z2: 1\n    });\n    graphic.subPixelOptimizeLine(line.shape, line.style.lineWidth);\n    line.anid = 'line';\n    group.add(line);\n    var arrows = axisModel.get(['axisLine', 'symbol']);\n\n    if (arrows != null) {\n      var arrowSize = axisModel.get(['axisLine', 'symbolSize']);\n\n      if (isString(arrows)) {\n        // Use the same arrow for start and end point\n        arrows = [arrows, arrows];\n      }\n\n      if (isString(arrowSize) || isNumber(arrowSize)) {\n        // Use the same size for width and height\n        arrowSize = [arrowSize, arrowSize];\n      }\n\n      var arrowOffset = normalizeSymbolOffset(axisModel.get(['axisLine', 'symbolOffset']) || 0, arrowSize);\n      var symbolWidth_1 = arrowSize[0];\n      var symbolHeight_1 = arrowSize[1];\n      each([{\n        rotate: opt.rotation + Math.PI / 2,\n        offset: arrowOffset[0],\n        r: 0\n      }, {\n        rotate: opt.rotation - Math.PI / 2,\n        offset: arrowOffset[1],\n        r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))\n      }], function (point, index) {\n        if (arrows[index] !== 'none' && arrows[index] != null) {\n          var symbol = createSymbol(arrows[index], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true); // Calculate arrow position with offset\n\n          var r = point.r + point.offset;\n          var pt = inverse ? pt2 : pt1;\n          symbol.attr({\n            rotation: point.rotate,\n            x: pt[0] + r * Math.cos(opt.rotation),\n            y: pt[1] - r * Math.sin(opt.rotation),\n            silent: true,\n            z2: 11\n          });\n          group.add(symbol);\n        }\n      });\n    }\n  },\n  axisTickLabel: function (opt, axisModel, group, transformGroup) {\n    var ticksEls = buildAxisMajorTicks(group, transformGroup, axisModel, opt);\n    var labelEls = buildAxisLabel(group, transformGroup, axisModel, opt);\n    fixMinMaxLabelShow(axisModel, labelEls, ticksEls);\n    buildAxisMinorTicks(group, transformGroup, axisModel, opt.tickDirection); // This bit fixes the label overlap issue for the time chart.\n    // See https://github.com/apache/echarts/issues/14266 for more.\n\n    if (axisModel.get(['axisLabel', 'hideOverlap'])) {\n      var labelList = prepareLayoutList(map(labelEls, function (label) {\n        return {\n          label: label,\n          priority: label.z2,\n          defaultAttr: {\n            ignore: label.ignore\n          }\n        };\n      }));\n      hideOverlap(labelList);\n    }\n  },\n  axisName: function (opt, axisModel, group, transformGroup) {\n    var name = retrieve(opt.axisName, axisModel.get('name'));\n\n    if (!name) {\n      return;\n    }\n\n    var nameLocation = axisModel.get('nameLocation');\n    var nameDirection = opt.nameDirection;\n    var textStyleModel = axisModel.getModel('nameTextStyle');\n    var gap = axisModel.get('nameGap') || 0;\n    var extent = axisModel.axis.getExtent();\n    var gapSignal = extent[0] > extent[1] ? -1 : 1;\n    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // Reuse labelOffset.\n    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n    var labelLayout;\n    var nameRotation = axisModel.get('nameRotate');\n\n    if (nameRotation != null) {\n      nameRotation = nameRotation * PI / 180; // To radian.\n    }\n\n    var axisNameAvailableWidth;\n\n    if (isNameLocationCenter(nameLocation)) {\n      labelLayout = AxisBuilder.innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n      nameDirection);\n    } else {\n      labelLayout = endTextLayout(opt.rotation, nameLocation, nameRotation || 0, extent);\n      axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\n      if (axisNameAvailableWidth != null) {\n        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n      }\n    }\n\n    var textFont = textStyleModel.getFont();\n    var truncateOpt = axisModel.get('nameTruncate', true) || {};\n    var ellipsis = truncateOpt.ellipsis;\n    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);\n    var textEl = new graphic.Text({\n      x: pos[0],\n      y: pos[1],\n      rotation: labelLayout.rotation,\n      silent: AxisBuilder.isLabelSilent(axisModel),\n      style: createTextStyle(textStyleModel, {\n        text: name,\n        font: textFont,\n        overflow: 'truncate',\n        width: maxWidth,\n        ellipsis: ellipsis,\n        fill: textStyleModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']),\n        align: textStyleModel.get('align') || labelLayout.textAlign,\n        verticalAlign: textStyleModel.get('verticalAlign') || labelLayout.textVerticalAlign\n      }),\n      z2: 1\n    });\n    graphic.setTooltipConfig({\n      el: textEl,\n      componentModel: axisModel,\n      itemName: name\n    });\n    textEl.__fullText = name; // Id for animation\n\n    textEl.anid = 'name';\n\n    if (axisModel.get('triggerEvent')) {\n      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);\n      eventData.targetType = 'axisName';\n      eventData.name = name;\n      getECData(textEl).eventData = eventData;\n    } // FIXME\n\n\n    transformGroup.add(textEl);\n    textEl.updateTransform();\n    group.add(textEl);\n    textEl.decomposeTransform();\n  }\n};\n\nfunction endTextLayout(rotation, textPosition, textRotate, extent) {\n  var rotationDiff = remRadian(textRotate - rotation);\n  var textAlign;\n  var textVerticalAlign;\n  var inverse = extent[0] > extent[1];\n  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\n  if (isRadianAroundZero(rotationDiff - PI / 2)) {\n    textVerticalAlign = onLeft ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n    textVerticalAlign = onLeft ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n      textAlign = onLeft ? 'left' : 'right';\n    } else {\n      textAlign = onLeft ? 'right' : 'left';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n  if (shouldShowAllLabels(axisModel.axis)) {\n    return;\n  } // If min or max are user set, we need to check\n  // If the tick on min(max) are overlap on their neighbour tick\n  // If they are overlapped, we need to hide the min(max) tick label\n\n\n  var showMinLabel = axisModel.get(['axisLabel', 'showMinLabel']);\n  var showMaxLabel = axisModel.get(['axisLabel', 'showMaxLabel']); // FIXME\n  // Have not consider onBand yet, where tick els is more than label els.\n\n  labelEls = labelEls || [];\n  tickEls = tickEls || [];\n  var firstLabel = labelEls[0];\n  var nextLabel = labelEls[1];\n  var lastLabel = labelEls[labelEls.length - 1];\n  var prevLabel = labelEls[labelEls.length - 2];\n  var firstTick = tickEls[0];\n  var nextTick = tickEls[1];\n  var lastTick = tickEls[tickEls.length - 1];\n  var prevTick = tickEls[tickEls.length - 2];\n\n  if (showMinLabel === false) {\n    ignoreEl(firstLabel);\n    ignoreEl(firstTick);\n  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n    if (showMinLabel) {\n      ignoreEl(nextLabel);\n      ignoreEl(nextTick);\n    } else {\n      ignoreEl(firstLabel);\n      ignoreEl(firstTick);\n    }\n  }\n\n  if (showMaxLabel === false) {\n    ignoreEl(lastLabel);\n    ignoreEl(lastTick);\n  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n    if (showMaxLabel) {\n      ignoreEl(prevLabel);\n      ignoreEl(prevTick);\n    } else {\n      ignoreEl(lastLabel);\n      ignoreEl(lastTick);\n    }\n  }\n}\n\nfunction ignoreEl(el) {\n  el && (el.ignore = true);\n}\n\nfunction isTwoLabelOverlapped(current, next) {\n  // current and next has the same rotation.\n  var firstRect = current && current.getBoundingRect().clone();\n  var nextRect = next && next.getBoundingRect().clone();\n\n  if (!firstRect || !nextRect) {\n    return;\n  } // When checking intersect of two rotated labels, we use mRotationBack\n  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n\n\n  var mRotationBack = matrixUtil.identity([]);\n  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);\n  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));\n  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));\n  return firstRect.intersect(nextRect);\n}\n\nfunction isNameLocationCenter(nameLocation) {\n  return nameLocation === 'middle' || nameLocation === 'center';\n}\n\nfunction createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {\n  var tickEls = [];\n  var pt1 = [];\n  var pt2 = [];\n\n  for (var i = 0; i < ticksCoords.length; i++) {\n    var tickCoord = ticksCoords[i].coord;\n    pt1[0] = tickCoord;\n    pt1[1] = 0;\n    pt2[0] = tickCoord;\n    pt2[1] = tickEndCoord;\n\n    if (tickTransform) {\n      v2ApplyTransform(pt1, pt1, tickTransform);\n      v2ApplyTransform(pt2, pt2, tickTransform);\n    } // Tick line, Not use group transform to have better line draw\n\n\n    var tickEl = new graphic.Line({\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: tickLineStyle,\n      z2: 2,\n      autoBatch: true,\n      silent: true\n    });\n    graphic.subPixelOptimizeLine(tickEl.shape, tickEl.style.lineWidth);\n    tickEl.anid = anidPrefix + '_' + ticksCoords[i].tickValue;\n    tickEls.push(tickEl);\n  }\n\n  return tickEls;\n}\n\nfunction buildAxisMajorTicks(group, transformGroup, axisModel, opt) {\n  var axis = axisModel.axis;\n  var tickModel = axisModel.getModel('axisTick');\n  var shown = tickModel.get('show');\n\n  if (shown === 'auto' && opt.handleAutoShown) {\n    shown = opt.handleAutoShown('axisTick');\n  }\n\n  if (!shown || axis.scale.isBlank()) {\n    return;\n  }\n\n  var lineStyleModel = tickModel.getModel('lineStyle');\n  var tickEndCoord = opt.tickDirection * tickModel.get('length');\n  var ticksCoords = axis.getTicksCoords();\n  var ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, defaults(lineStyleModel.getLineStyle(), {\n    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])\n  }), 'ticks');\n\n  for (var i = 0; i < ticksEls.length; i++) {\n    group.add(ticksEls[i]);\n  }\n\n  return ticksEls;\n}\n\nfunction buildAxisMinorTicks(group, transformGroup, axisModel, tickDirection) {\n  var axis = axisModel.axis;\n  var minorTickModel = axisModel.getModel('minorTick');\n\n  if (!minorTickModel.get('show') || axis.scale.isBlank()) {\n    return;\n  }\n\n  var minorTicksCoords = axis.getMinorTicksCoords();\n\n  if (!minorTicksCoords.length) {\n    return;\n  }\n\n  var lineStyleModel = minorTickModel.getModel('lineStyle');\n  var tickEndCoord = tickDirection * minorTickModel.get('length');\n  var minorTickLineStyle = defaults(lineStyleModel.getLineStyle(), defaults(axisModel.getModel('axisTick').getLineStyle(), {\n    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])\n  }));\n\n  for (var i = 0; i < minorTicksCoords.length; i++) {\n    var minorTicksEls = createTicks(minorTicksCoords[i], transformGroup.transform, tickEndCoord, minorTickLineStyle, 'minorticks_' + i);\n\n    for (var k = 0; k < minorTicksEls.length; k++) {\n      group.add(minorTicksEls[k]);\n    }\n  }\n}\n\nfunction buildAxisLabel(group, transformGroup, axisModel, opt) {\n  var axis = axisModel.axis;\n  var show = retrieve(opt.axisLabelShow, axisModel.get(['axisLabel', 'show']));\n\n  if (!show || axis.scale.isBlank()) {\n    return;\n  }\n\n  var labelModel = axisModel.getModel('axisLabel');\n  var labelMargin = labelModel.get('margin');\n  var labels = axis.getViewLabels(); // Special label rotate.\n\n  var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;\n  var labelLayout = AxisBuilder.innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n  var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);\n  var labelEls = [];\n  var silent = AxisBuilder.isLabelSilent(axisModel);\n  var triggerEvent = axisModel.get('triggerEvent');\n  each(labels, function (labelItem, index) {\n    var tickValue = axis.scale.type === 'ordinal' ? axis.scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;\n    var formattedLabel = labelItem.formattedLabel;\n    var rawLabel = labelItem.rawLabel;\n    var itemLabelModel = labelModel;\n\n    if (rawCategoryData && rawCategoryData[tickValue]) {\n      var rawCategoryItem = rawCategoryData[tickValue];\n\n      if (isObject(rawCategoryItem) && rawCategoryItem.textStyle) {\n        itemLabelModel = new Model(rawCategoryItem.textStyle, labelModel, axisModel.ecModel);\n      }\n    }\n\n    var textColor = itemLabelModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']);\n    var tickCoord = axis.dataToCoord(tickValue);\n    var textEl = new graphic.Text({\n      x: tickCoord,\n      y: opt.labelOffset + opt.labelDirection * labelMargin,\n      rotation: labelLayout.rotation,\n      silent: silent,\n      z2: 10 + (labelItem.level || 0),\n      style: createTextStyle(itemLabelModel, {\n        text: formattedLabel,\n        align: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,\n        verticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,\n        fill: isFunction(textColor) ? textColor( // (1) In category axis with data zoom, tick is not the original\n        // index of axis.data. So tick should not be exposed to user\n        // in category axis.\n        // (2) Compatible with previous version, which always use formatted label as\n        // input. But in interval scale the formatted label is like '223,445', which\n        // maked user replace ','. So we modify it to return original val but remain\n        // it as 'string' to avoid error in replacing.\n        axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor\n      })\n    });\n    textEl.anid = 'label_' + tickValue; // Pack data for mouse event\n\n    if (triggerEvent) {\n      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);\n      eventData.targetType = 'axisLabel';\n      eventData.value = rawLabel;\n      eventData.tickIndex = index;\n\n      if (axis.type === 'category') {\n        eventData.dataIndex = tickValue;\n      }\n\n      getECData(textEl).eventData = eventData;\n    } // FIXME\n\n\n    transformGroup.add(textEl);\n    textEl.updateTransform();\n    labelEls.push(textEl);\n    group.add(textEl);\n    textEl.decomposeTransform();\n  });\n  return labelEls;\n}\n\nexport default AxisBuilder;"]},"metadata":{},"sourceType":"module"}