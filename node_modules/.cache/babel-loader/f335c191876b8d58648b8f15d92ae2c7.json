{"ast":null,"code":"import \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.repeat.js\";\nimport { adjustTextY, getIdURL, getMatrixStr, getPathPrecision, getShadowKey, getSRTTransformString, hasShadow, isAroundZero, isGradient, isImagePattern, isLinearGradient, isPattern, isRadialGradient, normalizeColor, round4, TEXT_ALIGN_TO_ANCHOR } from './helper.js';\nimport Path from '../graphic/Path.js';\nimport ZRImage from '../graphic/Image.js';\nimport { getLineHeight } from '../contain/text.js';\nimport TSpan from '../graphic/TSpan.js';\nimport SVGPathRebuilder from './SVGPathRebuilder.js';\nimport mapStyleToAttrs from './mapStyleToAttrs.js';\nimport { createVNode, vNodeToString } from './core.js';\nimport { assert, clone, isFunction, isString, logError, map, retrieve2 } from '../core/util.js';\nimport { createOrUpdateImage } from '../graphic/helper/image.js';\nimport { createCSSAnimation } from './cssAnimation.js';\nimport { hasSeparateFont, parseFontSize } from '../graphic/Text.js';\nimport { DEFAULT_FONT, DEFAULT_FONT_FAMILY } from '../core/platform.js';\nvar round = Math.round;\n\nfunction isImageLike(val) {\n  return val && isString(val.src);\n}\n\nfunction isCanvasLike(val) {\n  return val && isFunction(val.toDataURL);\n}\n\nfunction setStyleAttrs(attrs, style, el, scope) {\n  mapStyleToAttrs(function (key, val) {\n    var isFillStroke = key === 'fill' || key === 'stroke';\n\n    if (isFillStroke && isGradient(val)) {\n      setGradient(style, attrs, key, scope);\n    } else if (isFillStroke && isPattern(val)) {\n      setPattern(el, attrs, key, scope);\n    } else {\n      attrs[key] = val;\n    }\n  }, style, el, false);\n  setShadow(el, attrs, scope);\n}\n\nfunction noRotateScale(m) {\n  return isAroundZero(m[0] - 1) && isAroundZero(m[1]) && isAroundZero(m[2]) && isAroundZero(m[3] - 1);\n}\n\nfunction noTranslate(m) {\n  return isAroundZero(m[4]) && isAroundZero(m[5]);\n}\n\nfunction setTransform(attrs, m, compress) {\n  if (m && !(noTranslate(m) && noRotateScale(m))) {\n    var mul = compress ? 10 : 1e4;\n    attrs.transform = noRotateScale(m) ? \"translate(\" + round(m[4] * mul) / mul + \" \" + round(m[5] * mul) / mul + \")\" : getMatrixStr(m);\n  }\n}\n\nfunction convertPolyShape(shape, attrs, mul) {\n  var points = shape.points;\n  var strArr = [];\n\n  for (var i = 0; i < points.length; i++) {\n    strArr.push(round(points[i][0] * mul) / mul);\n    strArr.push(round(points[i][1] * mul) / mul);\n  }\n\n  attrs.points = strArr.join(' ');\n}\n\nfunction validatePolyShape(shape) {\n  return !shape.smooth;\n}\n\nfunction createAttrsConvert(desc) {\n  var normalizedDesc = map(desc, function (item) {\n    return typeof item === 'string' ? [item, item] : item;\n  });\n  return function (shape, attrs, mul) {\n    for (var i = 0; i < normalizedDesc.length; i++) {\n      var item = normalizedDesc[i];\n      var val = shape[item[0]];\n\n      if (val != null) {\n        attrs[item[1]] = round(val * mul) / mul;\n      }\n    }\n  };\n}\n\nvar builtinShapesDef = {\n  circle: [createAttrsConvert(['cx', 'cy', 'r'])],\n  polyline: [convertPolyShape, validatePolyShape],\n  polygon: [convertPolyShape, validatePolyShape]\n};\n\nfunction hasShapeAnimation(el) {\n  var animators = el.animators;\n\n  for (var i = 0; i < animators.length; i++) {\n    if (animators[i].targetName === 'shape') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function brushSVGPath(el, scope) {\n  var style = el.style;\n  var shape = el.shape;\n  var builtinShpDef = builtinShapesDef[el.type];\n  var attrs = {};\n  var needsAnimate = scope.animation;\n  var svgElType = 'path';\n  var strokePercent = el.style.strokePercent;\n  var precision = scope.compress && getPathPrecision(el) || 4;\n\n  if (builtinShpDef && !scope.willUpdate && !(builtinShpDef[1] && !builtinShpDef[1](shape)) && !(needsAnimate && hasShapeAnimation(el)) && !(strokePercent < 1)) {\n    svgElType = el.type;\n    var mul = Math.pow(10, precision);\n    builtinShpDef[0](shape, attrs, mul);\n  } else {\n    var needBuildPath = !el.path || el.shapeChanged();\n\n    if (!el.path) {\n      el.createPathProxy();\n    }\n\n    var path = el.path;\n\n    if (needBuildPath) {\n      path.beginPath();\n      el.buildPath(path, el.shape);\n      el.pathUpdated();\n    }\n\n    var pathVersion = path.getVersion();\n    var elExt = el;\n    var svgPathBuilder = elExt.__svgPathBuilder;\n\n    if (elExt.__svgPathVersion !== pathVersion || !svgPathBuilder || strokePercent !== elExt.__svgPathStrokePercent) {\n      if (!svgPathBuilder) {\n        svgPathBuilder = elExt.__svgPathBuilder = new SVGPathRebuilder();\n      }\n\n      svgPathBuilder.reset(precision);\n      path.rebuildPath(svgPathBuilder, strokePercent);\n      svgPathBuilder.generateStr();\n      elExt.__svgPathVersion = pathVersion;\n      elExt.__svgPathStrokePercent = strokePercent;\n    }\n\n    attrs.d = svgPathBuilder.getStr();\n  }\n\n  setTransform(attrs, el.transform);\n  setStyleAttrs(attrs, style, el, scope);\n  scope.animation && createCSSAnimation(el, attrs, scope);\n  return createVNode(svgElType, el.id + '', attrs);\n}\nexport function brushSVGImage(el, scope) {\n  var style = el.style;\n  var image = style.image;\n\n  if (image && !isString(image)) {\n    if (isImageLike(image)) {\n      image = image.src;\n    } else if (isCanvasLike(image)) {\n      image = image.toDataURL();\n    }\n  }\n\n  if (!image) {\n    return;\n  }\n\n  var x = style.x || 0;\n  var y = style.y || 0;\n  var dw = style.width;\n  var dh = style.height;\n  var attrs = {\n    href: image,\n    width: dw,\n    height: dh\n  };\n\n  if (x) {\n    attrs.x = x;\n  }\n\n  if (y) {\n    attrs.y = y;\n  }\n\n  setTransform(attrs, el.transform);\n  setStyleAttrs(attrs, style, el, scope);\n  scope.animation && createCSSAnimation(el, attrs, scope);\n  return createVNode('image', el.id + '', attrs);\n}\n;\nexport function brushSVGTSpan(el, scope) {\n  var style = el.style;\n  var text = style.text;\n  text != null && (text += '');\n\n  if (!text || isNaN(style.x) || isNaN(style.y)) {\n    return;\n  }\n\n  var font = style.font || DEFAULT_FONT;\n  var x = style.x || 0;\n  var y = adjustTextY(style.y || 0, getLineHeight(font), style.textBaseline);\n  var textAlign = TEXT_ALIGN_TO_ANCHOR[style.textAlign] || style.textAlign;\n  var attrs = {\n    'dominant-baseline': 'central',\n    'text-anchor': textAlign\n  };\n\n  if (hasSeparateFont(style)) {\n    var separatedFontStr = '';\n    var fontStyle = style.fontStyle;\n    var fontSize = parseFontSize(style.fontSize);\n\n    if (!parseFloat(fontSize)) {\n      return;\n    }\n\n    var fontFamily = style.fontFamily || DEFAULT_FONT_FAMILY;\n    var fontWeight = style.fontWeight;\n    separatedFontStr += \"font-size:\" + fontSize + \";font-family:\" + fontFamily + \";\";\n\n    if (fontStyle && fontStyle !== 'normal') {\n      separatedFontStr += \"font-style:\" + fontStyle + \";\";\n    }\n\n    if (fontWeight && fontWeight !== 'normal') {\n      separatedFontStr += \"font-weight:\" + fontWeight + \";\";\n    }\n\n    attrs.style = separatedFontStr;\n  } else {\n    attrs.style = \"font: \" + font;\n  }\n\n  if (text.match(/\\s/)) {\n    attrs['xml:space'] = 'preserve';\n  }\n\n  if (x) {\n    attrs.x = x;\n  }\n\n  if (y) {\n    attrs.y = y;\n  }\n\n  setTransform(attrs, el.transform);\n  setStyleAttrs(attrs, style, el, scope);\n  scope.animation && createCSSAnimation(el, attrs, scope);\n  return createVNode('text', el.id + '', attrs, undefined, text);\n}\nexport function brush(el, scope) {\n  if (el instanceof Path) {\n    return brushSVGPath(el, scope);\n  } else if (el instanceof ZRImage) {\n    return brushSVGImage(el, scope);\n  } else if (el instanceof TSpan) {\n    return brushSVGTSpan(el, scope);\n  }\n}\n\nfunction setShadow(el, attrs, scope) {\n  var style = el.style;\n\n  if (hasShadow(style)) {\n    var shadowKey = getShadowKey(el);\n    var shadowCache = scope.shadowCache;\n    var shadowId = shadowCache[shadowKey];\n\n    if (!shadowId) {\n      var globalScale = el.getGlobalScale();\n      var scaleX = globalScale[0];\n      var scaleY = globalScale[1];\n\n      if (!scaleX || !scaleY) {\n        return;\n      }\n\n      var offsetX = style.shadowOffsetX || 0;\n      var offsetY = style.shadowOffsetY || 0;\n      var blur_1 = style.shadowBlur;\n\n      var _a = normalizeColor(style.shadowColor),\n          opacity = _a.opacity,\n          color = _a.color;\n\n      var stdDx = blur_1 / 2 / scaleX;\n      var stdDy = blur_1 / 2 / scaleY;\n      var stdDeviation = stdDx + ' ' + stdDy;\n      shadowId = scope.zrId + '-s' + scope.shadowIdx++;\n      scope.defs[shadowId] = createVNode('filter', shadowId, {\n        'id': shadowId,\n        'x': '-100%',\n        'y': '-100%',\n        'width': '300%',\n        'height': '300%'\n      }, [createVNode('feDropShadow', '', {\n        'dx': offsetX / scaleX,\n        'dy': offsetY / scaleY,\n        'stdDeviation': stdDeviation,\n        'flood-color': color,\n        'flood-opacity': opacity\n      })]);\n      shadowCache[shadowKey] = shadowId;\n    }\n\n    attrs.filter = getIdURL(shadowId);\n  }\n}\n\nexport function setGradient(style, attrs, target, scope) {\n  var val = style[target];\n  var gradientTag;\n  var gradientAttrs = {\n    'gradientUnits': val.global ? 'userSpaceOnUse' : 'objectBoundingBox'\n  };\n\n  if (isLinearGradient(val)) {\n    gradientTag = 'linearGradient';\n    gradientAttrs.x1 = val.x;\n    gradientAttrs.y1 = val.y;\n    gradientAttrs.x2 = val.x2;\n    gradientAttrs.y2 = val.y2;\n  } else if (isRadialGradient(val)) {\n    gradientTag = 'radialGradient';\n    gradientAttrs.cx = retrieve2(val.x, 0.5);\n    gradientAttrs.cy = retrieve2(val.y, 0.5);\n    gradientAttrs.r = retrieve2(val.r, 0.5);\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      logError('Illegal gradient type.');\n    }\n\n    return;\n  }\n\n  var colors = val.colorStops;\n  var colorStops = [];\n\n  for (var i = 0, len = colors.length; i < len; ++i) {\n    var offset = round4(colors[i].offset) * 100 + '%';\n    var stopColor = colors[i].color;\n\n    var _a = normalizeColor(stopColor),\n        color = _a.color,\n        opacity = _a.opacity;\n\n    var stopsAttrs = {\n      'offset': offset\n    };\n    stopsAttrs['stop-color'] = color;\n\n    if (opacity < 1) {\n      stopsAttrs['stop-opacity'] = opacity;\n    }\n\n    colorStops.push(createVNode('stop', i + '', stopsAttrs));\n  }\n\n  var gradientVNode = createVNode(gradientTag, '', gradientAttrs, colorStops);\n  var gradientKey = vNodeToString(gradientVNode);\n  var gradientCache = scope.gradientCache;\n  var gradientId = gradientCache[gradientKey];\n\n  if (!gradientId) {\n    gradientId = scope.zrId + '-g' + scope.gradientIdx++;\n    gradientCache[gradientKey] = gradientId;\n    gradientAttrs.id = gradientId;\n    scope.defs[gradientId] = createVNode(gradientTag, gradientId, gradientAttrs, colorStops);\n  }\n\n  attrs[target] = getIdURL(gradientId);\n}\nexport function setPattern(el, attrs, target, scope) {\n  var val = el.style[target];\n  var boundingRect = el.getBoundingRect();\n  var patternAttrs = {};\n  var repeat = val.repeat;\n  var noRepeat = repeat === 'no-repeat';\n  var repeatX = repeat === 'repeat-x';\n  var repeatY = repeat === 'repeat-y';\n  var child;\n\n  if (isImagePattern(val)) {\n    var imageWidth_1 = val.imageWidth;\n    var imageHeight_1 = val.imageHeight;\n    var imageSrc = void 0;\n    var patternImage = val.image;\n\n    if (isString(patternImage)) {\n      imageSrc = patternImage;\n    } else if (isImageLike(patternImage)) {\n      imageSrc = patternImage.src;\n    } else if (isCanvasLike(patternImage)) {\n      imageSrc = patternImage.toDataURL();\n    }\n\n    if (typeof Image === 'undefined') {\n      var errMsg = 'Image width/height must been given explictly in svg-ssr renderer.';\n      assert(imageWidth_1, errMsg);\n      assert(imageHeight_1, errMsg);\n    } else if (imageWidth_1 == null || imageHeight_1 == null) {\n      var setSizeToVNode_1 = function setSizeToVNode_1(vNode, img) {\n        if (vNode) {\n          var svgEl = vNode.elm;\n          var width = imageWidth_1 || img.width;\n          var height = imageHeight_1 || img.height;\n\n          if (vNode.tag === 'pattern') {\n            if (repeatX) {\n              height = 1;\n              width /= boundingRect.width;\n            } else if (repeatY) {\n              width = 1;\n              height /= boundingRect.height;\n            }\n          }\n\n          vNode.attrs.width = width;\n          vNode.attrs.height = height;\n\n          if (svgEl) {\n            svgEl.setAttribute('width', width);\n            svgEl.setAttribute('height', height);\n          }\n        }\n      };\n\n      var createdImage = createOrUpdateImage(imageSrc, null, el, function (img) {\n        noRepeat || setSizeToVNode_1(patternVNode, img);\n        setSizeToVNode_1(child, img);\n      });\n\n      if (createdImage && createdImage.width && createdImage.height) {\n        imageWidth_1 = imageWidth_1 || createdImage.width;\n        imageHeight_1 = imageHeight_1 || createdImage.height;\n      }\n    }\n\n    child = createVNode('image', 'img', {\n      href: imageSrc,\n      width: imageWidth_1,\n      height: imageHeight_1\n    });\n    patternAttrs.width = imageWidth_1;\n    patternAttrs.height = imageHeight_1;\n  } else if (val.svgElement) {\n    child = clone(val.svgElement);\n    patternAttrs.width = val.svgWidth;\n    patternAttrs.height = val.svgHeight;\n  }\n\n  if (!child) {\n    return;\n  }\n\n  var patternWidth;\n  var patternHeight;\n\n  if (noRepeat) {\n    patternWidth = patternHeight = 1;\n  } else if (repeatX) {\n    patternHeight = 1;\n    patternWidth = patternAttrs.width / boundingRect.width;\n  } else if (repeatY) {\n    patternWidth = 1;\n    patternHeight = patternAttrs.height / boundingRect.height;\n  } else {\n    patternAttrs.patternUnits = 'userSpaceOnUse';\n  }\n\n  if (patternWidth != null && !isNaN(patternWidth)) {\n    patternAttrs.width = patternWidth;\n  }\n\n  if (patternHeight != null && !isNaN(patternHeight)) {\n    patternAttrs.height = patternHeight;\n  }\n\n  var patternTransform = getSRTTransformString(val);\n  patternTransform && (patternAttrs.patternTransform = patternTransform);\n  var patternVNode = createVNode('pattern', '', patternAttrs, [child]);\n  var patternKey = vNodeToString(patternVNode);\n  var patternCache = scope.patternCache;\n  var patternId = patternCache[patternKey];\n\n  if (!patternId) {\n    patternId = scope.zrId + '-p' + scope.patternIdx++;\n    patternCache[patternKey] = patternId;\n    patternAttrs.id = patternId;\n    patternVNode = scope.defs[patternId] = createVNode('pattern', patternId, patternAttrs, [child]);\n  }\n\n  attrs[target] = getIdURL(patternId);\n}\nexport function setClipPath(clipPath, attrs, scope) {\n  var clipPathCache = scope.clipPathCache,\n      defs = scope.defs;\n  var clipPathId = clipPathCache[clipPath.id];\n\n  if (!clipPathId) {\n    clipPathId = scope.zrId + '-c' + scope.clipPathIdx++;\n    var clipPathAttrs = {\n      id: clipPathId\n    };\n    clipPathCache[clipPath.id] = clipPathId;\n    defs[clipPathId] = createVNode('clipPath', clipPathId, clipPathAttrs, [brushSVGPath(clipPath, scope)]);\n  }\n\n  attrs['clip-path'] = getIdURL(clipPathId);\n}","map":{"version":3,"sources":["/home/rayce/Udatabase/study/ElectronicMall/ElectronicMallVue/node_modules/zrender/lib/svg/graphic.js"],"names":["adjustTextY","getIdURL","getMatrixStr","getPathPrecision","getShadowKey","getSRTTransformString","hasShadow","isAroundZero","isGradient","isImagePattern","isLinearGradient","isPattern","isRadialGradient","normalizeColor","round4","TEXT_ALIGN_TO_ANCHOR","Path","ZRImage","getLineHeight","TSpan","SVGPathRebuilder","mapStyleToAttrs","createVNode","vNodeToString","assert","clone","isFunction","isString","logError","map","retrieve2","createOrUpdateImage","createCSSAnimation","hasSeparateFont","parseFontSize","DEFAULT_FONT","DEFAULT_FONT_FAMILY","round","Math","isImageLike","val","src","isCanvasLike","toDataURL","setStyleAttrs","attrs","style","el","scope","key","isFillStroke","setGradient","setPattern","setShadow","noRotateScale","m","noTranslate","setTransform","compress","mul","transform","convertPolyShape","shape","points","strArr","i","length","push","join","validatePolyShape","smooth","createAttrsConvert","desc","normalizedDesc","item","builtinShapesDef","circle","polyline","polygon","hasShapeAnimation","animators","targetName","brushSVGPath","builtinShpDef","type","needsAnimate","animation","svgElType","strokePercent","precision","willUpdate","pow","needBuildPath","path","shapeChanged","createPathProxy","beginPath","buildPath","pathUpdated","pathVersion","getVersion","elExt","svgPathBuilder","__svgPathBuilder","__svgPathVersion","__svgPathStrokePercent","reset","rebuildPath","generateStr","d","getStr","id","brushSVGImage","image","x","y","dw","width","dh","height","href","brushSVGTSpan","text","isNaN","font","textBaseline","textAlign","separatedFontStr","fontStyle","fontSize","parseFloat","fontFamily","fontWeight","match","undefined","brush","shadowKey","shadowCache","shadowId","globalScale","getGlobalScale","scaleX","scaleY","offsetX","shadowOffsetX","offsetY","shadowOffsetY","blur_1","shadowBlur","_a","shadowColor","opacity","color","stdDx","stdDy","stdDeviation","zrId","shadowIdx","defs","filter","target","gradientTag","gradientAttrs","global","x1","y1","x2","y2","cx","cy","r","process","env","NODE_ENV","colors","colorStops","len","offset","stopColor","stopsAttrs","gradientVNode","gradientKey","gradientCache","gradientId","gradientIdx","boundingRect","getBoundingRect","patternAttrs","repeat","noRepeat","repeatX","repeatY","child","imageWidth_1","imageWidth","imageHeight_1","imageHeight","imageSrc","patternImage","Image","errMsg","setSizeToVNode_1","vNode","img","svgEl","elm","tag","setAttribute","createdImage","patternVNode","svgElement","svgWidth","svgHeight","patternWidth","patternHeight","patternUnits","patternTransform","patternKey","patternCache","patternId","patternIdx","setClipPath","clipPath","clipPathCache","clipPathId","clipPathIdx","clipPathAttrs"],"mappings":"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","sourcesContent":["import { adjustTextY, getIdURL, getMatrixStr, getPathPrecision, getShadowKey, getSRTTransformString, hasShadow, isAroundZero, isGradient, isImagePattern, isLinearGradient, isPattern, isRadialGradient, normalizeColor, round4, TEXT_ALIGN_TO_ANCHOR } from './helper.js';\nimport Path from '../graphic/Path.js';\nimport ZRImage from '../graphic/Image.js';\nimport { getLineHeight } from '../contain/text.js';\nimport TSpan from '../graphic/TSpan.js';\nimport SVGPathRebuilder from './SVGPathRebuilder.js';\nimport mapStyleToAttrs from './mapStyleToAttrs.js';\nimport { createVNode, vNodeToString } from './core.js';\nimport { assert, clone, isFunction, isString, logError, map, retrieve2 } from '../core/util.js';\nimport { createOrUpdateImage } from '../graphic/helper/image.js';\nimport { createCSSAnimation } from './cssAnimation.js';\nimport { hasSeparateFont, parseFontSize } from '../graphic/Text.js';\nimport { DEFAULT_FONT, DEFAULT_FONT_FAMILY } from '../core/platform.js';\nvar round = Math.round;\nfunction isImageLike(val) {\n    return val && isString(val.src);\n}\nfunction isCanvasLike(val) {\n    return val && isFunction(val.toDataURL);\n}\nfunction setStyleAttrs(attrs, style, el, scope) {\n    mapStyleToAttrs(function (key, val) {\n        var isFillStroke = key === 'fill' || key === 'stroke';\n        if (isFillStroke && isGradient(val)) {\n            setGradient(style, attrs, key, scope);\n        }\n        else if (isFillStroke && isPattern(val)) {\n            setPattern(el, attrs, key, scope);\n        }\n        else {\n            attrs[key] = val;\n        }\n    }, style, el, false);\n    setShadow(el, attrs, scope);\n}\nfunction noRotateScale(m) {\n    return isAroundZero(m[0] - 1)\n        && isAroundZero(m[1])\n        && isAroundZero(m[2])\n        && isAroundZero(m[3] - 1);\n}\nfunction noTranslate(m) {\n    return isAroundZero(m[4]) && isAroundZero(m[5]);\n}\nfunction setTransform(attrs, m, compress) {\n    if (m && !(noTranslate(m) && noRotateScale(m))) {\n        var mul = compress ? 10 : 1e4;\n        attrs.transform = noRotateScale(m)\n            ? \"translate(\" + round(m[4] * mul) / mul + \" \" + round(m[5] * mul) / mul + \")\" : getMatrixStr(m);\n    }\n}\nfunction convertPolyShape(shape, attrs, mul) {\n    var points = shape.points;\n    var strArr = [];\n    for (var i = 0; i < points.length; i++) {\n        strArr.push(round(points[i][0] * mul) / mul);\n        strArr.push(round(points[i][1] * mul) / mul);\n    }\n    attrs.points = strArr.join(' ');\n}\nfunction validatePolyShape(shape) {\n    return !shape.smooth;\n}\nfunction createAttrsConvert(desc) {\n    var normalizedDesc = map(desc, function (item) {\n        return (typeof item === 'string' ? [item, item] : item);\n    });\n    return function (shape, attrs, mul) {\n        for (var i = 0; i < normalizedDesc.length; i++) {\n            var item = normalizedDesc[i];\n            var val = shape[item[0]];\n            if (val != null) {\n                attrs[item[1]] = round(val * mul) / mul;\n            }\n        }\n    };\n}\nvar builtinShapesDef = {\n    circle: [createAttrsConvert(['cx', 'cy', 'r'])],\n    polyline: [convertPolyShape, validatePolyShape],\n    polygon: [convertPolyShape, validatePolyShape]\n};\nfunction hasShapeAnimation(el) {\n    var animators = el.animators;\n    for (var i = 0; i < animators.length; i++) {\n        if (animators[i].targetName === 'shape') {\n            return true;\n        }\n    }\n    return false;\n}\nexport function brushSVGPath(el, scope) {\n    var style = el.style;\n    var shape = el.shape;\n    var builtinShpDef = builtinShapesDef[el.type];\n    var attrs = {};\n    var needsAnimate = scope.animation;\n    var svgElType = 'path';\n    var strokePercent = el.style.strokePercent;\n    var precision = (scope.compress && getPathPrecision(el)) || 4;\n    if (builtinShpDef\n        && !scope.willUpdate\n        && !(builtinShpDef[1] && !builtinShpDef[1](shape))\n        && !(needsAnimate && hasShapeAnimation(el))\n        && !(strokePercent < 1)) {\n        svgElType = el.type;\n        var mul = Math.pow(10, precision);\n        builtinShpDef[0](shape, attrs, mul);\n    }\n    else {\n        var needBuildPath = !el.path || el.shapeChanged();\n        if (!el.path) {\n            el.createPathProxy();\n        }\n        var path = el.path;\n        if (needBuildPath) {\n            path.beginPath();\n            el.buildPath(path, el.shape);\n            el.pathUpdated();\n        }\n        var pathVersion = path.getVersion();\n        var elExt = el;\n        var svgPathBuilder = elExt.__svgPathBuilder;\n        if (elExt.__svgPathVersion !== pathVersion\n            || !svgPathBuilder\n            || strokePercent !== elExt.__svgPathStrokePercent) {\n            if (!svgPathBuilder) {\n                svgPathBuilder = elExt.__svgPathBuilder = new SVGPathRebuilder();\n            }\n            svgPathBuilder.reset(precision);\n            path.rebuildPath(svgPathBuilder, strokePercent);\n            svgPathBuilder.generateStr();\n            elExt.__svgPathVersion = pathVersion;\n            elExt.__svgPathStrokePercent = strokePercent;\n        }\n        attrs.d = svgPathBuilder.getStr();\n    }\n    setTransform(attrs, el.transform);\n    setStyleAttrs(attrs, style, el, scope);\n    scope.animation && createCSSAnimation(el, attrs, scope);\n    return createVNode(svgElType, el.id + '', attrs);\n}\nexport function brushSVGImage(el, scope) {\n    var style = el.style;\n    var image = style.image;\n    if (image && !isString(image)) {\n        if (isImageLike(image)) {\n            image = image.src;\n        }\n        else if (isCanvasLike(image)) {\n            image = image.toDataURL();\n        }\n    }\n    if (!image) {\n        return;\n    }\n    var x = style.x || 0;\n    var y = style.y || 0;\n    var dw = style.width;\n    var dh = style.height;\n    var attrs = {\n        href: image,\n        width: dw,\n        height: dh\n    };\n    if (x) {\n        attrs.x = x;\n    }\n    if (y) {\n        attrs.y = y;\n    }\n    setTransform(attrs, el.transform);\n    setStyleAttrs(attrs, style, el, scope);\n    scope.animation && createCSSAnimation(el, attrs, scope);\n    return createVNode('image', el.id + '', attrs);\n}\n;\nexport function brushSVGTSpan(el, scope) {\n    var style = el.style;\n    var text = style.text;\n    text != null && (text += '');\n    if (!text || isNaN(style.x) || isNaN(style.y)) {\n        return;\n    }\n    var font = style.font || DEFAULT_FONT;\n    var x = style.x || 0;\n    var y = adjustTextY(style.y || 0, getLineHeight(font), style.textBaseline);\n    var textAlign = TEXT_ALIGN_TO_ANCHOR[style.textAlign]\n        || style.textAlign;\n    var attrs = {\n        'dominant-baseline': 'central',\n        'text-anchor': textAlign\n    };\n    if (hasSeparateFont(style)) {\n        var separatedFontStr = '';\n        var fontStyle = style.fontStyle;\n        var fontSize = parseFontSize(style.fontSize);\n        if (!parseFloat(fontSize)) {\n            return;\n        }\n        var fontFamily = style.fontFamily || DEFAULT_FONT_FAMILY;\n        var fontWeight = style.fontWeight;\n        separatedFontStr += \"font-size:\" + fontSize + \";font-family:\" + fontFamily + \";\";\n        if (fontStyle && fontStyle !== 'normal') {\n            separatedFontStr += \"font-style:\" + fontStyle + \";\";\n        }\n        if (fontWeight && fontWeight !== 'normal') {\n            separatedFontStr += \"font-weight:\" + fontWeight + \";\";\n        }\n        attrs.style = separatedFontStr;\n    }\n    else {\n        attrs.style = \"font: \" + font;\n    }\n    if (text.match(/\\s/)) {\n        attrs['xml:space'] = 'preserve';\n    }\n    if (x) {\n        attrs.x = x;\n    }\n    if (y) {\n        attrs.y = y;\n    }\n    setTransform(attrs, el.transform);\n    setStyleAttrs(attrs, style, el, scope);\n    scope.animation && createCSSAnimation(el, attrs, scope);\n    return createVNode('text', el.id + '', attrs, undefined, text);\n}\nexport function brush(el, scope) {\n    if (el instanceof Path) {\n        return brushSVGPath(el, scope);\n    }\n    else if (el instanceof ZRImage) {\n        return brushSVGImage(el, scope);\n    }\n    else if (el instanceof TSpan) {\n        return brushSVGTSpan(el, scope);\n    }\n}\nfunction setShadow(el, attrs, scope) {\n    var style = el.style;\n    if (hasShadow(style)) {\n        var shadowKey = getShadowKey(el);\n        var shadowCache = scope.shadowCache;\n        var shadowId = shadowCache[shadowKey];\n        if (!shadowId) {\n            var globalScale = el.getGlobalScale();\n            var scaleX = globalScale[0];\n            var scaleY = globalScale[1];\n            if (!scaleX || !scaleY) {\n                return;\n            }\n            var offsetX = style.shadowOffsetX || 0;\n            var offsetY = style.shadowOffsetY || 0;\n            var blur_1 = style.shadowBlur;\n            var _a = normalizeColor(style.shadowColor), opacity = _a.opacity, color = _a.color;\n            var stdDx = blur_1 / 2 / scaleX;\n            var stdDy = blur_1 / 2 / scaleY;\n            var stdDeviation = stdDx + ' ' + stdDy;\n            shadowId = scope.zrId + '-s' + scope.shadowIdx++;\n            scope.defs[shadowId] = createVNode('filter', shadowId, {\n                'id': shadowId,\n                'x': '-100%',\n                'y': '-100%',\n                'width': '300%',\n                'height': '300%'\n            }, [\n                createVNode('feDropShadow', '', {\n                    'dx': offsetX / scaleX,\n                    'dy': offsetY / scaleY,\n                    'stdDeviation': stdDeviation,\n                    'flood-color': color,\n                    'flood-opacity': opacity\n                })\n            ]);\n            shadowCache[shadowKey] = shadowId;\n        }\n        attrs.filter = getIdURL(shadowId);\n    }\n}\nexport function setGradient(style, attrs, target, scope) {\n    var val = style[target];\n    var gradientTag;\n    var gradientAttrs = {\n        'gradientUnits': val.global\n            ? 'userSpaceOnUse'\n            : 'objectBoundingBox'\n    };\n    if (isLinearGradient(val)) {\n        gradientTag = 'linearGradient';\n        gradientAttrs.x1 = val.x;\n        gradientAttrs.y1 = val.y;\n        gradientAttrs.x2 = val.x2;\n        gradientAttrs.y2 = val.y2;\n    }\n    else if (isRadialGradient(val)) {\n        gradientTag = 'radialGradient';\n        gradientAttrs.cx = retrieve2(val.x, 0.5);\n        gradientAttrs.cy = retrieve2(val.y, 0.5);\n        gradientAttrs.r = retrieve2(val.r, 0.5);\n    }\n    else {\n        if (process.env.NODE_ENV !== 'production') {\n            logError('Illegal gradient type.');\n        }\n        return;\n    }\n    var colors = val.colorStops;\n    var colorStops = [];\n    for (var i = 0, len = colors.length; i < len; ++i) {\n        var offset = round4(colors[i].offset) * 100 + '%';\n        var stopColor = colors[i].color;\n        var _a = normalizeColor(stopColor), color = _a.color, opacity = _a.opacity;\n        var stopsAttrs = {\n            'offset': offset\n        };\n        stopsAttrs['stop-color'] = color;\n        if (opacity < 1) {\n            stopsAttrs['stop-opacity'] = opacity;\n        }\n        colorStops.push(createVNode('stop', i + '', stopsAttrs));\n    }\n    var gradientVNode = createVNode(gradientTag, '', gradientAttrs, colorStops);\n    var gradientKey = vNodeToString(gradientVNode);\n    var gradientCache = scope.gradientCache;\n    var gradientId = gradientCache[gradientKey];\n    if (!gradientId) {\n        gradientId = scope.zrId + '-g' + scope.gradientIdx++;\n        gradientCache[gradientKey] = gradientId;\n        gradientAttrs.id = gradientId;\n        scope.defs[gradientId] = createVNode(gradientTag, gradientId, gradientAttrs, colorStops);\n    }\n    attrs[target] = getIdURL(gradientId);\n}\nexport function setPattern(el, attrs, target, scope) {\n    var val = el.style[target];\n    var boundingRect = el.getBoundingRect();\n    var patternAttrs = {};\n    var repeat = val.repeat;\n    var noRepeat = repeat === 'no-repeat';\n    var repeatX = repeat === 'repeat-x';\n    var repeatY = repeat === 'repeat-y';\n    var child;\n    if (isImagePattern(val)) {\n        var imageWidth_1 = val.imageWidth;\n        var imageHeight_1 = val.imageHeight;\n        var imageSrc = void 0;\n        var patternImage = val.image;\n        if (isString(patternImage)) {\n            imageSrc = patternImage;\n        }\n        else if (isImageLike(patternImage)) {\n            imageSrc = patternImage.src;\n        }\n        else if (isCanvasLike(patternImage)) {\n            imageSrc = patternImage.toDataURL();\n        }\n        if (typeof Image === 'undefined') {\n            var errMsg = 'Image width/height must been given explictly in svg-ssr renderer.';\n            assert(imageWidth_1, errMsg);\n            assert(imageHeight_1, errMsg);\n        }\n        else if (imageWidth_1 == null || imageHeight_1 == null) {\n            var setSizeToVNode_1 = function (vNode, img) {\n                if (vNode) {\n                    var svgEl = vNode.elm;\n                    var width = imageWidth_1 || img.width;\n                    var height = imageHeight_1 || img.height;\n                    if (vNode.tag === 'pattern') {\n                        if (repeatX) {\n                            height = 1;\n                            width /= boundingRect.width;\n                        }\n                        else if (repeatY) {\n                            width = 1;\n                            height /= boundingRect.height;\n                        }\n                    }\n                    vNode.attrs.width = width;\n                    vNode.attrs.height = height;\n                    if (svgEl) {\n                        svgEl.setAttribute('width', width);\n                        svgEl.setAttribute('height', height);\n                    }\n                }\n            };\n            var createdImage = createOrUpdateImage(imageSrc, null, el, function (img) {\n                noRepeat || setSizeToVNode_1(patternVNode, img);\n                setSizeToVNode_1(child, img);\n            });\n            if (createdImage && createdImage.width && createdImage.height) {\n                imageWidth_1 = imageWidth_1 || createdImage.width;\n                imageHeight_1 = imageHeight_1 || createdImage.height;\n            }\n        }\n        child = createVNode('image', 'img', {\n            href: imageSrc,\n            width: imageWidth_1,\n            height: imageHeight_1\n        });\n        patternAttrs.width = imageWidth_1;\n        patternAttrs.height = imageHeight_1;\n    }\n    else if (val.svgElement) {\n        child = clone(val.svgElement);\n        patternAttrs.width = val.svgWidth;\n        patternAttrs.height = val.svgHeight;\n    }\n    if (!child) {\n        return;\n    }\n    var patternWidth;\n    var patternHeight;\n    if (noRepeat) {\n        patternWidth = patternHeight = 1;\n    }\n    else if (repeatX) {\n        patternHeight = 1;\n        patternWidth = patternAttrs.width / boundingRect.width;\n    }\n    else if (repeatY) {\n        patternWidth = 1;\n        patternHeight = patternAttrs.height / boundingRect.height;\n    }\n    else {\n        patternAttrs.patternUnits = 'userSpaceOnUse';\n    }\n    if (patternWidth != null && !isNaN(patternWidth)) {\n        patternAttrs.width = patternWidth;\n    }\n    if (patternHeight != null && !isNaN(patternHeight)) {\n        patternAttrs.height = patternHeight;\n    }\n    var patternTransform = getSRTTransformString(val);\n    patternTransform && (patternAttrs.patternTransform = patternTransform);\n    var patternVNode = createVNode('pattern', '', patternAttrs, [child]);\n    var patternKey = vNodeToString(patternVNode);\n    var patternCache = scope.patternCache;\n    var patternId = patternCache[patternKey];\n    if (!patternId) {\n        patternId = scope.zrId + '-p' + scope.patternIdx++;\n        patternCache[patternKey] = patternId;\n        patternAttrs.id = patternId;\n        patternVNode = scope.defs[patternId] = createVNode('pattern', patternId, patternAttrs, [child]);\n    }\n    attrs[target] = getIdURL(patternId);\n}\nexport function setClipPath(clipPath, attrs, scope) {\n    var clipPathCache = scope.clipPathCache, defs = scope.defs;\n    var clipPathId = clipPathCache[clipPath.id];\n    if (!clipPathId) {\n        clipPathId = scope.zrId + '-c' + scope.clipPathIdx++;\n        var clipPathAttrs = {\n            id: clipPathId\n        };\n        clipPathCache[clipPath.id] = clipPathId;\n        defs[clipPathId] = createVNode('clipPath', clipPathId, clipPathAttrs, [brushSVGPath(clipPath, scope)]);\n    }\n    attrs['clip-path'] = getIdURL(clipPathId);\n}\n"]},"metadata":{},"sourceType":"module"}