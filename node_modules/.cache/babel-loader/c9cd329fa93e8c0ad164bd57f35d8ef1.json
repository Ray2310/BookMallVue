{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Universal transitions that can animate between any shapes(series) and any properties in any amounts.\nimport { SERIES_UNIVERSAL_TRANSITION_PROP } from '../model/Series.js';\nimport { createHashMap, each, map, filter, isArray, extend } from 'zrender/lib/core/util.js';\nimport { applyMorphAnimation, getPathList } from './morphTransitionHelper.js';\nimport Path from 'zrender/lib/graphic/Path.js';\nimport { initProps } from '../util/graphic.js';\nimport DataDiffer from '../data/DataDiffer.js';\nimport { makeInner, normalizeToArray } from '../util/model.js';\nimport { warn } from '../util/log.js';\nimport { getAnimationConfig, getOldStyle } from './basicTransition.js';\nimport Displayable from 'zrender/lib/graphic/Displayable.js';\nvar DATA_COUNT_THRESHOLD = 1e4;\n;\nvar getUniversalTransitionGlobalStore = makeInner();\n\nfunction getGroupIdDimension(data) {\n  var dimensions = data.dimensions;\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimInfo = data.getDimensionInfo(dimensions[i]);\n\n    if (dimInfo && dimInfo.otherDims.itemGroupId === 0) {\n      return dimensions[i];\n    }\n  }\n}\n\nfunction flattenDataDiffItems(list) {\n  var items = [];\n  each(list, function (seriesInfo) {\n    var data = seriesInfo.data;\n\n    if (data.count() > DATA_COUNT_THRESHOLD) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('Universal transition is disabled on large data > 10k.');\n      }\n\n      return;\n    }\n\n    var indices = data.getIndices();\n    var groupDim = getGroupIdDimension(data);\n\n    for (var dataIndex = 0; dataIndex < indices.length; dataIndex++) {\n      items.push({\n        dataGroupId: seriesInfo.dataGroupId,\n        data: data,\n        dim: seriesInfo.dim || groupDim,\n        divide: seriesInfo.divide,\n        dataIndex: dataIndex\n      });\n    }\n  });\n  return items;\n}\n\nfunction fadeInElement(newEl, newSeries, newIndex) {\n  newEl.traverse(function (el) {\n    if (el instanceof Path) {\n      // TODO use fade in animation for target element.\n      initProps(el, {\n        style: {\n          opacity: 0\n        }\n      }, newSeries, {\n        dataIndex: newIndex,\n        isFrom: true\n      });\n    }\n  });\n}\n\nfunction removeEl(el) {\n  if (el.parent) {\n    // Bake parent transform to element.\n    // So it can still have proper transform to transition after it's removed.\n    var computedTransform = el.getComputedTransform();\n    el.setLocalTransform(computedTransform);\n    el.parent.remove(el);\n  }\n}\n\nfunction stopAnimation(el) {\n  el.stopAnimation();\n\n  if (el.isGroup) {\n    el.traverse(function (child) {\n      child.stopAnimation();\n    });\n  }\n}\n\nfunction animateElementStyles(el, dataIndex, seriesModel) {\n  var animationConfig = getAnimationConfig('update', seriesModel, dataIndex);\n  animationConfig && el.traverse(function (child) {\n    if (child instanceof Displayable) {\n      var oldStyle = getOldStyle(child);\n\n      if (oldStyle) {\n        child.animateFrom({\n          style: oldStyle\n        }, animationConfig);\n      }\n    }\n  });\n}\n\nfunction isAllIdSame(oldDiffItems, newDiffItems) {\n  var len = oldDiffItems.length;\n\n  if (len !== newDiffItems.length) {\n    return false;\n  }\n\n  for (var i = 0; i < len; i++) {\n    var oldItem = oldDiffItems[i];\n    var newItem = newDiffItems[i];\n\n    if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction transitionBetween(oldList, newList, api) {\n  var oldDiffItems = flattenDataDiffItems(oldList);\n  var newDiffItems = flattenDataDiffItems(newList);\n\n  function updateMorphingPathProps(from, to, rawFrom, rawTo, animationCfg) {\n    if (rawFrom || from) {\n      to.animateFrom({\n        style: rawFrom && rawFrom !== from ? // dividingMethod like clone may override the style(opacity)\n        // So extend it to raw style.\n        extend(extend({}, rawFrom.style), from.style) : from.style\n      }, animationCfg);\n    }\n  }\n\n  function findKeyDim(items) {\n    for (var i = 0; i < items.length; i++) {\n      if (items[i].dim) {\n        return items[i].dim;\n      }\n    }\n  }\n\n  var oldKeyDim = findKeyDim(oldDiffItems);\n  var newKeyDim = findKeyDim(newDiffItems);\n  var hasMorphAnimation = false;\n\n  function createKeyGetter(isOld, onlyGetId) {\n    return function (diffItem) {\n      var data = diffItem.data;\n      var dataIndex = diffItem.dataIndex; // TODO if specified dim\n\n      if (onlyGetId) {\n        return data.getId(dataIndex);\n      } // Use group id as transition key by default.\n      // So we can achieve multiple to multiple animation like drilldown / up naturally.\n      // If group id not exits. Use id instead. If so, only one to one transition will be applied.\n\n\n      var dataGroupId = diffItem.dataGroupId; // If specified key dimension(itemGroupId by default). Use this same dimension from other data.\n      // PENDING: If only use key dimension of newData.\n\n      var keyDim = isOld ? oldKeyDim || newKeyDim : newKeyDim || oldKeyDim;\n      var dimInfo = keyDim && data.getDimensionInfo(keyDim);\n      var dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta;\n\n      if (dimInfo) {\n        // Get from encode.itemGroupId.\n        var key = data.get(dimInfo.name, dataIndex);\n\n        if (dimOrdinalMeta) {\n          return dimOrdinalMeta.categories[key] || key + '';\n        }\n\n        return key + '';\n      } // Get groupId from raw item. { groupId: '' }\n\n\n      var itemVal = data.getRawDataItem(dataIndex);\n\n      if (itemVal && itemVal.groupId) {\n        return itemVal.groupId + '';\n      }\n\n      return dataGroupId || data.getId(dataIndex);\n    };\n  } // Use id if it's very likely to be an one to one animation\n  // It's more robust than groupId\n  // TODO Check if key dimension is specified.\n\n\n  var useId = isAllIdSame(oldDiffItems, newDiffItems);\n  var isElementStillInChart = {};\n\n  if (!useId) {\n    // We may have different diff strategy with basicTransition if we use other dimension as key.\n    // If so, we can't simply check if oldEl is same with newEl. We need a map to check if oldEl is still being used in the new chart.\n    // We can't use the elements that already being morphed. Let it keep it's original basic transition.\n    for (var i = 0; i < newDiffItems.length; i++) {\n      var newItem = newDiffItems[i];\n      var el = newItem.data.getItemGraphicEl(newItem.dataIndex);\n\n      if (el) {\n        isElementStillInChart[el.id] = true;\n      }\n    }\n  }\n\n  function updateOneToOne(newIndex, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var newItem = newDiffItems[newIndex];\n    var newSeries = newItem.data.hostModel; // TODO Mark this elements is morphed and don't morph them anymore\n\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);\n    var newEl = newItem.data.getItemGraphicEl(newItem.dataIndex); // Can't handle same elements.\n\n    if (oldEl === newEl) {\n      newEl && animateElementStyles(newEl, newItem.dataIndex, newSeries);\n      return;\n    }\n\n    if ( // We can't use the elements that already being morphed\n    oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n\n    if (newEl) {\n      // TODO: If keep animating the group in case\n      // some of the elements don't want to be morphed.\n      // TODO Label?\n      stopAnimation(newEl);\n\n      if (oldEl) {\n        stopAnimation(oldEl); // If old element is doing leaving animation. stop it and remove it immediately.\n\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newIndex);\n      }\n    } // else keep oldEl leaving animation.\n\n  }\n\n  new DataDiffer(oldDiffItems, newDiffItems, createKeyGetter(true, useId), createKeyGetter(false, useId), null, 'multiple').update(updateOneToOne).updateManyToOne(function (newIndex, oldIndices) {\n    var newItem = newDiffItems[newIndex];\n    var newData = newItem.data;\n    var newSeries = newData.hostModel;\n    var newEl = newData.getItemGraphicEl(newItem.dataIndex);\n    var oldElsList = filter(map(oldIndices, function (idx) {\n      return oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex);\n    }), function (oldEl) {\n      return oldEl && oldEl !== newEl && !isElementStillInChart[oldEl.id];\n    });\n\n    if (newEl) {\n      stopAnimation(newEl);\n\n      if (oldElsList.length) {\n        // If old element is doing leaving animation. stop it and remove it immediately.\n        each(oldElsList, function (oldEl) {\n          stopAnimation(oldEl);\n          removeEl(oldEl);\n        });\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldElsList), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newItem.dataIndex);\n      }\n    } // else keep oldEl leaving animation.\n\n  }).updateOneToMany(function (newIndices, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex); // We can't use the elements that already being morphed\n\n    if (oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n\n    var newElsList = filter(map(newIndices, function (idx) {\n      return newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex);\n    }), function (el) {\n      return el && el !== oldEl;\n    });\n    var newSeris = newDiffItems[newIndices[0]].data.hostModel;\n\n    if (newElsList.length) {\n      each(newElsList, function (newEl) {\n        return stopAnimation(newEl);\n      });\n\n      if (oldEl) {\n        stopAnimation(oldEl); // If old element is doing leaving animation. stop it and remove it immediately.\n\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newElsList), oldItem.divide, // Use divide on old.\n        newSeris, newIndices[0], updateMorphingPathProps);\n      } else {\n        each(newElsList, function (newEl) {\n          return fadeInElement(newEl, newSeris, newIndices[0]);\n        });\n      }\n    } // else keep oldEl leaving animation.\n\n  }).updateManyToMany(function (newIndices, oldIndices) {\n    // If two data are same and both have groupId.\n    // Normally they should be diff by id.\n    new DataDiffer(oldIndices, newIndices, function (rawIdx) {\n      return oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex);\n    }, function (rawIdx) {\n      return newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex);\n    }).update(function (newIndex, oldIndex) {\n      // Use the original index\n      updateOneToOne(newIndices[newIndex], oldIndices[oldIndex]);\n    }).execute();\n  }).execute();\n\n  if (hasMorphAnimation) {\n    each(newList, function (_a) {\n      var data = _a.data;\n      var seriesModel = data.hostModel;\n      var view = seriesModel && api.getViewOfSeriesModel(seriesModel);\n      var animationCfg = getAnimationConfig('update', seriesModel, 0); // use 0 index.\n\n      if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) {\n        view.group.traverse(function (el) {\n          if (el instanceof Path && !el.animators.length) {\n            // We can't accept there still exists element that has no animation\n            // if universalTransition is enabled\n            el.animateFrom({\n              style: {\n                opacity: 0\n              }\n            }, animationCfg);\n          }\n        });\n      }\n    });\n  }\n}\n\nfunction getSeriesTransitionKey(series) {\n  var seriesKey = series.getModel('universalTransition').get('seriesKey');\n\n  if (!seriesKey) {\n    // Use series id by default.\n    return series.id;\n  }\n\n  return seriesKey;\n}\n\nfunction convertArraySeriesKeyToString(seriesKey) {\n  if (isArray(seriesKey)) {\n    // Order independent.\n    return seriesKey.sort().join(',');\n  }\n\n  return seriesKey;\n}\n\nfunction getDivideShapeFromData(data) {\n  if (data.hostModel) {\n    return data.hostModel.getModel('universalTransition').get('divideShape');\n  }\n}\n\nfunction findTransitionSeriesBatches(globalStore, params) {\n  var updateBatches = createHashMap();\n  var oldDataMap = createHashMap(); // Map that only store key in array seriesKey.\n  // Which is used to query the old data when transition from one to multiple series.\n\n  var oldDataMapForSplit = createHashMap();\n  each(globalStore.oldSeries, function (series, idx) {\n    var oldDataGroupId = globalStore.oldDataGroupIds[idx];\n    var oldData = globalStore.oldData[idx];\n    var transitionKey = getSeriesTransitionKey(series);\n    var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);\n    oldDataMap.set(transitionKeyStr, {\n      dataGroupId: oldDataGroupId,\n      data: oldData\n    });\n\n    if (isArray(transitionKey)) {\n      // Same key can't in different array seriesKey.\n      each(transitionKey, function (key) {\n        oldDataMapForSplit.set(key, {\n          key: transitionKeyStr,\n          dataGroupId: oldDataGroupId,\n          data: oldData\n        });\n      });\n    }\n  });\n\n  function checkTransitionSeriesKeyDuplicated(transitionKeyStr) {\n    if (updateBatches.get(transitionKeyStr)) {\n      warn(\"Duplicated seriesKey in universalTransition \" + transitionKeyStr);\n    }\n  }\n\n  each(params.updatedSeries, function (series) {\n    if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {\n      var newDataGroupId = series.get('dataGroupId');\n      var newData = series.getData();\n      var transitionKey = getSeriesTransitionKey(series);\n      var transitionKeyStr = convertArraySeriesKeyToString(transitionKey); // Only transition between series with same id.\n\n      var oldData = oldDataMap.get(transitionKeyStr); // string transition key is the best match.\n\n      if (oldData) {\n        if (process.env.NODE_ENV !== 'production') {\n          checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n        } // TODO check if data is same?\n\n\n        updateBatches.set(transitionKeyStr, {\n          oldSeries: [{\n            dataGroupId: oldData.dataGroupId,\n            divide: getDivideShapeFromData(oldData.data),\n            data: oldData.data\n          }],\n          newSeries: [{\n            dataGroupId: newDataGroupId,\n            divide: getDivideShapeFromData(newData),\n            data: newData\n          }]\n        });\n      } else {\n        // Transition from multiple series.\n        if (isArray(transitionKey)) {\n          if (process.env.NODE_ENV !== 'production') {\n            checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n          }\n\n          var oldSeries_1 = [];\n          each(transitionKey, function (key) {\n            var oldData = oldDataMap.get(key);\n\n            if (oldData.data) {\n              oldSeries_1.push({\n                dataGroupId: oldData.dataGroupId,\n                divide: getDivideShapeFromData(oldData.data),\n                data: oldData.data\n              });\n            }\n          });\n\n          if (oldSeries_1.length) {\n            updateBatches.set(transitionKeyStr, {\n              oldSeries: oldSeries_1,\n              newSeries: [{\n                dataGroupId: newDataGroupId,\n                data: newData,\n                divide: getDivideShapeFromData(newData)\n              }]\n            });\n          }\n        } else {\n          // Try transition to multiple series.\n          var oldData_1 = oldDataMapForSplit.get(transitionKey);\n\n          if (oldData_1) {\n            var batch = updateBatches.get(oldData_1.key);\n\n            if (!batch) {\n              batch = {\n                oldSeries: [{\n                  dataGroupId: oldData_1.dataGroupId,\n                  data: oldData_1.data,\n                  divide: getDivideShapeFromData(oldData_1.data)\n                }],\n                newSeries: []\n              };\n              updateBatches.set(oldData_1.key, batch);\n            }\n\n            batch.newSeries.push({\n              dataGroupId: newDataGroupId,\n              data: newData,\n              divide: getDivideShapeFromData(newData)\n            });\n          }\n        }\n      }\n    }\n  });\n  return updateBatches;\n}\n\nfunction querySeries(series, finder) {\n  for (var i = 0; i < series.length; i++) {\n    var found = finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id;\n\n    if (found) {\n      return i;\n    }\n  }\n}\n\nfunction transitionSeriesFromOpt(transitionOpt, globalStore, params, api) {\n  var from = [];\n  var to = [];\n  each(normalizeToArray(transitionOpt.from), function (finder) {\n    var idx = querySeries(globalStore.oldSeries, finder);\n\n    if (idx >= 0) {\n      from.push({\n        dataGroupId: globalStore.oldDataGroupIds[idx],\n        data: globalStore.oldData[idx],\n        // TODO can specify divideShape in transition.\n        divide: getDivideShapeFromData(globalStore.oldData[idx]),\n        dim: finder.dimension\n      });\n    }\n  });\n  each(normalizeToArray(transitionOpt.to), function (finder) {\n    var idx = querySeries(params.updatedSeries, finder);\n\n    if (idx >= 0) {\n      var data = params.updatedSeries[idx].getData();\n      to.push({\n        dataGroupId: globalStore.oldDataGroupIds[idx],\n        data: data,\n        divide: getDivideShapeFromData(data),\n        dim: finder.dimension\n      });\n    }\n  });\n\n  if (from.length > 0 && to.length > 0) {\n    transitionBetween(from, to, api);\n  }\n}\n\nexport function installUniversalTransition(registers) {\n  registers.registerUpdateLifecycle('series:beforeupdate', function (ecMOdel, api, params) {\n    each(normalizeToArray(params.seriesTransition), function (transOpt) {\n      each(normalizeToArray(transOpt.to), function (finder) {\n        var series = params.updatedSeries;\n\n        for (var i = 0; i < series.length; i++) {\n          if (finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id) {\n            series[i][SERIES_UNIVERSAL_TRANSITION_PROP] = true;\n          }\n        }\n      });\n    });\n  });\n  registers.registerUpdateLifecycle('series:transition', function (ecModel, api, params) {\n    // TODO api provide an namespace that can save stuff per instance\n    var globalStore = getUniversalTransitionGlobalStore(api); // TODO multiple to multiple series.\n\n    if (globalStore.oldSeries && params.updatedSeries && params.optionChanged) {\n      // Use give transition config if its' give;\n      var transitionOpt = params.seriesTransition;\n\n      if (transitionOpt) {\n        each(normalizeToArray(transitionOpt), function (opt) {\n          transitionSeriesFromOpt(opt, globalStore, params, api);\n        });\n      } else {\n        // Else guess from series based on transition series key.\n        var updateBatches_1 = findTransitionSeriesBatches(globalStore, params);\n        each(updateBatches_1.keys(), function (key) {\n          var batch = updateBatches_1.get(key);\n          transitionBetween(batch.oldSeries, batch.newSeries, api);\n        });\n      } // Reset\n\n\n      each(params.updatedSeries, function (series) {\n        // Reset;\n        if (series[SERIES_UNIVERSAL_TRANSITION_PROP]) {\n          series[SERIES_UNIVERSAL_TRANSITION_PROP] = false;\n        }\n      });\n    } // Save all series of current update. Not only the updated one.\n\n\n    var allSeries = ecModel.getSeries();\n    var savedSeries = globalStore.oldSeries = [];\n    var savedDataGroupIds = globalStore.oldDataGroupIds = [];\n    var savedData = globalStore.oldData = [];\n\n    for (var i = 0; i < allSeries.length; i++) {\n      var data = allSeries[i].getData(); // Only save the data that can have transition.\n      // Avoid large data costing too much extra memory\n\n      if (data.count() < DATA_COUNT_THRESHOLD) {\n        savedSeries.push(allSeries[i]);\n        savedDataGroupIds.push(allSeries[i].get('dataGroupId'));\n        savedData.push(data);\n      }\n    }\n  });\n}","map":{"version":3,"sources":["D:/Work/WorkSpace/GitWorkSpace/TenShop/resource/ElectronicMall/src/ElectronicMallVue/node_modules/echarts/lib/animation/universalTransition.js"],"names":["SERIES_UNIVERSAL_TRANSITION_PROP","createHashMap","each","map","filter","isArray","extend","applyMorphAnimation","getPathList","Path","initProps","DataDiffer","makeInner","normalizeToArray","warn","getAnimationConfig","getOldStyle","Displayable","DATA_COUNT_THRESHOLD","getUniversalTransitionGlobalStore","getGroupIdDimension","data","dimensions","i","length","dimInfo","getDimensionInfo","otherDims","itemGroupId","flattenDataDiffItems","list","items","seriesInfo","count","process","env","NODE_ENV","indices","getIndices","groupDim","dataIndex","push","dataGroupId","dim","divide","fadeInElement","newEl","newSeries","newIndex","traverse","el","style","opacity","isFrom","removeEl","parent","computedTransform","getComputedTransform","setLocalTransform","remove","stopAnimation","isGroup","child","animateElementStyles","seriesModel","animationConfig","oldStyle","animateFrom","isAllIdSame","oldDiffItems","newDiffItems","len","oldItem","newItem","getId","transitionBetween","oldList","newList","api","updateMorphingPathProps","from","to","rawFrom","rawTo","animationCfg","findKeyDim","oldKeyDim","newKeyDim","hasMorphAnimation","createKeyGetter","isOld","onlyGetId","diffItem","keyDim","dimOrdinalMeta","ordinalMeta","key","get","name","categories","itemVal","getRawDataItem","groupId","useId","isElementStillInChart","getItemGraphicEl","id","updateOneToOne","oldIndex","hostModel","oldEl","update","updateManyToOne","oldIndices","newData","oldElsList","idx","updateOneToMany","newIndices","newElsList","newSeris","updateManyToMany","rawIdx","execute","_a","view","getViewOfSeriesModel","isAnimationEnabled","duration","group","animators","getSeriesTransitionKey","series","seriesKey","getModel","convertArraySeriesKeyToString","sort","join","getDivideShapeFromData","findTransitionSeriesBatches","globalStore","params","updateBatches","oldDataMap","oldDataMapForSplit","oldSeries","oldDataGroupId","oldDataGroupIds","oldData","transitionKey","transitionKeyStr","set","checkTransitionSeriesKeyDuplicated","updatedSeries","isUniversalTransitionEnabled","newDataGroupId","getData","oldSeries_1","oldData_1","batch","querySeries","finder","found","seriesIndex","seriesId","transitionSeriesFromOpt","transitionOpt","dimension","installUniversalTransition","registers","registerUpdateLifecycle","ecMOdel","seriesTransition","transOpt","ecModel","optionChanged","opt","updateBatches_1","keys","allSeries","getSeries","savedSeries","savedDataGroupIds","savedData"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Universal transitions that can animate between any shapes(series) and any properties in any amounts.\nimport { SERIES_UNIVERSAL_TRANSITION_PROP } from '../model/Series.js';\nimport { createHashMap, each, map, filter, isArray, extend } from 'zrender/lib/core/util.js';\nimport { applyMorphAnimation, getPathList } from './morphTransitionHelper.js';\nimport Path from 'zrender/lib/graphic/Path.js';\nimport { initProps } from '../util/graphic.js';\nimport DataDiffer from '../data/DataDiffer.js';\nimport { makeInner, normalizeToArray } from '../util/model.js';\nimport { warn } from '../util/log.js';\nimport { getAnimationConfig, getOldStyle } from './basicTransition.js';\nimport Displayable from 'zrender/lib/graphic/Displayable.js';\nvar DATA_COUNT_THRESHOLD = 1e4;\n;\nvar getUniversalTransitionGlobalStore = makeInner();\n\nfunction getGroupIdDimension(data) {\n  var dimensions = data.dimensions;\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimInfo = data.getDimensionInfo(dimensions[i]);\n\n    if (dimInfo && dimInfo.otherDims.itemGroupId === 0) {\n      return dimensions[i];\n    }\n  }\n}\n\nfunction flattenDataDiffItems(list) {\n  var items = [];\n  each(list, function (seriesInfo) {\n    var data = seriesInfo.data;\n\n    if (data.count() > DATA_COUNT_THRESHOLD) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('Universal transition is disabled on large data > 10k.');\n      }\n\n      return;\n    }\n\n    var indices = data.getIndices();\n    var groupDim = getGroupIdDimension(data);\n\n    for (var dataIndex = 0; dataIndex < indices.length; dataIndex++) {\n      items.push({\n        dataGroupId: seriesInfo.dataGroupId,\n        data: data,\n        dim: seriesInfo.dim || groupDim,\n        divide: seriesInfo.divide,\n        dataIndex: dataIndex\n      });\n    }\n  });\n  return items;\n}\n\nfunction fadeInElement(newEl, newSeries, newIndex) {\n  newEl.traverse(function (el) {\n    if (el instanceof Path) {\n      // TODO use fade in animation for target element.\n      initProps(el, {\n        style: {\n          opacity: 0\n        }\n      }, newSeries, {\n        dataIndex: newIndex,\n        isFrom: true\n      });\n    }\n  });\n}\n\nfunction removeEl(el) {\n  if (el.parent) {\n    // Bake parent transform to element.\n    // So it can still have proper transform to transition after it's removed.\n    var computedTransform = el.getComputedTransform();\n    el.setLocalTransform(computedTransform);\n    el.parent.remove(el);\n  }\n}\n\nfunction stopAnimation(el) {\n  el.stopAnimation();\n\n  if (el.isGroup) {\n    el.traverse(function (child) {\n      child.stopAnimation();\n    });\n  }\n}\n\nfunction animateElementStyles(el, dataIndex, seriesModel) {\n  var animationConfig = getAnimationConfig('update', seriesModel, dataIndex);\n  animationConfig && el.traverse(function (child) {\n    if (child instanceof Displayable) {\n      var oldStyle = getOldStyle(child);\n\n      if (oldStyle) {\n        child.animateFrom({\n          style: oldStyle\n        }, animationConfig);\n      }\n    }\n  });\n}\n\nfunction isAllIdSame(oldDiffItems, newDiffItems) {\n  var len = oldDiffItems.length;\n\n  if (len !== newDiffItems.length) {\n    return false;\n  }\n\n  for (var i = 0; i < len; i++) {\n    var oldItem = oldDiffItems[i];\n    var newItem = newDiffItems[i];\n\n    if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction transitionBetween(oldList, newList, api) {\n  var oldDiffItems = flattenDataDiffItems(oldList);\n  var newDiffItems = flattenDataDiffItems(newList);\n\n  function updateMorphingPathProps(from, to, rawFrom, rawTo, animationCfg) {\n    if (rawFrom || from) {\n      to.animateFrom({\n        style: rawFrom && rawFrom !== from ? // dividingMethod like clone may override the style(opacity)\n        // So extend it to raw style.\n        extend(extend({}, rawFrom.style), from.style) : from.style\n      }, animationCfg);\n    }\n  }\n\n  function findKeyDim(items) {\n    for (var i = 0; i < items.length; i++) {\n      if (items[i].dim) {\n        return items[i].dim;\n      }\n    }\n  }\n\n  var oldKeyDim = findKeyDim(oldDiffItems);\n  var newKeyDim = findKeyDim(newDiffItems);\n  var hasMorphAnimation = false;\n\n  function createKeyGetter(isOld, onlyGetId) {\n    return function (diffItem) {\n      var data = diffItem.data;\n      var dataIndex = diffItem.dataIndex; // TODO if specified dim\n\n      if (onlyGetId) {\n        return data.getId(dataIndex);\n      } // Use group id as transition key by default.\n      // So we can achieve multiple to multiple animation like drilldown / up naturally.\n      // If group id not exits. Use id instead. If so, only one to one transition will be applied.\n\n\n      var dataGroupId = diffItem.dataGroupId; // If specified key dimension(itemGroupId by default). Use this same dimension from other data.\n      // PENDING: If only use key dimension of newData.\n\n      var keyDim = isOld ? oldKeyDim || newKeyDim : newKeyDim || oldKeyDim;\n      var dimInfo = keyDim && data.getDimensionInfo(keyDim);\n      var dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta;\n\n      if (dimInfo) {\n        // Get from encode.itemGroupId.\n        var key = data.get(dimInfo.name, dataIndex);\n\n        if (dimOrdinalMeta) {\n          return dimOrdinalMeta.categories[key] || key + '';\n        }\n\n        return key + '';\n      } // Get groupId from raw item. { groupId: '' }\n\n\n      var itemVal = data.getRawDataItem(dataIndex);\n\n      if (itemVal && itemVal.groupId) {\n        return itemVal.groupId + '';\n      }\n\n      return dataGroupId || data.getId(dataIndex);\n    };\n  } // Use id if it's very likely to be an one to one animation\n  // It's more robust than groupId\n  // TODO Check if key dimension is specified.\n\n\n  var useId = isAllIdSame(oldDiffItems, newDiffItems);\n  var isElementStillInChart = {};\n\n  if (!useId) {\n    // We may have different diff strategy with basicTransition if we use other dimension as key.\n    // If so, we can't simply check if oldEl is same with newEl. We need a map to check if oldEl is still being used in the new chart.\n    // We can't use the elements that already being morphed. Let it keep it's original basic transition.\n    for (var i = 0; i < newDiffItems.length; i++) {\n      var newItem = newDiffItems[i];\n      var el = newItem.data.getItemGraphicEl(newItem.dataIndex);\n\n      if (el) {\n        isElementStillInChart[el.id] = true;\n      }\n    }\n  }\n\n  function updateOneToOne(newIndex, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var newItem = newDiffItems[newIndex];\n    var newSeries = newItem.data.hostModel; // TODO Mark this elements is morphed and don't morph them anymore\n\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);\n    var newEl = newItem.data.getItemGraphicEl(newItem.dataIndex); // Can't handle same elements.\n\n    if (oldEl === newEl) {\n      newEl && animateElementStyles(newEl, newItem.dataIndex, newSeries);\n      return;\n    }\n\n    if ( // We can't use the elements that already being morphed\n    oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n\n    if (newEl) {\n      // TODO: If keep animating the group in case\n      // some of the elements don't want to be morphed.\n      // TODO Label?\n      stopAnimation(newEl);\n\n      if (oldEl) {\n        stopAnimation(oldEl); // If old element is doing leaving animation. stop it and remove it immediately.\n\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newIndex);\n      }\n    } // else keep oldEl leaving animation.\n\n  }\n\n  new DataDiffer(oldDiffItems, newDiffItems, createKeyGetter(true, useId), createKeyGetter(false, useId), null, 'multiple').update(updateOneToOne).updateManyToOne(function (newIndex, oldIndices) {\n    var newItem = newDiffItems[newIndex];\n    var newData = newItem.data;\n    var newSeries = newData.hostModel;\n    var newEl = newData.getItemGraphicEl(newItem.dataIndex);\n    var oldElsList = filter(map(oldIndices, function (idx) {\n      return oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex);\n    }), function (oldEl) {\n      return oldEl && oldEl !== newEl && !isElementStillInChart[oldEl.id];\n    });\n\n    if (newEl) {\n      stopAnimation(newEl);\n\n      if (oldElsList.length) {\n        // If old element is doing leaving animation. stop it and remove it immediately.\n        each(oldElsList, function (oldEl) {\n          stopAnimation(oldEl);\n          removeEl(oldEl);\n        });\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldElsList), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newItem.dataIndex);\n      }\n    } // else keep oldEl leaving animation.\n\n  }).updateOneToMany(function (newIndices, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex); // We can't use the elements that already being morphed\n\n    if (oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n\n    var newElsList = filter(map(newIndices, function (idx) {\n      return newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex);\n    }), function (el) {\n      return el && el !== oldEl;\n    });\n    var newSeris = newDiffItems[newIndices[0]].data.hostModel;\n\n    if (newElsList.length) {\n      each(newElsList, function (newEl) {\n        return stopAnimation(newEl);\n      });\n\n      if (oldEl) {\n        stopAnimation(oldEl); // If old element is doing leaving animation. stop it and remove it immediately.\n\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newElsList), oldItem.divide, // Use divide on old.\n        newSeris, newIndices[0], updateMorphingPathProps);\n      } else {\n        each(newElsList, function (newEl) {\n          return fadeInElement(newEl, newSeris, newIndices[0]);\n        });\n      }\n    } // else keep oldEl leaving animation.\n\n  }).updateManyToMany(function (newIndices, oldIndices) {\n    // If two data are same and both have groupId.\n    // Normally they should be diff by id.\n    new DataDiffer(oldIndices, newIndices, function (rawIdx) {\n      return oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex);\n    }, function (rawIdx) {\n      return newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex);\n    }).update(function (newIndex, oldIndex) {\n      // Use the original index\n      updateOneToOne(newIndices[newIndex], oldIndices[oldIndex]);\n    }).execute();\n  }).execute();\n\n  if (hasMorphAnimation) {\n    each(newList, function (_a) {\n      var data = _a.data;\n      var seriesModel = data.hostModel;\n      var view = seriesModel && api.getViewOfSeriesModel(seriesModel);\n      var animationCfg = getAnimationConfig('update', seriesModel, 0); // use 0 index.\n\n      if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) {\n        view.group.traverse(function (el) {\n          if (el instanceof Path && !el.animators.length) {\n            // We can't accept there still exists element that has no animation\n            // if universalTransition is enabled\n            el.animateFrom({\n              style: {\n                opacity: 0\n              }\n            }, animationCfg);\n          }\n        });\n      }\n    });\n  }\n}\n\nfunction getSeriesTransitionKey(series) {\n  var seriesKey = series.getModel('universalTransition').get('seriesKey');\n\n  if (!seriesKey) {\n    // Use series id by default.\n    return series.id;\n  }\n\n  return seriesKey;\n}\n\nfunction convertArraySeriesKeyToString(seriesKey) {\n  if (isArray(seriesKey)) {\n    // Order independent.\n    return seriesKey.sort().join(',');\n  }\n\n  return seriesKey;\n}\n\nfunction getDivideShapeFromData(data) {\n  if (data.hostModel) {\n    return data.hostModel.getModel('universalTransition').get('divideShape');\n  }\n}\n\nfunction findTransitionSeriesBatches(globalStore, params) {\n  var updateBatches = createHashMap();\n  var oldDataMap = createHashMap(); // Map that only store key in array seriesKey.\n  // Which is used to query the old data when transition from one to multiple series.\n\n  var oldDataMapForSplit = createHashMap();\n  each(globalStore.oldSeries, function (series, idx) {\n    var oldDataGroupId = globalStore.oldDataGroupIds[idx];\n    var oldData = globalStore.oldData[idx];\n    var transitionKey = getSeriesTransitionKey(series);\n    var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);\n    oldDataMap.set(transitionKeyStr, {\n      dataGroupId: oldDataGroupId,\n      data: oldData\n    });\n\n    if (isArray(transitionKey)) {\n      // Same key can't in different array seriesKey.\n      each(transitionKey, function (key) {\n        oldDataMapForSplit.set(key, {\n          key: transitionKeyStr,\n          dataGroupId: oldDataGroupId,\n          data: oldData\n        });\n      });\n    }\n  });\n\n  function checkTransitionSeriesKeyDuplicated(transitionKeyStr) {\n    if (updateBatches.get(transitionKeyStr)) {\n      warn(\"Duplicated seriesKey in universalTransition \" + transitionKeyStr);\n    }\n  }\n\n  each(params.updatedSeries, function (series) {\n    if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {\n      var newDataGroupId = series.get('dataGroupId');\n      var newData = series.getData();\n      var transitionKey = getSeriesTransitionKey(series);\n      var transitionKeyStr = convertArraySeriesKeyToString(transitionKey); // Only transition between series with same id.\n\n      var oldData = oldDataMap.get(transitionKeyStr); // string transition key is the best match.\n\n      if (oldData) {\n        if (process.env.NODE_ENV !== 'production') {\n          checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n        } // TODO check if data is same?\n\n\n        updateBatches.set(transitionKeyStr, {\n          oldSeries: [{\n            dataGroupId: oldData.dataGroupId,\n            divide: getDivideShapeFromData(oldData.data),\n            data: oldData.data\n          }],\n          newSeries: [{\n            dataGroupId: newDataGroupId,\n            divide: getDivideShapeFromData(newData),\n            data: newData\n          }]\n        });\n      } else {\n        // Transition from multiple series.\n        if (isArray(transitionKey)) {\n          if (process.env.NODE_ENV !== 'production') {\n            checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n          }\n\n          var oldSeries_1 = [];\n          each(transitionKey, function (key) {\n            var oldData = oldDataMap.get(key);\n\n            if (oldData.data) {\n              oldSeries_1.push({\n                dataGroupId: oldData.dataGroupId,\n                divide: getDivideShapeFromData(oldData.data),\n                data: oldData.data\n              });\n            }\n          });\n\n          if (oldSeries_1.length) {\n            updateBatches.set(transitionKeyStr, {\n              oldSeries: oldSeries_1,\n              newSeries: [{\n                dataGroupId: newDataGroupId,\n                data: newData,\n                divide: getDivideShapeFromData(newData)\n              }]\n            });\n          }\n        } else {\n          // Try transition to multiple series.\n          var oldData_1 = oldDataMapForSplit.get(transitionKey);\n\n          if (oldData_1) {\n            var batch = updateBatches.get(oldData_1.key);\n\n            if (!batch) {\n              batch = {\n                oldSeries: [{\n                  dataGroupId: oldData_1.dataGroupId,\n                  data: oldData_1.data,\n                  divide: getDivideShapeFromData(oldData_1.data)\n                }],\n                newSeries: []\n              };\n              updateBatches.set(oldData_1.key, batch);\n            }\n\n            batch.newSeries.push({\n              dataGroupId: newDataGroupId,\n              data: newData,\n              divide: getDivideShapeFromData(newData)\n            });\n          }\n        }\n      }\n    }\n  });\n  return updateBatches;\n}\n\nfunction querySeries(series, finder) {\n  for (var i = 0; i < series.length; i++) {\n    var found = finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id;\n\n    if (found) {\n      return i;\n    }\n  }\n}\n\nfunction transitionSeriesFromOpt(transitionOpt, globalStore, params, api) {\n  var from = [];\n  var to = [];\n  each(normalizeToArray(transitionOpt.from), function (finder) {\n    var idx = querySeries(globalStore.oldSeries, finder);\n\n    if (idx >= 0) {\n      from.push({\n        dataGroupId: globalStore.oldDataGroupIds[idx],\n        data: globalStore.oldData[idx],\n        // TODO can specify divideShape in transition.\n        divide: getDivideShapeFromData(globalStore.oldData[idx]),\n        dim: finder.dimension\n      });\n    }\n  });\n  each(normalizeToArray(transitionOpt.to), function (finder) {\n    var idx = querySeries(params.updatedSeries, finder);\n\n    if (idx >= 0) {\n      var data = params.updatedSeries[idx].getData();\n      to.push({\n        dataGroupId: globalStore.oldDataGroupIds[idx],\n        data: data,\n        divide: getDivideShapeFromData(data),\n        dim: finder.dimension\n      });\n    }\n  });\n\n  if (from.length > 0 && to.length > 0) {\n    transitionBetween(from, to, api);\n  }\n}\n\nexport function installUniversalTransition(registers) {\n  registers.registerUpdateLifecycle('series:beforeupdate', function (ecMOdel, api, params) {\n    each(normalizeToArray(params.seriesTransition), function (transOpt) {\n      each(normalizeToArray(transOpt.to), function (finder) {\n        var series = params.updatedSeries;\n\n        for (var i = 0; i < series.length; i++) {\n          if (finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id) {\n            series[i][SERIES_UNIVERSAL_TRANSITION_PROP] = true;\n          }\n        }\n      });\n    });\n  });\n  registers.registerUpdateLifecycle('series:transition', function (ecModel, api, params) {\n    // TODO api provide an namespace that can save stuff per instance\n    var globalStore = getUniversalTransitionGlobalStore(api); // TODO multiple to multiple series.\n\n    if (globalStore.oldSeries && params.updatedSeries && params.optionChanged) {\n      // Use give transition config if its' give;\n      var transitionOpt = params.seriesTransition;\n\n      if (transitionOpt) {\n        each(normalizeToArray(transitionOpt), function (opt) {\n          transitionSeriesFromOpt(opt, globalStore, params, api);\n        });\n      } else {\n        // Else guess from series based on transition series key.\n        var updateBatches_1 = findTransitionSeriesBatches(globalStore, params);\n        each(updateBatches_1.keys(), function (key) {\n          var batch = updateBatches_1.get(key);\n          transitionBetween(batch.oldSeries, batch.newSeries, api);\n        });\n      } // Reset\n\n\n      each(params.updatedSeries, function (series) {\n        // Reset;\n        if (series[SERIES_UNIVERSAL_TRANSITION_PROP]) {\n          series[SERIES_UNIVERSAL_TRANSITION_PROP] = false;\n        }\n      });\n    } // Save all series of current update. Not only the updated one.\n\n\n    var allSeries = ecModel.getSeries();\n    var savedSeries = globalStore.oldSeries = [];\n    var savedDataGroupIds = globalStore.oldDataGroupIds = [];\n    var savedData = globalStore.oldData = [];\n\n    for (var i = 0; i < allSeries.length; i++) {\n      var data = allSeries[i].getData(); // Only save the data that can have transition.\n      // Avoid large data costing too much extra memory\n\n      if (data.count() < DATA_COUNT_THRESHOLD) {\n        savedSeries.push(allSeries[i]);\n        savedDataGroupIds.push(allSeries[i].get('dataGroupId'));\n        savedData.push(data);\n      }\n    }\n  });\n}"]},"metadata":{},"sourceType":"module"}