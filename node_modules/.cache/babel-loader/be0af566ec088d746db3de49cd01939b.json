{"ast":null,"code":"import \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.error.cause.js\";\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport { makeInner, normalizeToArray } from '../util/model.js';\nimport { assert, bind, each, eqNaN, extend, hasOwn, indexOf, isArrayLike, keys, reduce } from 'zrender/lib/core/util.js';\nimport { cloneValue } from 'zrender/lib/animation/Animator.js';\nimport Displayable from 'zrender/lib/graphic/Displayable.js';\nimport { getAnimationConfig } from './basicTrasition.js';\nimport { Path } from '../util/graphic.js';\nimport { warn } from '../util/log.js';\nimport { TRANSFORMABLE_PROPS } from 'zrender/lib/core/Transformable.js';\nvar LEGACY_TRANSFORM_PROPS_MAP = {\n  position: ['x', 'y'],\n  scale: ['scaleX', 'scaleY'],\n  origin: ['originX', 'originY']\n};\nvar LEGACY_TRANSFORM_PROPS = keys(LEGACY_TRANSFORM_PROPS_MAP);\nvar TRANSFORM_PROPS_MAP = reduce(TRANSFORMABLE_PROPS, function (obj, key) {\n  obj[key] = 1;\n  return obj;\n}, {});\nvar transformPropNamesStr = TRANSFORMABLE_PROPS.join(', '); // '' means root\n\nexport var ELEMENT_ANIMATABLE_PROPS = ['', 'style', 'shape', 'extra'];\n;\nvar transitionInnerStore = makeInner();\n;\n\nfunction getElementAnimationConfig(animationType, el, elOption, parentModel, dataIndex) {\n  var animationProp = animationType + \"Animation\";\n  var config = getAnimationConfig(animationType, parentModel, dataIndex) || {};\n  var userDuring = transitionInnerStore(el).userDuring; // Only set when duration is > 0 and it's need to be animated.\n\n  if (config.duration > 0) {\n    // For simplicity, if during not specified, the previous during will not work any more.\n    config.during = userDuring ? bind(duringCall, {\n      el: el,\n      userDuring: userDuring\n    }) : null;\n    config.setToFinal = true;\n    config.scope = animationType;\n  }\n\n  extend(config, elOption[animationProp]);\n  return config;\n}\n\nexport function applyUpdateTransition(el, elOption, animatableModel, opts) {\n  opts = opts || {};\n  var dataIndex = opts.dataIndex,\n      isInit = opts.isInit,\n      clearStyle = opts.clearStyle;\n  var hasAnimation = animatableModel.isAnimationEnabled(); // Save the meta info for further morphing. Like apply on the sub morphing elements.\n\n  var store = transitionInnerStore(el);\n  var styleOpt = elOption.style;\n  store.userDuring = elOption.during;\n  var transFromProps = {};\n  var propsToSet = {};\n  prepareTransformAllPropsFinal(el, elOption, propsToSet);\n  prepareShapeOrExtraAllPropsFinal('shape', elOption, propsToSet);\n  prepareShapeOrExtraAllPropsFinal('extra', elOption, propsToSet);\n\n  if (!isInit && hasAnimation) {\n    prepareTransformTransitionFrom(el, elOption, transFromProps);\n    prepareShapeOrExtraTransitionFrom('shape', el, elOption, transFromProps);\n    prepareShapeOrExtraTransitionFrom('extra', el, elOption, transFromProps);\n    prepareStyleTransitionFrom(el, elOption, styleOpt, transFromProps);\n  }\n\n  propsToSet.style = styleOpt;\n  applyPropsDirectly(el, propsToSet, clearStyle);\n  applyMiscProps(el, elOption);\n\n  if (hasAnimation) {\n    if (isInit) {\n      var enterFromProps_1 = {};\n      each(ELEMENT_ANIMATABLE_PROPS, function (propName) {\n        var prop = propName ? elOption[propName] : elOption;\n\n        if (prop && prop.enterFrom) {\n          if (propName) {\n            enterFromProps_1[propName] = enterFromProps_1[propName] || {};\n          }\n\n          extend(propName ? enterFromProps_1[propName] : enterFromProps_1, prop.enterFrom);\n        }\n      });\n      var config = getElementAnimationConfig('enter', el, elOption, animatableModel, dataIndex);\n\n      if (config.duration > 0) {\n        el.animateFrom(enterFromProps_1, config);\n      }\n    } else {\n      applyPropsTransition(el, elOption, dataIndex || 0, animatableModel, transFromProps);\n    }\n  } // Store leave to be used in leave transition.\n\n\n  updateLeaveTo(el, elOption);\n  styleOpt ? el.dirty() : el.markRedraw();\n}\nexport function updateLeaveTo(el, elOption) {\n  // Try merge to previous set leaveTo\n  var leaveToProps = transitionInnerStore(el).leaveToProps;\n\n  for (var i = 0; i < ELEMENT_ANIMATABLE_PROPS.length; i++) {\n    var propName = ELEMENT_ANIMATABLE_PROPS[i];\n    var prop = propName ? elOption[propName] : elOption;\n\n    if (prop && prop.leaveTo) {\n      if (!leaveToProps) {\n        leaveToProps = transitionInnerStore(el).leaveToProps = {};\n      }\n\n      if (propName) {\n        leaveToProps[propName] = leaveToProps[propName] || {};\n      }\n\n      extend(propName ? leaveToProps[propName] : leaveToProps, prop.leaveTo);\n    }\n  }\n}\nexport function applyLeaveTransition(el, elOption, animatableModel, onRemove) {\n  if (el) {\n    var parent_1 = el.parent;\n    var leaveToProps = transitionInnerStore(el).leaveToProps;\n\n    if (leaveToProps) {\n      // TODO TODO use leave after leaveAnimation in series is introduced\n      // TODO Data index?\n      var config = getElementAnimationConfig('update', el, elOption, animatableModel, 0);\n\n      config.done = function () {\n        parent_1.remove(el);\n        onRemove && onRemove();\n      };\n\n      el.animateTo(leaveToProps, config);\n    } else {\n      parent_1.remove(el);\n      onRemove && onRemove();\n    }\n  }\n}\nexport function isTransitionAll(transition) {\n  return transition === 'all';\n}\n\nfunction applyPropsDirectly(el, // Can be null/undefined\nallPropsFinal, clearStyle) {\n  var styleOpt = allPropsFinal.style;\n\n  if (!el.isGroup && styleOpt) {\n    if (clearStyle) {\n      el.useStyle({}); // When style object changed, how to trade the existing animation?\n      // It is probably complicated and not needed to cover all the cases.\n      // But still need consider the case:\n      // (1) When using init animation on `style.opacity`, and before the animation\n      //     ended users triggers an update by mousewhel. At that time the init\n      //     animation should better be continued rather than terminated.\n      //     So after `useStyle` called, we should change the animation target manually\n      //     to continue the effect of the init animation.\n      // (2) PENDING: If the previous animation targeted at a `val1`, and currently we need\n      //     to update the value to `val2` and no animation declared, should be terminate\n      //     the previous animation or just modify the target of the animation?\n      //     Therotically That will happen not only on `style` but also on `shape` and\n      //     `transfrom` props. But we haven't handle this case at present yet.\n      // (3) PENDING: Is it proper to visit `animators` and `targetName`?\n\n      var animators = el.animators;\n\n      for (var i = 0; i < animators.length; i++) {\n        var animator = animators[i]; // targetName is the \"topKey\".\n\n        if (animator.targetName === 'style') {\n          animator.changeTarget(el.style);\n        }\n      }\n    }\n\n    el.setStyle(styleOpt);\n  }\n\n  if (allPropsFinal) {\n    // Not set style here.\n    allPropsFinal.style = null; // Set el to the final state firstly.\n\n    allPropsFinal && el.attr(allPropsFinal);\n    allPropsFinal.style = styleOpt;\n  }\n}\n\nfunction applyPropsTransition(el, elOption, dataIndex, model, // Can be null/undefined\ntransFromProps) {\n  if (transFromProps) {\n    var config = getElementAnimationConfig('update', el, elOption, model, dataIndex);\n\n    if (config.duration > 0) {\n      el.animateFrom(transFromProps, config);\n    }\n  }\n}\n\nfunction applyMiscProps(el, elOption) {\n  // Merge by default.\n  hasOwn(elOption, 'silent') && (el.silent = elOption.silent);\n  hasOwn(elOption, 'ignore') && (el.ignore = elOption.ignore);\n\n  if (el instanceof Displayable) {\n    hasOwn(elOption, 'invisible') && (el.invisible = elOption.invisible);\n  }\n\n  if (el instanceof Path) {\n    hasOwn(elOption, 'autoBatch') && (el.autoBatch = elOption.autoBatch);\n  }\n} // Use it to avoid it be exposed to user.\n\n\nvar tmpDuringScope = {};\nvar transitionDuringAPI = {\n  // Usually other props do not need to be changed in animation during.\n  setTransform: function setTransform(key, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(hasOwn(TRANSFORM_PROPS_MAP, key), 'Only ' + transformPropNamesStr + ' available in `setTransform`.');\n    }\n\n    tmpDuringScope.el[key] = val;\n    return this;\n  },\n  getTransform: function getTransform(key) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(hasOwn(TRANSFORM_PROPS_MAP, key), 'Only ' + transformPropNamesStr + ' available in `getTransform`.');\n    }\n\n    return tmpDuringScope.el[key];\n  },\n  setShape: function setShape(key, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n\n    var el = tmpDuringScope.el;\n    var shape = el.shape || (el.shape = {});\n    shape[key] = val;\n    el.dirtyShape && el.dirtyShape();\n    return this;\n  },\n  getShape: function getShape(key) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n\n    var shape = tmpDuringScope.el.shape;\n\n    if (shape) {\n      return shape[key];\n    }\n  },\n  setStyle: function setStyle(key, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n\n    var el = tmpDuringScope.el;\n    var style = el.style;\n\n    if (style) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (eqNaN(val)) {\n          warn('style.' + key + ' must not be assigned with NaN.');\n        }\n      }\n\n      style[key] = val;\n      el.dirtyStyle && el.dirtyStyle();\n    }\n\n    return this;\n  },\n  getStyle: function getStyle(key) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n\n    var style = tmpDuringScope.el.style;\n\n    if (style) {\n      return style[key];\n    }\n  },\n  setExtra: function setExtra(key, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n\n    var extra = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {});\n    extra[key] = val;\n    return this;\n  },\n  getExtra: function getExtra(key) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n\n    var extra = tmpDuringScope.el.extra;\n\n    if (extra) {\n      return extra[key];\n    }\n  }\n};\n\nfunction assertNotReserved(key) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (key === 'transition' || key === 'enterFrom' || key === 'leaveTo') {\n      throw new Error('key must not be \"' + key + '\"');\n    }\n  }\n}\n\nfunction duringCall() {\n  // Do not provide \"percent\" until some requirements come.\n  // Because consider thies case:\n  // enterFrom: {x: 100, y: 30}, transition: 'x'.\n  // And enter duration is different from update duration.\n  // Thus it might be confused about the meaning of \"percent\" in during callback.\n  var scope = this;\n  var el = scope.el;\n\n  if (!el) {\n    return;\n  } // If el is remove from zr by reason like legend, during still need to called,\n  // becuase el will be added back to zr and the prop value should not be incorrect.\n\n\n  var latestUserDuring = transitionInnerStore(el).userDuring;\n  var scopeUserDuring = scope.userDuring; // Ensured a during is only called once in each animation frame.\n  // If a during is called multiple times in one frame, maybe some users' calulation logic\n  // might be wrong (not sure whether this usage exists).\n  // The case of a during might be called twice can be: by default there is a animator for\n  // 'x', 'y' when init. Before the init animation finished, call `setOption` to start\n  // another animators for 'style'/'shape'/'extra'.\n\n  if (latestUserDuring !== scopeUserDuring) {\n    // release\n    scope.el = scope.userDuring = null;\n    return;\n  }\n\n  tmpDuringScope.el = el; // Give no `this` to user in \"during\" calling.\n\n  scopeUserDuring(transitionDuringAPI); // FIXME: if in future meet the case that some prop will be both modified in `during` and `state`,\n  // consider the issue that the prop might be incorrect when return to \"normal\" state.\n}\n\nfunction prepareShapeOrExtraTransitionFrom(mainAttr, fromEl, elOption, transFromProps) {\n  var attrOpt = elOption[mainAttr];\n\n  if (!attrOpt) {\n    return;\n  }\n\n  var elPropsInAttr = fromEl[mainAttr];\n  var transFromPropsInAttr;\n\n  if (elPropsInAttr) {\n    var transition = elOption.transition;\n    var attrTransition = attrOpt.transition;\n\n    if (attrTransition) {\n      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});\n\n      if (isTransitionAll(attrTransition)) {\n        extend(transFromPropsInAttr, elPropsInAttr);\n      } else {\n        var transitionKeys = normalizeToArray(attrTransition);\n\n        for (var i = 0; i < transitionKeys.length; i++) {\n          var key = transitionKeys[i];\n          var elVal = elPropsInAttr[key];\n          transFromPropsInAttr[key] = elVal;\n        }\n      }\n    } else if (isTransitionAll(transition) || indexOf(transition, mainAttr) >= 0) {\n      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});\n      var elPropsInAttrKeys = keys(elPropsInAttr);\n\n      for (var i = 0; i < elPropsInAttrKeys.length; i++) {\n        var key = elPropsInAttrKeys[i];\n        var elVal = elPropsInAttr[key];\n\n        if (isNonStyleTransitionEnabled(attrOpt[key], elVal)) {\n          transFromPropsInAttr[key] = elVal;\n        }\n      }\n    }\n  }\n}\n\nfunction prepareShapeOrExtraAllPropsFinal(mainAttr, elOption, allProps) {\n  var attrOpt = elOption[mainAttr];\n\n  if (!attrOpt) {\n    return;\n  }\n\n  var allPropsInAttr = allProps[mainAttr] = {};\n  var keysInAttr = keys(attrOpt);\n\n  for (var i = 0; i < keysInAttr.length; i++) {\n    var key = keysInAttr[i]; // To avoid share one object with different element, and\n    // to avoid user modify the object inexpectedly, have to clone.\n\n    allPropsInAttr[key] = cloneValue(attrOpt[key]);\n  }\n}\n\nfunction prepareTransformTransitionFrom(el, elOption, transFromProps) {\n  var transition = elOption.transition;\n  var transitionKeys = isTransitionAll(transition) ? TRANSFORMABLE_PROPS : normalizeToArray(transition || []);\n\n  for (var i = 0; i < transitionKeys.length; i++) {\n    var key = transitionKeys[i];\n\n    if (key === 'style' || key === 'shape' || key === 'extra') {\n      continue;\n    }\n\n    var elVal = el[key];\n\n    if (process.env.NODE_ENV !== 'production') {\n      checkTransformPropRefer(key, 'el.transition');\n    } // Do not clone, animator will perform that clone.\n\n\n    transFromProps[key] = elVal;\n  }\n}\n\nfunction prepareTransformAllPropsFinal(el, elOption, allProps) {\n  for (var i = 0; i < LEGACY_TRANSFORM_PROPS.length; i++) {\n    var legacyName = LEGACY_TRANSFORM_PROPS[i];\n    var xyName = LEGACY_TRANSFORM_PROPS_MAP[legacyName];\n    var legacyArr = elOption[legacyName];\n\n    if (legacyArr) {\n      allProps[xyName[0]] = legacyArr[0];\n      allProps[xyName[1]] = legacyArr[1];\n    }\n  }\n\n  for (var i = 0; i < TRANSFORMABLE_PROPS.length; i++) {\n    var key = TRANSFORMABLE_PROPS[i];\n\n    if (elOption[key] != null) {\n      allProps[key] = elOption[key];\n    }\n  }\n}\n\nfunction prepareStyleTransitionFrom(fromEl, elOption, styleOpt, transFromProps) {\n  if (!styleOpt) {\n    return;\n  }\n\n  var fromElStyle = fromEl.style;\n  var transFromStyleProps;\n\n  if (fromElStyle) {\n    var styleTransition = styleOpt.transition;\n    var elTransition = elOption.transition;\n\n    if (styleTransition && !isTransitionAll(styleTransition)) {\n      var transitionKeys = normalizeToArray(styleTransition);\n      !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});\n\n      for (var i = 0; i < transitionKeys.length; i++) {\n        var key = transitionKeys[i];\n        var elVal = fromElStyle[key]; // Do not clone, see `checkNonStyleTansitionRefer`.\n\n        transFromStyleProps[key] = elVal;\n      }\n    } else if (fromEl.getAnimationStyleProps && (isTransitionAll(elTransition) || isTransitionAll(styleTransition) || indexOf(elTransition, 'style') >= 0)) {\n      var animationProps = fromEl.getAnimationStyleProps();\n      var animationStyleProps = animationProps ? animationProps.style : null;\n\n      if (animationStyleProps) {\n        !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});\n        var styleKeys = keys(styleOpt);\n\n        for (var i = 0; i < styleKeys.length; i++) {\n          var key = styleKeys[i];\n\n          if (animationStyleProps[key]) {\n            var elVal = fromElStyle[key];\n            transFromStyleProps[key] = elVal;\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction isNonStyleTransitionEnabled(optVal, elVal) {\n  // The same as `checkNonStyleTansitionRefer`.\n  return !isArrayLike(optVal) ? optVal != null && isFinite(optVal) : optVal !== elVal;\n}\n\nvar checkTransformPropRefer;\n\nif (process.env.NODE_ENV !== 'production') {\n  checkTransformPropRefer = function checkTransformPropRefer(key, usedIn) {\n    if (!hasOwn(TRANSFORM_PROPS_MAP, key)) {\n      warn('Prop `' + key + '` is not a permitted in `' + usedIn + '`. ' + 'Only `' + keys(TRANSFORM_PROPS_MAP).join('`, `') + '` are permitted.');\n    }\n  };\n}","map":{"version":3,"sources":["D:/Work/WorkSpace/GitWorkSpace/TenShop/resource/ElectronicMall/src/qingge-Market/qingge-vue/node_modules/echarts/lib/animation/customGraphicTransition.js"],"names":["makeInner","normalizeToArray","assert","bind","each","eqNaN","extend","hasOwn","indexOf","isArrayLike","keys","reduce","cloneValue","Displayable","getAnimationConfig","Path","warn","TRANSFORMABLE_PROPS","LEGACY_TRANSFORM_PROPS_MAP","position","scale","origin","LEGACY_TRANSFORM_PROPS","TRANSFORM_PROPS_MAP","obj","key","transformPropNamesStr","join","ELEMENT_ANIMATABLE_PROPS","transitionInnerStore","getElementAnimationConfig","animationType","el","elOption","parentModel","dataIndex","animationProp","config","userDuring","duration","during","duringCall","setToFinal","scope","applyUpdateTransition","animatableModel","opts","isInit","clearStyle","hasAnimation","isAnimationEnabled","store","styleOpt","style","transFromProps","propsToSet","prepareTransformAllPropsFinal","prepareShapeOrExtraAllPropsFinal","prepareTransformTransitionFrom","prepareShapeOrExtraTransitionFrom","prepareStyleTransitionFrom","applyPropsDirectly","applyMiscProps","enterFromProps_1","propName","prop","enterFrom","animateFrom","applyPropsTransition","updateLeaveTo","dirty","markRedraw","leaveToProps","i","length","leaveTo","applyLeaveTransition","onRemove","parent_1","parent","done","remove","animateTo","isTransitionAll","transition","allPropsFinal","isGroup","useStyle","animators","animator","targetName","changeTarget","setStyle","attr","model","silent","ignore","invisible","autoBatch","tmpDuringScope","transitionDuringAPI","setTransform","val","process","env","NODE_ENV","getTransform","setShape","assertNotReserved","shape","dirtyShape","getShape","dirtyStyle","getStyle","setExtra","extra","getExtra","Error","latestUserDuring","scopeUserDuring","mainAttr","fromEl","attrOpt","elPropsInAttr","transFromPropsInAttr","attrTransition","transitionKeys","elVal","elPropsInAttrKeys","isNonStyleTransitionEnabled","allProps","allPropsInAttr","keysInAttr","checkTransformPropRefer","legacyName","xyName","legacyArr","fromElStyle","transFromStyleProps","styleTransition","elTransition","getAnimationStyleProps","animationProps","animationStyleProps","styleKeys","optVal","isFinite","usedIn"],"mappings":"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","sourcesContent":["\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n\r\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\nimport { makeInner, normalizeToArray } from '../util/model.js';\r\nimport { assert, bind, each, eqNaN, extend, hasOwn, indexOf, isArrayLike, keys, reduce } from 'zrender/lib/core/util.js';\r\nimport { cloneValue } from 'zrender/lib/animation/Animator.js';\r\nimport Displayable from 'zrender/lib/graphic/Displayable.js';\r\nimport { getAnimationConfig } from './basicTrasition.js';\r\nimport { Path } from '../util/graphic.js';\r\nimport { warn } from '../util/log.js';\r\nimport { TRANSFORMABLE_PROPS } from 'zrender/lib/core/Transformable.js';\r\nvar LEGACY_TRANSFORM_PROPS_MAP = {\r\n  position: ['x', 'y'],\r\n  scale: ['scaleX', 'scaleY'],\r\n  origin: ['originX', 'originY']\r\n};\r\nvar LEGACY_TRANSFORM_PROPS = keys(LEGACY_TRANSFORM_PROPS_MAP);\r\nvar TRANSFORM_PROPS_MAP = reduce(TRANSFORMABLE_PROPS, function (obj, key) {\r\n  obj[key] = 1;\r\n  return obj;\r\n}, {});\r\nvar transformPropNamesStr = TRANSFORMABLE_PROPS.join(', '); // '' means root\r\n\r\nexport var ELEMENT_ANIMATABLE_PROPS = ['', 'style', 'shape', 'extra'];\r\n;\r\nvar transitionInnerStore = makeInner();\r\n;\r\n\r\nfunction getElementAnimationConfig(animationType, el, elOption, parentModel, dataIndex) {\r\n  var animationProp = animationType + \"Animation\";\r\n  var config = getAnimationConfig(animationType, parentModel, dataIndex) || {};\r\n  var userDuring = transitionInnerStore(el).userDuring; // Only set when duration is > 0 and it's need to be animated.\r\n\r\n  if (config.duration > 0) {\r\n    // For simplicity, if during not specified, the previous during will not work any more.\r\n    config.during = userDuring ? bind(duringCall, {\r\n      el: el,\r\n      userDuring: userDuring\r\n    }) : null;\r\n    config.setToFinal = true;\r\n    config.scope = animationType;\r\n  }\r\n\r\n  extend(config, elOption[animationProp]);\r\n  return config;\r\n}\r\n\r\nexport function applyUpdateTransition(el, elOption, animatableModel, opts) {\r\n  opts = opts || {};\r\n  var dataIndex = opts.dataIndex,\r\n      isInit = opts.isInit,\r\n      clearStyle = opts.clearStyle;\r\n  var hasAnimation = animatableModel.isAnimationEnabled(); // Save the meta info for further morphing. Like apply on the sub morphing elements.\r\n\r\n  var store = transitionInnerStore(el);\r\n  var styleOpt = elOption.style;\r\n  store.userDuring = elOption.during;\r\n  var transFromProps = {};\r\n  var propsToSet = {};\r\n  prepareTransformAllPropsFinal(el, elOption, propsToSet);\r\n  prepareShapeOrExtraAllPropsFinal('shape', elOption, propsToSet);\r\n  prepareShapeOrExtraAllPropsFinal('extra', elOption, propsToSet);\r\n\r\n  if (!isInit && hasAnimation) {\r\n    prepareTransformTransitionFrom(el, elOption, transFromProps);\r\n    prepareShapeOrExtraTransitionFrom('shape', el, elOption, transFromProps);\r\n    prepareShapeOrExtraTransitionFrom('extra', el, elOption, transFromProps);\r\n    prepareStyleTransitionFrom(el, elOption, styleOpt, transFromProps);\r\n  }\r\n\r\n  propsToSet.style = styleOpt;\r\n  applyPropsDirectly(el, propsToSet, clearStyle);\r\n  applyMiscProps(el, elOption);\r\n\r\n  if (hasAnimation) {\r\n    if (isInit) {\r\n      var enterFromProps_1 = {};\r\n      each(ELEMENT_ANIMATABLE_PROPS, function (propName) {\r\n        var prop = propName ? elOption[propName] : elOption;\r\n\r\n        if (prop && prop.enterFrom) {\r\n          if (propName) {\r\n            enterFromProps_1[propName] = enterFromProps_1[propName] || {};\r\n          }\r\n\r\n          extend(propName ? enterFromProps_1[propName] : enterFromProps_1, prop.enterFrom);\r\n        }\r\n      });\r\n      var config = getElementAnimationConfig('enter', el, elOption, animatableModel, dataIndex);\r\n\r\n      if (config.duration > 0) {\r\n        el.animateFrom(enterFromProps_1, config);\r\n      }\r\n    } else {\r\n      applyPropsTransition(el, elOption, dataIndex || 0, animatableModel, transFromProps);\r\n    }\r\n  } // Store leave to be used in leave transition.\r\n\r\n\r\n  updateLeaveTo(el, elOption);\r\n  styleOpt ? el.dirty() : el.markRedraw();\r\n}\r\nexport function updateLeaveTo(el, elOption) {\r\n  // Try merge to previous set leaveTo\r\n  var leaveToProps = transitionInnerStore(el).leaveToProps;\r\n\r\n  for (var i = 0; i < ELEMENT_ANIMATABLE_PROPS.length; i++) {\r\n    var propName = ELEMENT_ANIMATABLE_PROPS[i];\r\n    var prop = propName ? elOption[propName] : elOption;\r\n\r\n    if (prop && prop.leaveTo) {\r\n      if (!leaveToProps) {\r\n        leaveToProps = transitionInnerStore(el).leaveToProps = {};\r\n      }\r\n\r\n      if (propName) {\r\n        leaveToProps[propName] = leaveToProps[propName] || {};\r\n      }\r\n\r\n      extend(propName ? leaveToProps[propName] : leaveToProps, prop.leaveTo);\r\n    }\r\n  }\r\n}\r\nexport function applyLeaveTransition(el, elOption, animatableModel, onRemove) {\r\n  if (el) {\r\n    var parent_1 = el.parent;\r\n    var leaveToProps = transitionInnerStore(el).leaveToProps;\r\n\r\n    if (leaveToProps) {\r\n      // TODO TODO use leave after leaveAnimation in series is introduced\r\n      // TODO Data index?\r\n      var config = getElementAnimationConfig('update', el, elOption, animatableModel, 0);\r\n\r\n      config.done = function () {\r\n        parent_1.remove(el);\r\n        onRemove && onRemove();\r\n      };\r\n\r\n      el.animateTo(leaveToProps, config);\r\n    } else {\r\n      parent_1.remove(el);\r\n      onRemove && onRemove();\r\n    }\r\n  }\r\n}\r\nexport function isTransitionAll(transition) {\r\n  return transition === 'all';\r\n}\r\n\r\nfunction applyPropsDirectly(el, // Can be null/undefined\r\nallPropsFinal, clearStyle) {\r\n  var styleOpt = allPropsFinal.style;\r\n\r\n  if (!el.isGroup && styleOpt) {\r\n    if (clearStyle) {\r\n      el.useStyle({}); // When style object changed, how to trade the existing animation?\r\n      // It is probably complicated and not needed to cover all the cases.\r\n      // But still need consider the case:\r\n      // (1) When using init animation on `style.opacity`, and before the animation\r\n      //     ended users triggers an update by mousewhel. At that time the init\r\n      //     animation should better be continued rather than terminated.\r\n      //     So after `useStyle` called, we should change the animation target manually\r\n      //     to continue the effect of the init animation.\r\n      // (2) PENDING: If the previous animation targeted at a `val1`, and currently we need\r\n      //     to update the value to `val2` and no animation declared, should be terminate\r\n      //     the previous animation or just modify the target of the animation?\r\n      //     Therotically That will happen not only on `style` but also on `shape` and\r\n      //     `transfrom` props. But we haven't handle this case at present yet.\r\n      // (3) PENDING: Is it proper to visit `animators` and `targetName`?\r\n\r\n      var animators = el.animators;\r\n\r\n      for (var i = 0; i < animators.length; i++) {\r\n        var animator = animators[i]; // targetName is the \"topKey\".\r\n\r\n        if (animator.targetName === 'style') {\r\n          animator.changeTarget(el.style);\r\n        }\r\n      }\r\n    }\r\n\r\n    el.setStyle(styleOpt);\r\n  }\r\n\r\n  if (allPropsFinal) {\r\n    // Not set style here.\r\n    allPropsFinal.style = null; // Set el to the final state firstly.\r\n\r\n    allPropsFinal && el.attr(allPropsFinal);\r\n    allPropsFinal.style = styleOpt;\r\n  }\r\n}\r\n\r\nfunction applyPropsTransition(el, elOption, dataIndex, model, // Can be null/undefined\r\ntransFromProps) {\r\n  if (transFromProps) {\r\n    var config = getElementAnimationConfig('update', el, elOption, model, dataIndex);\r\n\r\n    if (config.duration > 0) {\r\n      el.animateFrom(transFromProps, config);\r\n    }\r\n  }\r\n}\r\n\r\nfunction applyMiscProps(el, elOption) {\r\n  // Merge by default.\r\n  hasOwn(elOption, 'silent') && (el.silent = elOption.silent);\r\n  hasOwn(elOption, 'ignore') && (el.ignore = elOption.ignore);\r\n\r\n  if (el instanceof Displayable) {\r\n    hasOwn(elOption, 'invisible') && (el.invisible = elOption.invisible);\r\n  }\r\n\r\n  if (el instanceof Path) {\r\n    hasOwn(elOption, 'autoBatch') && (el.autoBatch = elOption.autoBatch);\r\n  }\r\n} // Use it to avoid it be exposed to user.\r\n\r\n\r\nvar tmpDuringScope = {};\r\nvar transitionDuringAPI = {\r\n  // Usually other props do not need to be changed in animation during.\r\n  setTransform: function (key, val) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assert(hasOwn(TRANSFORM_PROPS_MAP, key), 'Only ' + transformPropNamesStr + ' available in `setTransform`.');\r\n    }\r\n\r\n    tmpDuringScope.el[key] = val;\r\n    return this;\r\n  },\r\n  getTransform: function (key) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assert(hasOwn(TRANSFORM_PROPS_MAP, key), 'Only ' + transformPropNamesStr + ' available in `getTransform`.');\r\n    }\r\n\r\n    return tmpDuringScope.el[key];\r\n  },\r\n  setShape: function (key, val) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assertNotReserved(key);\r\n    }\r\n\r\n    var el = tmpDuringScope.el;\r\n    var shape = el.shape || (el.shape = {});\r\n    shape[key] = val;\r\n    el.dirtyShape && el.dirtyShape();\r\n    return this;\r\n  },\r\n  getShape: function (key) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assertNotReserved(key);\r\n    }\r\n\r\n    var shape = tmpDuringScope.el.shape;\r\n\r\n    if (shape) {\r\n      return shape[key];\r\n    }\r\n  },\r\n  setStyle: function (key, val) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assertNotReserved(key);\r\n    }\r\n\r\n    var el = tmpDuringScope.el;\r\n    var style = el.style;\r\n\r\n    if (style) {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        if (eqNaN(val)) {\r\n          warn('style.' + key + ' must not be assigned with NaN.');\r\n        }\r\n      }\r\n\r\n      style[key] = val;\r\n      el.dirtyStyle && el.dirtyStyle();\r\n    }\r\n\r\n    return this;\r\n  },\r\n  getStyle: function (key) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assertNotReserved(key);\r\n    }\r\n\r\n    var style = tmpDuringScope.el.style;\r\n\r\n    if (style) {\r\n      return style[key];\r\n    }\r\n  },\r\n  setExtra: function (key, val) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assertNotReserved(key);\r\n    }\r\n\r\n    var extra = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {});\r\n    extra[key] = val;\r\n    return this;\r\n  },\r\n  getExtra: function (key) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assertNotReserved(key);\r\n    }\r\n\r\n    var extra = tmpDuringScope.el.extra;\r\n\r\n    if (extra) {\r\n      return extra[key];\r\n    }\r\n  }\r\n};\r\n\r\nfunction assertNotReserved(key) {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (key === 'transition' || key === 'enterFrom' || key === 'leaveTo') {\r\n      throw new Error('key must not be \"' + key + '\"');\r\n    }\r\n  }\r\n}\r\n\r\nfunction duringCall() {\r\n  // Do not provide \"percent\" until some requirements come.\r\n  // Because consider thies case:\r\n  // enterFrom: {x: 100, y: 30}, transition: 'x'.\r\n  // And enter duration is different from update duration.\r\n  // Thus it might be confused about the meaning of \"percent\" in during callback.\r\n  var scope = this;\r\n  var el = scope.el;\r\n\r\n  if (!el) {\r\n    return;\r\n  } // If el is remove from zr by reason like legend, during still need to called,\r\n  // becuase el will be added back to zr and the prop value should not be incorrect.\r\n\r\n\r\n  var latestUserDuring = transitionInnerStore(el).userDuring;\r\n  var scopeUserDuring = scope.userDuring; // Ensured a during is only called once in each animation frame.\r\n  // If a during is called multiple times in one frame, maybe some users' calulation logic\r\n  // might be wrong (not sure whether this usage exists).\r\n  // The case of a during might be called twice can be: by default there is a animator for\r\n  // 'x', 'y' when init. Before the init animation finished, call `setOption` to start\r\n  // another animators for 'style'/'shape'/'extra'.\r\n\r\n  if (latestUserDuring !== scopeUserDuring) {\r\n    // release\r\n    scope.el = scope.userDuring = null;\r\n    return;\r\n  }\r\n\r\n  tmpDuringScope.el = el; // Give no `this` to user in \"during\" calling.\r\n\r\n  scopeUserDuring(transitionDuringAPI); // FIXME: if in future meet the case that some prop will be both modified in `during` and `state`,\r\n  // consider the issue that the prop might be incorrect when return to \"normal\" state.\r\n}\r\n\r\nfunction prepareShapeOrExtraTransitionFrom(mainAttr, fromEl, elOption, transFromProps) {\r\n  var attrOpt = elOption[mainAttr];\r\n\r\n  if (!attrOpt) {\r\n    return;\r\n  }\r\n\r\n  var elPropsInAttr = fromEl[mainAttr];\r\n  var transFromPropsInAttr;\r\n\r\n  if (elPropsInAttr) {\r\n    var transition = elOption.transition;\r\n    var attrTransition = attrOpt.transition;\r\n\r\n    if (attrTransition) {\r\n      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});\r\n\r\n      if (isTransitionAll(attrTransition)) {\r\n        extend(transFromPropsInAttr, elPropsInAttr);\r\n      } else {\r\n        var transitionKeys = normalizeToArray(attrTransition);\r\n\r\n        for (var i = 0; i < transitionKeys.length; i++) {\r\n          var key = transitionKeys[i];\r\n          var elVal = elPropsInAttr[key];\r\n          transFromPropsInAttr[key] = elVal;\r\n        }\r\n      }\r\n    } else if (isTransitionAll(transition) || indexOf(transition, mainAttr) >= 0) {\r\n      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});\r\n      var elPropsInAttrKeys = keys(elPropsInAttr);\r\n\r\n      for (var i = 0; i < elPropsInAttrKeys.length; i++) {\r\n        var key = elPropsInAttrKeys[i];\r\n        var elVal = elPropsInAttr[key];\r\n\r\n        if (isNonStyleTransitionEnabled(attrOpt[key], elVal)) {\r\n          transFromPropsInAttr[key] = elVal;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction prepareShapeOrExtraAllPropsFinal(mainAttr, elOption, allProps) {\r\n  var attrOpt = elOption[mainAttr];\r\n\r\n  if (!attrOpt) {\r\n    return;\r\n  }\r\n\r\n  var allPropsInAttr = allProps[mainAttr] = {};\r\n  var keysInAttr = keys(attrOpt);\r\n\r\n  for (var i = 0; i < keysInAttr.length; i++) {\r\n    var key = keysInAttr[i]; // To avoid share one object with different element, and\r\n    // to avoid user modify the object inexpectedly, have to clone.\r\n\r\n    allPropsInAttr[key] = cloneValue(attrOpt[key]);\r\n  }\r\n}\r\n\r\nfunction prepareTransformTransitionFrom(el, elOption, transFromProps) {\r\n  var transition = elOption.transition;\r\n  var transitionKeys = isTransitionAll(transition) ? TRANSFORMABLE_PROPS : normalizeToArray(transition || []);\r\n\r\n  for (var i = 0; i < transitionKeys.length; i++) {\r\n    var key = transitionKeys[i];\r\n\r\n    if (key === 'style' || key === 'shape' || key === 'extra') {\r\n      continue;\r\n    }\r\n\r\n    var elVal = el[key];\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      checkTransformPropRefer(key, 'el.transition');\r\n    } // Do not clone, animator will perform that clone.\r\n\r\n\r\n    transFromProps[key] = elVal;\r\n  }\r\n}\r\n\r\nfunction prepareTransformAllPropsFinal(el, elOption, allProps) {\r\n  for (var i = 0; i < LEGACY_TRANSFORM_PROPS.length; i++) {\r\n    var legacyName = LEGACY_TRANSFORM_PROPS[i];\r\n    var xyName = LEGACY_TRANSFORM_PROPS_MAP[legacyName];\r\n    var legacyArr = elOption[legacyName];\r\n\r\n    if (legacyArr) {\r\n      allProps[xyName[0]] = legacyArr[0];\r\n      allProps[xyName[1]] = legacyArr[1];\r\n    }\r\n  }\r\n\r\n  for (var i = 0; i < TRANSFORMABLE_PROPS.length; i++) {\r\n    var key = TRANSFORMABLE_PROPS[i];\r\n\r\n    if (elOption[key] != null) {\r\n      allProps[key] = elOption[key];\r\n    }\r\n  }\r\n}\r\n\r\nfunction prepareStyleTransitionFrom(fromEl, elOption, styleOpt, transFromProps) {\r\n  if (!styleOpt) {\r\n    return;\r\n  }\r\n\r\n  var fromElStyle = fromEl.style;\r\n  var transFromStyleProps;\r\n\r\n  if (fromElStyle) {\r\n    var styleTransition = styleOpt.transition;\r\n    var elTransition = elOption.transition;\r\n\r\n    if (styleTransition && !isTransitionAll(styleTransition)) {\r\n      var transitionKeys = normalizeToArray(styleTransition);\r\n      !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});\r\n\r\n      for (var i = 0; i < transitionKeys.length; i++) {\r\n        var key = transitionKeys[i];\r\n        var elVal = fromElStyle[key]; // Do not clone, see `checkNonStyleTansitionRefer`.\r\n\r\n        transFromStyleProps[key] = elVal;\r\n      }\r\n    } else if (fromEl.getAnimationStyleProps && (isTransitionAll(elTransition) || isTransitionAll(styleTransition) || indexOf(elTransition, 'style') >= 0)) {\r\n      var animationProps = fromEl.getAnimationStyleProps();\r\n      var animationStyleProps = animationProps ? animationProps.style : null;\r\n\r\n      if (animationStyleProps) {\r\n        !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});\r\n        var styleKeys = keys(styleOpt);\r\n\r\n        for (var i = 0; i < styleKeys.length; i++) {\r\n          var key = styleKeys[i];\r\n\r\n          if (animationStyleProps[key]) {\r\n            var elVal = fromElStyle[key];\r\n            transFromStyleProps[key] = elVal;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction isNonStyleTransitionEnabled(optVal, elVal) {\r\n  // The same as `checkNonStyleTansitionRefer`.\r\n  return !isArrayLike(optVal) ? optVal != null && isFinite(optVal) : optVal !== elVal;\r\n}\r\n\r\nvar checkTransformPropRefer;\r\n\r\nif (process.env.NODE_ENV !== 'production') {\r\n  checkTransformPropRefer = function (key, usedIn) {\r\n    if (!hasOwn(TRANSFORM_PROPS_MAP, key)) {\r\n      warn('Prop `' + key + '` is not a permitted in `' + usedIn + '`. ' + 'Only `' + keys(TRANSFORM_PROPS_MAP).join('`, `') + '` are permitted.');\r\n    }\r\n  };\r\n}"]},"metadata":{},"sourceType":"module"}