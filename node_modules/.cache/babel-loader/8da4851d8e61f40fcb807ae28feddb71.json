{"ast":null,"code":"import \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport * as pathTool from 'zrender/lib/tool/path.js';\nimport * as matrix from 'zrender/lib/core/matrix.js';\nimport * as vector from 'zrender/lib/core/vector.js';\nimport Path from 'zrender/lib/graphic/Path.js';\nimport Transformable from 'zrender/lib/core/Transformable.js';\nimport ZRImage from 'zrender/lib/graphic/Image.js';\nimport Group from 'zrender/lib/graphic/Group.js';\nimport ZRText from 'zrender/lib/graphic/Text.js';\nimport Circle from 'zrender/lib/graphic/shape/Circle.js';\nimport Ellipse from 'zrender/lib/graphic/shape/Ellipse.js';\nimport Sector from 'zrender/lib/graphic/shape/Sector.js';\nimport Ring from 'zrender/lib/graphic/shape/Ring.js';\nimport Polygon from 'zrender/lib/graphic/shape/Polygon.js';\nimport Polyline from 'zrender/lib/graphic/shape/Polyline.js';\nimport Rect from 'zrender/lib/graphic/shape/Rect.js';\nimport Line from 'zrender/lib/graphic/shape/Line.js';\nimport BezierCurve from 'zrender/lib/graphic/shape/BezierCurve.js';\nimport Arc from 'zrender/lib/graphic/shape/Arc.js';\nimport CompoundPath from 'zrender/lib/graphic/CompoundPath.js';\nimport LinearGradient from 'zrender/lib/graphic/LinearGradient.js';\nimport RadialGradient from 'zrender/lib/graphic/RadialGradient.js';\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport OrientedBoundingRect from 'zrender/lib/core/OrientedBoundingRect.js';\nimport Point from 'zrender/lib/core/Point.js';\nimport IncrementalDisplayable from 'zrender/lib/graphic/IncrementalDisplayable.js';\nimport * as subPixelOptimizeUtil from 'zrender/lib/graphic/helper/subPixelOptimize.js';\nimport { extend, isArrayLike, map, defaults, isString, keys, each, hasOwn, isArray } from 'zrender/lib/core/util.js';\nimport { getECData } from './innerStore.js';\nimport { updateProps, initProps, removeElement, removeElementWithFadeOut, isElementRemoved } from '../animation/basicTrasition.js';\n/**\r\n * @deprecated export for compatitable reason\r\n */\n\nexport { updateProps, initProps, removeElement, removeElementWithFadeOut, isElementRemoved };\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nvar _customShapeMap = {};\n/**\r\n * Extend shape with parameters\r\n */\n\nexport function extendShape(opts) {\n  return Path.extend(opts);\n}\nvar extendPathFromString = pathTool.extendFromString;\n/**\r\n * Extend path\r\n */\n\nexport function extendPath(pathData, opts) {\n  return extendPathFromString(pathData, opts);\n}\n/**\r\n * Register a user defined shape.\r\n * The shape class can be fetched by `getShapeClass`\r\n * This method will overwrite the registered shapes, including\r\n * the registered built-in shapes, if using the same `name`.\r\n * The shape can be used in `custom series` and\r\n * `graphic component` by declaring `{type: name}`.\r\n *\r\n * @param name\r\n * @param ShapeClass Can be generated by `extendShape`.\r\n */\n\nexport function registerShape(name, ShapeClass) {\n  _customShapeMap[name] = ShapeClass;\n}\n/**\r\n * Find shape class registered by `registerShape`. Usually used in\r\n * fetching user defined shape.\r\n *\r\n * [Caution]:\r\n * (1) This method **MUST NOT be used inside echarts !!!**, unless it is prepared\r\n * to use user registered shapes.\r\n * Because the built-in shape (see `getBuiltInShape`) will be registered by\r\n * `registerShape` by default. That enables users to get both built-in\r\n * shapes as well as the shapes belonging to themsleves. But users can overwrite\r\n * the built-in shapes by using names like 'circle', 'rect' via calling\r\n * `registerShape`. So the echarts inner featrues should not fetch shapes from here\r\n * in case that it is overwritten by users, except that some features, like\r\n * `custom series`, `graphic component`, do it deliberately.\r\n *\r\n * (2) In the features like `custom series`, `graphic component`, the user input\r\n * `{tpye: 'xxx'}` does not only specify shapes but also specify other graphic\r\n * elements like `'group'`, `'text'`, `'image'` or event `'path'`. Those names\r\n * are reserved names, that is, if some user register a shape named `'image'`,\r\n * the shape will not be used. If we intending to add some more reserved names\r\n * in feature, that might bring break changes (disable some existing user shape\r\n * names). But that case probably rearly happen. So we dont make more mechanism\r\n * to resolve this issue here.\r\n *\r\n * @param name\r\n * @return The shape class. If not found, return nothing.\r\n */\n\nexport function getShapeClass(name) {\n  if (_customShapeMap.hasOwnProperty(name)) {\n    return _customShapeMap[name];\n  }\n}\n/**\r\n * Create a path element from path data string\r\n * @param pathData\r\n * @param opts\r\n * @param rect\r\n * @param layout 'center' or 'cover' default to be cover\r\n */\n\nexport function makePath(pathData, opts, rect, layout) {\n  var path = pathTool.createFromString(pathData, opts);\n\n  if (rect) {\n    if (layout === 'center') {\n      rect = centerGraphic(rect, path.getBoundingRect());\n    }\n\n    resizePath(path, rect);\n  }\n\n  return path;\n}\n/**\r\n * Create a image element from image url\r\n * @param imageUrl image url\r\n * @param opts options\r\n * @param rect constrain rect\r\n * @param layout 'center' or 'cover'. Default to be 'cover'\r\n */\n\nexport function makeImage(imageUrl, rect, layout) {\n  var zrImg = new ZRImage({\n    style: {\n      image: imageUrl,\n      x: rect.x,\n      y: rect.y,\n      width: rect.width,\n      height: rect.height\n    },\n    onload: function onload(img) {\n      if (layout === 'center') {\n        var boundingRect = {\n          width: img.width,\n          height: img.height\n        };\n        zrImg.setStyle(centerGraphic(rect, boundingRect));\n      }\n    }\n  });\n  return zrImg;\n}\n/**\r\n * Get position of centered element in bounding box.\r\n *\r\n * @param  rect         element local bounding box\r\n * @param  boundingRect constraint bounding box\r\n * @return element position containing x, y, width, and height\r\n */\n\nfunction centerGraphic(rect, boundingRect) {\n  // Set rect to center, keep width / height ratio.\n  var aspect = boundingRect.width / boundingRect.height;\n  var width = rect.height * aspect;\n  var height;\n\n  if (width <= rect.width) {\n    height = rect.height;\n  } else {\n    width = rect.width;\n    height = width / aspect;\n  }\n\n  var cx = rect.x + rect.width / 2;\n  var cy = rect.y + rect.height / 2;\n  return {\n    x: cx - width / 2,\n    y: cy - height / 2,\n    width: width,\n    height: height\n  };\n}\n\nexport var mergePath = pathTool.mergePath;\n/**\r\n * Resize a path to fit the rect\r\n * @param path\r\n * @param rect\r\n */\n\nexport function resizePath(path, rect) {\n  if (!path.applyTransform) {\n    return;\n  }\n\n  var pathRect = path.getBoundingRect();\n  var m = pathRect.calculateTransform(rect);\n  path.applyTransform(m);\n}\n/**\r\n * Sub pixel optimize line for canvas\r\n */\n\nexport function subPixelOptimizeLine(param) {\n  subPixelOptimizeUtil.subPixelOptimizeLine(param.shape, param.shape, param.style);\n  return param;\n}\n/**\r\n * Sub pixel optimize rect for canvas\r\n */\n\nexport function subPixelOptimizeRect(param) {\n  subPixelOptimizeUtil.subPixelOptimizeRect(param.shape, param.shape, param.style);\n  return param;\n}\n/**\r\n * Sub pixel optimize for canvas\r\n *\r\n * @param position Coordinate, such as x, y\r\n * @param lineWidth Should be nonnegative integer.\r\n * @param positiveOrNegative Default false (negative).\r\n * @return Optimized position.\r\n */\n\nexport var subPixelOptimize = subPixelOptimizeUtil.subPixelOptimize;\n/**\r\n * Get transform matrix of target (param target),\r\n * in coordinate of its ancestor (param ancestor)\r\n *\r\n * @param target\r\n * @param [ancestor]\r\n */\n\nexport function getTransform(target, ancestor) {\n  var mat = matrix.identity([]);\n\n  while (target && target !== ancestor) {\n    matrix.mul(mat, target.getLocalTransform(), mat);\n    target = target.parent;\n  }\n\n  return mat;\n}\n/**\r\n * Apply transform to an vertex.\r\n * @param target [x, y]\r\n * @param transform Can be:\r\n *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n *      + {position, rotation, scale}, the same as `zrender/Transformable`.\r\n * @param invert Whether use invert matrix.\r\n * @return [x, y]\r\n */\n\nexport function applyTransform(target, transform, invert) {\n  if (transform && !isArrayLike(transform)) {\n    transform = Transformable.getLocalTransform(transform);\n  }\n\n  if (invert) {\n    transform = matrix.invert([], transform);\n  }\n\n  return vector.applyTransform([], target, transform);\n}\n/**\r\n * @param direction 'left' 'right' 'top' 'bottom'\r\n * @param transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n * @param invert Whether use invert matrix.\r\n * @return Transformed direction. 'left' 'right' 'top' 'bottom'\r\n */\n\nexport function transformDirection(direction, transform, invert) {\n  // Pick a base, ensure that transform result will not be (0, 0).\n  var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);\n  var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);\n  var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];\n  vertex = applyTransform(vertex, transform, invert);\n  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';\n}\n\nfunction isNotGroup(el) {\n  return !el.isGroup;\n}\n\nfunction isPath(el) {\n  return el.shape != null;\n}\n/**\r\n * Apply group transition animation from g1 to g2.\r\n * If no animatableModel, no animation.\r\n */\n\n\nexport function groupTransition(g1, g2, animatableModel) {\n  if (!g1 || !g2) {\n    return;\n  }\n\n  function getElMap(g) {\n    var elMap = {};\n    g.traverse(function (el) {\n      if (isNotGroup(el) && el.anid) {\n        elMap[el.anid] = el;\n      }\n    });\n    return elMap;\n  }\n\n  function getAnimatableProps(el) {\n    var obj = {\n      x: el.x,\n      y: el.y,\n      rotation: el.rotation\n    };\n\n    if (isPath(el)) {\n      obj.shape = extend({}, el.shape);\n    }\n\n    return obj;\n  }\n\n  var elMap1 = getElMap(g1);\n  g2.traverse(function (el) {\n    if (isNotGroup(el) && el.anid) {\n      var oldEl = elMap1[el.anid];\n\n      if (oldEl) {\n        var newProp = getAnimatableProps(el);\n        el.attr(getAnimatableProps(oldEl));\n        updateProps(el, newProp, animatableModel, getECData(el).dataIndex);\n      }\n    }\n  });\n}\nexport function clipPointsByRect(points, rect) {\n  // FIXME: this way migth be incorrect when grpahic clipped by a corner.\n  // and when element have border.\n  return map(points, function (point) {\n    var x = point[0];\n    x = mathMax(x, rect.x);\n    x = mathMin(x, rect.x + rect.width);\n    var y = point[1];\n    y = mathMax(y, rect.y);\n    y = mathMin(y, rect.y + rect.height);\n    return [x, y];\n  });\n}\n/**\r\n * Return a new clipped rect. If rect size are negative, return undefined.\r\n */\n\nexport function clipRectByRect(targetRect, rect) {\n  var x = mathMax(targetRect.x, rect.x);\n  var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);\n  var y = mathMax(targetRect.y, rect.y);\n  var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height); // If the total rect is cliped, nothing, including the border,\n  // should be painted. So return undefined.\n\n  if (x2 >= x && y2 >= y) {\n    return {\n      x: x,\n      y: y,\n      width: x2 - x,\n      height: y2 - y\n    };\n  }\n}\nexport function createIcon(iconStr, // Support 'image://' or 'path://' or direct svg path.\nopt, rect) {\n  var innerOpts = extend({\n    rectHover: true\n  }, opt);\n  var style = innerOpts.style = {\n    strokeNoScale: true\n  };\n  rect = rect || {\n    x: -1,\n    y: -1,\n    width: 2,\n    height: 2\n  };\n\n  if (iconStr) {\n    return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), defaults(style, rect), new ZRImage(innerOpts)) : makePath(iconStr.replace('path://', ''), innerOpts, rect, 'center');\n  }\n}\n/**\r\n * Return `true` if the given line (line `a`) and the given polygon\r\n * are intersect.\r\n * Note that we do not count colinear as intersect here because no\r\n * requirement for that. We could do that if required in future.\r\n */\n\nexport function linePolygonIntersect(a1x, a1y, a2x, a2y, points) {\n  for (var i = 0, p2 = points[points.length - 1]; i < points.length; i++) {\n    var p = points[i];\n\n    if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {\n      return true;\n    }\n\n    p2 = p;\n  }\n}\n/**\r\n * Return `true` if the given two lines (line `a` and line `b`)\r\n * are intersect.\r\n * Note that we do not count colinear as intersect here because no\r\n * requirement for that. We could do that if required in future.\r\n */\n\nexport function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {\n  // let `vec_m` to be `vec_a2 - vec_a1` and `vec_n` to be `vec_b2 - vec_b1`.\n  var mx = a2x - a1x;\n  var my = a2y - a1y;\n  var nx = b2x - b1x;\n  var ny = b2y - b1y; // `vec_m` and `vec_n` are parallel iff\n  //     exising `k` such that `vec_m = k · vec_n`, equivalent to `vec_m X vec_n = 0`.\n\n  var nmCrossProduct = crossProduct2d(nx, ny, mx, my);\n\n  if (nearZero(nmCrossProduct)) {\n    return false;\n  } // `vec_m` and `vec_n` are intersect iff\n  //     existing `p` and `q` in [0, 1] such that `vec_a1 + p * vec_m = vec_b1 + q * vec_n`,\n  //     such that `q = ((vec_a1 - vec_b1) X vec_m) / (vec_n X vec_m)`\n  //           and `p = ((vec_a1 - vec_b1) X vec_n) / (vec_n X vec_m)`.\n\n\n  var b1a1x = a1x - b1x;\n  var b1a1y = a1y - b1y;\n  var q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;\n\n  if (q < 0 || q > 1) {\n    return false;\n  }\n\n  var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;\n\n  if (p < 0 || p > 1) {\n    return false;\n  }\n\n  return true;\n}\n/**\r\n * Cross product of 2-dimension vector.\r\n */\n\nfunction crossProduct2d(x1, y1, x2, y2) {\n  return x1 * y2 - x2 * y1;\n}\n\nfunction nearZero(val) {\n  return val <= 1e-6 && val >= -1e-6;\n}\n\nexport function setTooltipConfig(opt) {\n  var itemTooltipOption = opt.itemTooltipOption;\n  var componentModel = opt.componentModel;\n  var itemName = opt.itemName;\n  var itemTooltipOptionObj = isString(itemTooltipOption) ? {\n    formatter: itemTooltipOption\n  } : itemTooltipOption;\n  var mainType = componentModel.mainType;\n  var componentIndex = componentModel.componentIndex;\n  var formatterParams = {\n    componentType: mainType,\n    name: itemName,\n    $vars: ['name']\n  };\n  formatterParams[mainType + 'Index'] = componentIndex;\n  var formatterParamsExtra = opt.formatterParamsExtra;\n\n  if (formatterParamsExtra) {\n    each(keys(formatterParamsExtra), function (key) {\n      if (!hasOwn(formatterParams, key)) {\n        formatterParams[key] = formatterParamsExtra[key];\n        formatterParams.$vars.push(key);\n      }\n    });\n  }\n\n  var ecData = getECData(opt.el);\n  ecData.componentMainType = mainType;\n  ecData.componentIndex = componentIndex;\n  ecData.tooltipConfig = {\n    name: itemName,\n    option: defaults({\n      content: itemName,\n      formatterParams: formatterParams\n    }, itemTooltipOptionObj)\n  };\n}\n\nfunction traverseElement(el, cb) {\n  var stopped; // TODO\n  // Polyfill for fixing zrender group traverse don't visit it's root issue.\n\n  if (el.isGroup) {\n    stopped = cb(el);\n  }\n\n  if (!stopped) {\n    el.traverse(cb);\n  }\n}\n\nexport function traverseElements(els, cb) {\n  if (els) {\n    if (isArray(els)) {\n      for (var i = 0; i < els.length; i++) {\n        traverseElement(els[i], cb);\n      }\n    } else {\n      traverseElement(els, cb);\n    }\n  }\n} // Register built-in shapes. These shapes might be overwirtten\n// by users, although we do not recommend that.\n\nregisterShape('circle', Circle);\nregisterShape('ellipse', Ellipse);\nregisterShape('sector', Sector);\nregisterShape('ring', Ring);\nregisterShape('polygon', Polygon);\nregisterShape('polyline', Polyline);\nregisterShape('rect', Rect);\nregisterShape('line', Line);\nregisterShape('bezierCurve', BezierCurve);\nregisterShape('arc', Arc);\nexport { Group, ZRImage as Image, ZRText as Text, Circle, Ellipse, Sector, Ring, Polygon, Polyline, Rect, Line, BezierCurve, Arc, IncrementalDisplayable, CompoundPath, LinearGradient, RadialGradient, BoundingRect, OrientedBoundingRect, Point, Path };","map":{"version":3,"sources":["D:/Work/WorkSpace/GitWorkSpace/TenShop/resource/ElectronicMall/src/qingge-Market/qingge-vue/node_modules/echarts/lib/util/graphic.js"],"names":["pathTool","matrix","vector","Path","Transformable","ZRImage","Group","ZRText","Circle","Ellipse","Sector","Ring","Polygon","Polyline","Rect","Line","BezierCurve","Arc","CompoundPath","LinearGradient","RadialGradient","BoundingRect","OrientedBoundingRect","Point","IncrementalDisplayable","subPixelOptimizeUtil","extend","isArrayLike","map","defaults","isString","keys","each","hasOwn","isArray","getECData","updateProps","initProps","removeElement","removeElementWithFadeOut","isElementRemoved","mathMax","Math","max","mathMin","min","_customShapeMap","extendShape","opts","extendPathFromString","extendFromString","extendPath","pathData","registerShape","name","ShapeClass","getShapeClass","hasOwnProperty","makePath","rect","layout","path","createFromString","centerGraphic","getBoundingRect","resizePath","makeImage","imageUrl","zrImg","style","image","x","y","width","height","onload","img","boundingRect","setStyle","aspect","cx","cy","mergePath","applyTransform","pathRect","m","calculateTransform","subPixelOptimizeLine","param","shape","subPixelOptimizeRect","subPixelOptimize","getTransform","target","ancestor","mat","identity","mul","getLocalTransform","parent","transform","invert","transformDirection","direction","hBase","abs","vBase","vertex","isNotGroup","el","isGroup","isPath","groupTransition","g1","g2","animatableModel","getElMap","g","elMap","traverse","anid","getAnimatableProps","obj","rotation","elMap1","oldEl","newProp","attr","dataIndex","clipPointsByRect","points","point","clipRectByRect","targetRect","x2","y2","createIcon","iconStr","opt","innerOpts","rectHover","strokeNoScale","indexOf","slice","replace","linePolygonIntersect","a1x","a1y","a2x","a2y","i","p2","length","p","lineLineIntersect","b1x","b1y","b2x","b2y","mx","my","nx","ny","nmCrossProduct","crossProduct2d","nearZero","b1a1x","b1a1y","q","x1","y1","val","setTooltipConfig","itemTooltipOption","componentModel","itemName","itemTooltipOptionObj","formatter","mainType","componentIndex","formatterParams","componentType","$vars","formatterParamsExtra","key","push","ecData","componentMainType","tooltipConfig","option","content","traverseElement","cb","stopped","traverseElements","els","Image","Text"],"mappings":"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","sourcesContent":["\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n\r\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\nimport * as pathTool from 'zrender/lib/tool/path.js';\r\nimport * as matrix from 'zrender/lib/core/matrix.js';\r\nimport * as vector from 'zrender/lib/core/vector.js';\r\nimport Path from 'zrender/lib/graphic/Path.js';\r\nimport Transformable from 'zrender/lib/core/Transformable.js';\r\nimport ZRImage from 'zrender/lib/graphic/Image.js';\r\nimport Group from 'zrender/lib/graphic/Group.js';\r\nimport ZRText from 'zrender/lib/graphic/Text.js';\r\nimport Circle from 'zrender/lib/graphic/shape/Circle.js';\r\nimport Ellipse from 'zrender/lib/graphic/shape/Ellipse.js';\r\nimport Sector from 'zrender/lib/graphic/shape/Sector.js';\r\nimport Ring from 'zrender/lib/graphic/shape/Ring.js';\r\nimport Polygon from 'zrender/lib/graphic/shape/Polygon.js';\r\nimport Polyline from 'zrender/lib/graphic/shape/Polyline.js';\r\nimport Rect from 'zrender/lib/graphic/shape/Rect.js';\r\nimport Line from 'zrender/lib/graphic/shape/Line.js';\r\nimport BezierCurve from 'zrender/lib/graphic/shape/BezierCurve.js';\r\nimport Arc from 'zrender/lib/graphic/shape/Arc.js';\r\nimport CompoundPath from 'zrender/lib/graphic/CompoundPath.js';\r\nimport LinearGradient from 'zrender/lib/graphic/LinearGradient.js';\r\nimport RadialGradient from 'zrender/lib/graphic/RadialGradient.js';\r\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\r\nimport OrientedBoundingRect from 'zrender/lib/core/OrientedBoundingRect.js';\r\nimport Point from 'zrender/lib/core/Point.js';\r\nimport IncrementalDisplayable from 'zrender/lib/graphic/IncrementalDisplayable.js';\r\nimport * as subPixelOptimizeUtil from 'zrender/lib/graphic/helper/subPixelOptimize.js';\r\nimport { extend, isArrayLike, map, defaults, isString, keys, each, hasOwn, isArray } from 'zrender/lib/core/util.js';\r\nimport { getECData } from './innerStore.js';\r\nimport { updateProps, initProps, removeElement, removeElementWithFadeOut, isElementRemoved } from '../animation/basicTrasition.js';\r\n/**\r\n * @deprecated export for compatitable reason\r\n */\r\n\r\nexport { updateProps, initProps, removeElement, removeElementWithFadeOut, isElementRemoved };\r\nvar mathMax = Math.max;\r\nvar mathMin = Math.min;\r\nvar _customShapeMap = {};\r\n/**\r\n * Extend shape with parameters\r\n */\r\n\r\nexport function extendShape(opts) {\r\n  return Path.extend(opts);\r\n}\r\nvar extendPathFromString = pathTool.extendFromString;\r\n/**\r\n * Extend path\r\n */\r\n\r\nexport function extendPath(pathData, opts) {\r\n  return extendPathFromString(pathData, opts);\r\n}\r\n/**\r\n * Register a user defined shape.\r\n * The shape class can be fetched by `getShapeClass`\r\n * This method will overwrite the registered shapes, including\r\n * the registered built-in shapes, if using the same `name`.\r\n * The shape can be used in `custom series` and\r\n * `graphic component` by declaring `{type: name}`.\r\n *\r\n * @param name\r\n * @param ShapeClass Can be generated by `extendShape`.\r\n */\r\n\r\nexport function registerShape(name, ShapeClass) {\r\n  _customShapeMap[name] = ShapeClass;\r\n}\r\n/**\r\n * Find shape class registered by `registerShape`. Usually used in\r\n * fetching user defined shape.\r\n *\r\n * [Caution]:\r\n * (1) This method **MUST NOT be used inside echarts !!!**, unless it is prepared\r\n * to use user registered shapes.\r\n * Because the built-in shape (see `getBuiltInShape`) will be registered by\r\n * `registerShape` by default. That enables users to get both built-in\r\n * shapes as well as the shapes belonging to themsleves. But users can overwrite\r\n * the built-in shapes by using names like 'circle', 'rect' via calling\r\n * `registerShape`. So the echarts inner featrues should not fetch shapes from here\r\n * in case that it is overwritten by users, except that some features, like\r\n * `custom series`, `graphic component`, do it deliberately.\r\n *\r\n * (2) In the features like `custom series`, `graphic component`, the user input\r\n * `{tpye: 'xxx'}` does not only specify shapes but also specify other graphic\r\n * elements like `'group'`, `'text'`, `'image'` or event `'path'`. Those names\r\n * are reserved names, that is, if some user register a shape named `'image'`,\r\n * the shape will not be used. If we intending to add some more reserved names\r\n * in feature, that might bring break changes (disable some existing user shape\r\n * names). But that case probably rearly happen. So we dont make more mechanism\r\n * to resolve this issue here.\r\n *\r\n * @param name\r\n * @return The shape class. If not found, return nothing.\r\n */\r\n\r\nexport function getShapeClass(name) {\r\n  if (_customShapeMap.hasOwnProperty(name)) {\r\n    return _customShapeMap[name];\r\n  }\r\n}\r\n/**\r\n * Create a path element from path data string\r\n * @param pathData\r\n * @param opts\r\n * @param rect\r\n * @param layout 'center' or 'cover' default to be cover\r\n */\r\n\r\nexport function makePath(pathData, opts, rect, layout) {\r\n  var path = pathTool.createFromString(pathData, opts);\r\n\r\n  if (rect) {\r\n    if (layout === 'center') {\r\n      rect = centerGraphic(rect, path.getBoundingRect());\r\n    }\r\n\r\n    resizePath(path, rect);\r\n  }\r\n\r\n  return path;\r\n}\r\n/**\r\n * Create a image element from image url\r\n * @param imageUrl image url\r\n * @param opts options\r\n * @param rect constrain rect\r\n * @param layout 'center' or 'cover'. Default to be 'cover'\r\n */\r\n\r\nexport function makeImage(imageUrl, rect, layout) {\r\n  var zrImg = new ZRImage({\r\n    style: {\r\n      image: imageUrl,\r\n      x: rect.x,\r\n      y: rect.y,\r\n      width: rect.width,\r\n      height: rect.height\r\n    },\r\n    onload: function (img) {\r\n      if (layout === 'center') {\r\n        var boundingRect = {\r\n          width: img.width,\r\n          height: img.height\r\n        };\r\n        zrImg.setStyle(centerGraphic(rect, boundingRect));\r\n      }\r\n    }\r\n  });\r\n  return zrImg;\r\n}\r\n/**\r\n * Get position of centered element in bounding box.\r\n *\r\n * @param  rect         element local bounding box\r\n * @param  boundingRect constraint bounding box\r\n * @return element position containing x, y, width, and height\r\n */\r\n\r\nfunction centerGraphic(rect, boundingRect) {\r\n  // Set rect to center, keep width / height ratio.\r\n  var aspect = boundingRect.width / boundingRect.height;\r\n  var width = rect.height * aspect;\r\n  var height;\r\n\r\n  if (width <= rect.width) {\r\n    height = rect.height;\r\n  } else {\r\n    width = rect.width;\r\n    height = width / aspect;\r\n  }\r\n\r\n  var cx = rect.x + rect.width / 2;\r\n  var cy = rect.y + rect.height / 2;\r\n  return {\r\n    x: cx - width / 2,\r\n    y: cy - height / 2,\r\n    width: width,\r\n    height: height\r\n  };\r\n}\r\n\r\nexport var mergePath = pathTool.mergePath;\r\n/**\r\n * Resize a path to fit the rect\r\n * @param path\r\n * @param rect\r\n */\r\n\r\nexport function resizePath(path, rect) {\r\n  if (!path.applyTransform) {\r\n    return;\r\n  }\r\n\r\n  var pathRect = path.getBoundingRect();\r\n  var m = pathRect.calculateTransform(rect);\r\n  path.applyTransform(m);\r\n}\r\n/**\r\n * Sub pixel optimize line for canvas\r\n */\r\n\r\nexport function subPixelOptimizeLine(param) {\r\n  subPixelOptimizeUtil.subPixelOptimizeLine(param.shape, param.shape, param.style);\r\n  return param;\r\n}\r\n/**\r\n * Sub pixel optimize rect for canvas\r\n */\r\n\r\nexport function subPixelOptimizeRect(param) {\r\n  subPixelOptimizeUtil.subPixelOptimizeRect(param.shape, param.shape, param.style);\r\n  return param;\r\n}\r\n/**\r\n * Sub pixel optimize for canvas\r\n *\r\n * @param position Coordinate, such as x, y\r\n * @param lineWidth Should be nonnegative integer.\r\n * @param positiveOrNegative Default false (negative).\r\n * @return Optimized position.\r\n */\r\n\r\nexport var subPixelOptimize = subPixelOptimizeUtil.subPixelOptimize;\r\n/**\r\n * Get transform matrix of target (param target),\r\n * in coordinate of its ancestor (param ancestor)\r\n *\r\n * @param target\r\n * @param [ancestor]\r\n */\r\n\r\nexport function getTransform(target, ancestor) {\r\n  var mat = matrix.identity([]);\r\n\r\n  while (target && target !== ancestor) {\r\n    matrix.mul(mat, target.getLocalTransform(), mat);\r\n    target = target.parent;\r\n  }\r\n\r\n  return mat;\r\n}\r\n/**\r\n * Apply transform to an vertex.\r\n * @param target [x, y]\r\n * @param transform Can be:\r\n *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n *      + {position, rotation, scale}, the same as `zrender/Transformable`.\r\n * @param invert Whether use invert matrix.\r\n * @return [x, y]\r\n */\r\n\r\nexport function applyTransform(target, transform, invert) {\r\n  if (transform && !isArrayLike(transform)) {\r\n    transform = Transformable.getLocalTransform(transform);\r\n  }\r\n\r\n  if (invert) {\r\n    transform = matrix.invert([], transform);\r\n  }\r\n\r\n  return vector.applyTransform([], target, transform);\r\n}\r\n/**\r\n * @param direction 'left' 'right' 'top' 'bottom'\r\n * @param transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n * @param invert Whether use invert matrix.\r\n * @return Transformed direction. 'left' 'right' 'top' 'bottom'\r\n */\r\n\r\nexport function transformDirection(direction, transform, invert) {\r\n  // Pick a base, ensure that transform result will not be (0, 0).\r\n  var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);\r\n  var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);\r\n  var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];\r\n  vertex = applyTransform(vertex, transform, invert);\r\n  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';\r\n}\r\n\r\nfunction isNotGroup(el) {\r\n  return !el.isGroup;\r\n}\r\n\r\nfunction isPath(el) {\r\n  return el.shape != null;\r\n}\r\n/**\r\n * Apply group transition animation from g1 to g2.\r\n * If no animatableModel, no animation.\r\n */\r\n\r\n\r\nexport function groupTransition(g1, g2, animatableModel) {\r\n  if (!g1 || !g2) {\r\n    return;\r\n  }\r\n\r\n  function getElMap(g) {\r\n    var elMap = {};\r\n    g.traverse(function (el) {\r\n      if (isNotGroup(el) && el.anid) {\r\n        elMap[el.anid] = el;\r\n      }\r\n    });\r\n    return elMap;\r\n  }\r\n\r\n  function getAnimatableProps(el) {\r\n    var obj = {\r\n      x: el.x,\r\n      y: el.y,\r\n      rotation: el.rotation\r\n    };\r\n\r\n    if (isPath(el)) {\r\n      obj.shape = extend({}, el.shape);\r\n    }\r\n\r\n    return obj;\r\n  }\r\n\r\n  var elMap1 = getElMap(g1);\r\n  g2.traverse(function (el) {\r\n    if (isNotGroup(el) && el.anid) {\r\n      var oldEl = elMap1[el.anid];\r\n\r\n      if (oldEl) {\r\n        var newProp = getAnimatableProps(el);\r\n        el.attr(getAnimatableProps(oldEl));\r\n        updateProps(el, newProp, animatableModel, getECData(el).dataIndex);\r\n      }\r\n    }\r\n  });\r\n}\r\nexport function clipPointsByRect(points, rect) {\r\n  // FIXME: this way migth be incorrect when grpahic clipped by a corner.\r\n  // and when element have border.\r\n  return map(points, function (point) {\r\n    var x = point[0];\r\n    x = mathMax(x, rect.x);\r\n    x = mathMin(x, rect.x + rect.width);\r\n    var y = point[1];\r\n    y = mathMax(y, rect.y);\r\n    y = mathMin(y, rect.y + rect.height);\r\n    return [x, y];\r\n  });\r\n}\r\n/**\r\n * Return a new clipped rect. If rect size are negative, return undefined.\r\n */\r\n\r\nexport function clipRectByRect(targetRect, rect) {\r\n  var x = mathMax(targetRect.x, rect.x);\r\n  var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);\r\n  var y = mathMax(targetRect.y, rect.y);\r\n  var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height); // If the total rect is cliped, nothing, including the border,\r\n  // should be painted. So return undefined.\r\n\r\n  if (x2 >= x && y2 >= y) {\r\n    return {\r\n      x: x,\r\n      y: y,\r\n      width: x2 - x,\r\n      height: y2 - y\r\n    };\r\n  }\r\n}\r\nexport function createIcon(iconStr, // Support 'image://' or 'path://' or direct svg path.\r\nopt, rect) {\r\n  var innerOpts = extend({\r\n    rectHover: true\r\n  }, opt);\r\n  var style = innerOpts.style = {\r\n    strokeNoScale: true\r\n  };\r\n  rect = rect || {\r\n    x: -1,\r\n    y: -1,\r\n    width: 2,\r\n    height: 2\r\n  };\r\n\r\n  if (iconStr) {\r\n    return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), defaults(style, rect), new ZRImage(innerOpts)) : makePath(iconStr.replace('path://', ''), innerOpts, rect, 'center');\r\n  }\r\n}\r\n/**\r\n * Return `true` if the given line (line `a`) and the given polygon\r\n * are intersect.\r\n * Note that we do not count colinear as intersect here because no\r\n * requirement for that. We could do that if required in future.\r\n */\r\n\r\nexport function linePolygonIntersect(a1x, a1y, a2x, a2y, points) {\r\n  for (var i = 0, p2 = points[points.length - 1]; i < points.length; i++) {\r\n    var p = points[i];\r\n\r\n    if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {\r\n      return true;\r\n    }\r\n\r\n    p2 = p;\r\n  }\r\n}\r\n/**\r\n * Return `true` if the given two lines (line `a` and line `b`)\r\n * are intersect.\r\n * Note that we do not count colinear as intersect here because no\r\n * requirement for that. We could do that if required in future.\r\n */\r\n\r\nexport function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {\r\n  // let `vec_m` to be `vec_a2 - vec_a1` and `vec_n` to be `vec_b2 - vec_b1`.\r\n  var mx = a2x - a1x;\r\n  var my = a2y - a1y;\r\n  var nx = b2x - b1x;\r\n  var ny = b2y - b1y; // `vec_m` and `vec_n` are parallel iff\r\n  //     exising `k` such that `vec_m = k · vec_n`, equivalent to `vec_m X vec_n = 0`.\r\n\r\n  var nmCrossProduct = crossProduct2d(nx, ny, mx, my);\r\n\r\n  if (nearZero(nmCrossProduct)) {\r\n    return false;\r\n  } // `vec_m` and `vec_n` are intersect iff\r\n  //     existing `p` and `q` in [0, 1] such that `vec_a1 + p * vec_m = vec_b1 + q * vec_n`,\r\n  //     such that `q = ((vec_a1 - vec_b1) X vec_m) / (vec_n X vec_m)`\r\n  //           and `p = ((vec_a1 - vec_b1) X vec_n) / (vec_n X vec_m)`.\r\n\r\n\r\n  var b1a1x = a1x - b1x;\r\n  var b1a1y = a1y - b1y;\r\n  var q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;\r\n\r\n  if (q < 0 || q > 1) {\r\n    return false;\r\n  }\r\n\r\n  var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;\r\n\r\n  if (p < 0 || p > 1) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n/**\r\n * Cross product of 2-dimension vector.\r\n */\r\n\r\nfunction crossProduct2d(x1, y1, x2, y2) {\r\n  return x1 * y2 - x2 * y1;\r\n}\r\n\r\nfunction nearZero(val) {\r\n  return val <= 1e-6 && val >= -1e-6;\r\n}\r\n\r\nexport function setTooltipConfig(opt) {\r\n  var itemTooltipOption = opt.itemTooltipOption;\r\n  var componentModel = opt.componentModel;\r\n  var itemName = opt.itemName;\r\n  var itemTooltipOptionObj = isString(itemTooltipOption) ? {\r\n    formatter: itemTooltipOption\r\n  } : itemTooltipOption;\r\n  var mainType = componentModel.mainType;\r\n  var componentIndex = componentModel.componentIndex;\r\n  var formatterParams = {\r\n    componentType: mainType,\r\n    name: itemName,\r\n    $vars: ['name']\r\n  };\r\n  formatterParams[mainType + 'Index'] = componentIndex;\r\n  var formatterParamsExtra = opt.formatterParamsExtra;\r\n\r\n  if (formatterParamsExtra) {\r\n    each(keys(formatterParamsExtra), function (key) {\r\n      if (!hasOwn(formatterParams, key)) {\r\n        formatterParams[key] = formatterParamsExtra[key];\r\n        formatterParams.$vars.push(key);\r\n      }\r\n    });\r\n  }\r\n\r\n  var ecData = getECData(opt.el);\r\n  ecData.componentMainType = mainType;\r\n  ecData.componentIndex = componentIndex;\r\n  ecData.tooltipConfig = {\r\n    name: itemName,\r\n    option: defaults({\r\n      content: itemName,\r\n      formatterParams: formatterParams\r\n    }, itemTooltipOptionObj)\r\n  };\r\n}\r\n\r\nfunction traverseElement(el, cb) {\r\n  var stopped; // TODO\r\n  // Polyfill for fixing zrender group traverse don't visit it's root issue.\r\n\r\n  if (el.isGroup) {\r\n    stopped = cb(el);\r\n  }\r\n\r\n  if (!stopped) {\r\n    el.traverse(cb);\r\n  }\r\n}\r\n\r\nexport function traverseElements(els, cb) {\r\n  if (els) {\r\n    if (isArray(els)) {\r\n      for (var i = 0; i < els.length; i++) {\r\n        traverseElement(els[i], cb);\r\n      }\r\n    } else {\r\n      traverseElement(els, cb);\r\n    }\r\n  }\r\n} // Register built-in shapes. These shapes might be overwirtten\r\n// by users, although we do not recommend that.\r\n\r\nregisterShape('circle', Circle);\r\nregisterShape('ellipse', Ellipse);\r\nregisterShape('sector', Sector);\r\nregisterShape('ring', Ring);\r\nregisterShape('polygon', Polygon);\r\nregisterShape('polyline', Polyline);\r\nregisterShape('rect', Rect);\r\nregisterShape('line', Line);\r\nregisterShape('bezierCurve', BezierCurve);\r\nregisterShape('arc', Arc);\r\nexport { Group, ZRImage as Image, ZRText as Text, Circle, Ellipse, Sector, Ring, Polygon, Polyline, Rect, Line, BezierCurve, Arc, IncrementalDisplayable, CompoundPath, LinearGradient, RadialGradient, BoundingRect, OrientedBoundingRect, Point, Path };"]},"metadata":{},"sourceType":"module"}