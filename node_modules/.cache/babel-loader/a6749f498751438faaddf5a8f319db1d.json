{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { getPrecisionSafe, round } from '../util/number.js';\nimport IntervalScale from '../scale/Interval.js';\nimport { getScaleExtent } from './axisHelper.js';\nimport { warn } from '../util/log.js';\nimport { increaseInterval, isValueNice } from '../scale/helper.js';\nvar mathLog = Math.log;\nexport function alignScaleTicks(scale, axisModel, alignToScale) {\n  var intervalScaleProto = IntervalScale.prototype; // NOTE: There is a precondition for log scale  here:\n  // In log scale we store _interval and _extent of exponent value.\n  // So if we use the method of InternalScale to set/get these data.\n  // It process the exponent value, which is linear and what we want here.\n\n  var alignToTicks = intervalScaleProto.getTicks.call(alignToScale);\n  var alignToNicedTicks = intervalScaleProto.getTicks.call(alignToScale, true);\n  var alignToSplitNumber = alignToTicks.length - 1;\n  var alignToInterval = intervalScaleProto.getInterval.call(alignToScale);\n  var scaleExtent = getScaleExtent(scale, axisModel);\n  var rawExtent = scaleExtent.extent;\n  var isMinFixed = scaleExtent.fixMin;\n  var isMaxFixed = scaleExtent.fixMax;\n\n  if (scale.type === 'log') {\n    var logBase = mathLog(scale.base);\n    rawExtent = [mathLog(rawExtent[0]) / logBase, mathLog(rawExtent[1]) / logBase];\n  }\n\n  scale.setExtent(rawExtent[0], rawExtent[1]);\n  scale.calcNiceExtent({\n    splitNumber: alignToSplitNumber,\n    fixMin: isMinFixed,\n    fixMax: isMaxFixed\n  });\n  var extent = intervalScaleProto.getExtent.call(scale); // Need to update the rawExtent.\n  // Because value in rawExtent may be not parsed. e.g. 'dataMin', 'dataMax'\n\n  if (isMinFixed) {\n    rawExtent[0] = extent[0];\n  }\n\n  if (isMaxFixed) {\n    rawExtent[1] = extent[1];\n  }\n\n  var interval = intervalScaleProto.getInterval.call(scale);\n  var min = rawExtent[0];\n  var max = rawExtent[1];\n\n  if (isMinFixed && isMaxFixed) {\n    // User set min, max, divide to get new interval\n    interval = (max - min) / alignToSplitNumber;\n  } else if (isMinFixed) {\n    max = rawExtent[0] + interval * alignToSplitNumber; // User set min, expand extent on the other side\n\n    while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1])) {\n      interval = increaseInterval(interval);\n      max = rawExtent[0] + interval * alignToSplitNumber;\n    }\n  } else if (isMaxFixed) {\n    // User set max, expand extent on the other side\n    min = rawExtent[1] - interval * alignToSplitNumber;\n\n    while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0])) {\n      interval = increaseInterval(interval);\n      min = rawExtent[1] - interval * alignToSplitNumber;\n    }\n  } else {\n    var nicedSplitNumber = scale.getTicks().length - 1;\n\n    if (nicedSplitNumber > alignToSplitNumber) {\n      interval = increaseInterval(interval);\n    }\n\n    var range = interval * alignToSplitNumber;\n    max = Math.ceil(rawExtent[1] / interval) * interval;\n    min = round(max - range); // Not change the result that crossing zero.\n\n    if (min < 0 && rawExtent[0] >= 0) {\n      min = 0;\n      max = round(range);\n    } else if (max > 0 && rawExtent[1] <= 0) {\n      max = 0;\n      min = -round(range);\n    }\n  } // Adjust min, max based on the extent of alignTo. When min or max is set in alignTo scale\n\n\n  var t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval;\n  var t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval; // NOTE: Must in setExtent -> setInterval -> setNiceExtent order.\n\n  intervalScaleProto.setExtent.call(scale, min + interval * t0, max + interval * t1);\n  intervalScaleProto.setInterval.call(scale, interval);\n\n  if (t0 || t1) {\n    intervalScaleProto.setNiceExtent.call(scale, min + interval, max - interval);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    var ticks = intervalScaleProto.getTicks.call(scale);\n\n    if (ticks[1] && (!isValueNice(interval) || getPrecisionSafe(ticks[1].value) > getPrecisionSafe(interval))) {\n      warn( // eslint-disable-next-line\n      \"The ticks may be not readable when set min: \" + axisModel.get('min') + \", max: \" + axisModel.get('max') + \" and alignTicks: true\");\n    }\n  }\n}","map":{"version":3,"sources":["/home/rayce/Udatabase/study/ElectronicMall/BookVue/node_modules/echarts/lib/coord/axisAlignTicks.js"],"names":["getPrecisionSafe","round","IntervalScale","getScaleExtent","warn","increaseInterval","isValueNice","mathLog","Math","log","alignScaleTicks","scale","axisModel","alignToScale","intervalScaleProto","prototype","alignToTicks","getTicks","call","alignToNicedTicks","alignToSplitNumber","length","alignToInterval","getInterval","scaleExtent","rawExtent","extent","isMinFixed","fixMin","isMaxFixed","fixMax","type","logBase","base","setExtent","calcNiceExtent","splitNumber","getExtent","interval","min","max","isFinite","nicedSplitNumber","range","ceil","t0","value","t1","setInterval","setNiceExtent","process","env","NODE_ENV","ticks","get"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { getPrecisionSafe, round } from '../util/number.js';\nimport IntervalScale from '../scale/Interval.js';\nimport { getScaleExtent } from './axisHelper.js';\nimport { warn } from '../util/log.js';\nimport { increaseInterval, isValueNice } from '../scale/helper.js';\nvar mathLog = Math.log;\nexport function alignScaleTicks(scale, axisModel, alignToScale) {\n  var intervalScaleProto = IntervalScale.prototype; // NOTE: There is a precondition for log scale  here:\n  // In log scale we store _interval and _extent of exponent value.\n  // So if we use the method of InternalScale to set/get these data.\n  // It process the exponent value, which is linear and what we want here.\n\n  var alignToTicks = intervalScaleProto.getTicks.call(alignToScale);\n  var alignToNicedTicks = intervalScaleProto.getTicks.call(alignToScale, true);\n  var alignToSplitNumber = alignToTicks.length - 1;\n  var alignToInterval = intervalScaleProto.getInterval.call(alignToScale);\n  var scaleExtent = getScaleExtent(scale, axisModel);\n  var rawExtent = scaleExtent.extent;\n  var isMinFixed = scaleExtent.fixMin;\n  var isMaxFixed = scaleExtent.fixMax;\n\n  if (scale.type === 'log') {\n    var logBase = mathLog(scale.base);\n    rawExtent = [mathLog(rawExtent[0]) / logBase, mathLog(rawExtent[1]) / logBase];\n  }\n\n  scale.setExtent(rawExtent[0], rawExtent[1]);\n  scale.calcNiceExtent({\n    splitNumber: alignToSplitNumber,\n    fixMin: isMinFixed,\n    fixMax: isMaxFixed\n  });\n  var extent = intervalScaleProto.getExtent.call(scale); // Need to update the rawExtent.\n  // Because value in rawExtent may be not parsed. e.g. 'dataMin', 'dataMax'\n\n  if (isMinFixed) {\n    rawExtent[0] = extent[0];\n  }\n\n  if (isMaxFixed) {\n    rawExtent[1] = extent[1];\n  }\n\n  var interval = intervalScaleProto.getInterval.call(scale);\n  var min = rawExtent[0];\n  var max = rawExtent[1];\n\n  if (isMinFixed && isMaxFixed) {\n    // User set min, max, divide to get new interval\n    interval = (max - min) / alignToSplitNumber;\n  } else if (isMinFixed) {\n    max = rawExtent[0] + interval * alignToSplitNumber; // User set min, expand extent on the other side\n\n    while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1])) {\n      interval = increaseInterval(interval);\n      max = rawExtent[0] + interval * alignToSplitNumber;\n    }\n  } else if (isMaxFixed) {\n    // User set max, expand extent on the other side\n    min = rawExtent[1] - interval * alignToSplitNumber;\n\n    while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0])) {\n      interval = increaseInterval(interval);\n      min = rawExtent[1] - interval * alignToSplitNumber;\n    }\n  } else {\n    var nicedSplitNumber = scale.getTicks().length - 1;\n\n    if (nicedSplitNumber > alignToSplitNumber) {\n      interval = increaseInterval(interval);\n    }\n\n    var range = interval * alignToSplitNumber;\n    max = Math.ceil(rawExtent[1] / interval) * interval;\n    min = round(max - range); // Not change the result that crossing zero.\n\n    if (min < 0 && rawExtent[0] >= 0) {\n      min = 0;\n      max = round(range);\n    } else if (max > 0 && rawExtent[1] <= 0) {\n      max = 0;\n      min = -round(range);\n    }\n  } // Adjust min, max based on the extent of alignTo. When min or max is set in alignTo scale\n\n\n  var t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval;\n  var t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval; // NOTE: Must in setExtent -> setInterval -> setNiceExtent order.\n\n  intervalScaleProto.setExtent.call(scale, min + interval * t0, max + interval * t1);\n  intervalScaleProto.setInterval.call(scale, interval);\n\n  if (t0 || t1) {\n    intervalScaleProto.setNiceExtent.call(scale, min + interval, max - interval);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    var ticks = intervalScaleProto.getTicks.call(scale);\n\n    if (ticks[1] && (!isValueNice(interval) || getPrecisionSafe(ticks[1].value) > getPrecisionSafe(interval))) {\n      warn( // eslint-disable-next-line\n      \"The ticks may be not readable when set min: \" + axisModel.get('min') + \", max: \" + axisModel.get('max') + \" and alignTicks: true\");\n    }\n  }\n}"]},"metadata":{},"sourceType":"module"}