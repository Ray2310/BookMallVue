{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.function.name.js\";\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport { parseSVG, makeViewBoxTransform } from 'zrender/lib/tool/parseSVG.js';\nimport Group from 'zrender/lib/graphic/Group.js';\nimport Rect from 'zrender/lib/graphic/shape/Rect.js';\nimport { assert, createHashMap, each } from 'zrender/lib/core/util.js';\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport { parseXML } from 'zrender/lib/tool/parseXML.js';\nimport { GeoSVGRegion } from './Region.js';\n/**\r\n * \"region available\" means that: enable users to set attribute `name=\"xxx\"` on those tags\r\n * to make it be a region.\r\n * 1. region styles and its label styles can be defined in echarts opton:\r\n * ```js\r\n * geo: {\r\n *     regions: [{\r\n *         name: 'xxx',\r\n *         itemStyle: { ... },\r\n *         label: { ... }\r\n *     }, {\r\n *         ...\r\n *     },\r\n *     ...]\r\n * };\r\n * ```\r\n * 2. name can be duplicated in different SVG tag. All of the tags with the same name share\r\n * a region option. For exampel if there are two <path> representing two lung lobes. They have\r\n * no common parents but both of them need to display label \"lung\" inside.\r\n */\n\nvar REGION_AVAILABLE_SVG_TAG_MAP = createHashMap(['rect', 'circle', 'line', 'ellipse', 'polygon', 'polyline', 'path', // <text> <tspan> are also enabled becuase some SVG might paint text itself,\n// but still need to trigger events or tooltip.\n'text', 'tspan', // <g> is also enabled because this case: if multiple tags share one name\n// and need label displayed, every tags will display the name, which is not\n// expected. So we can put them into a <g name=\"xxx\">. Thereby only one label\n// displayed and located based on the bounding rect of the <g>.\n'g']);\n\nvar GeoSVGResource =\n/** @class */\nfunction () {\n  function GeoSVGResource(mapName, svg) {\n    this.type = 'geoSVG'; // All used graphics. key: hostKey, value: root\n\n    this._usedGraphicMap = createHashMap(); // All unused graphics.\n\n    this._freedGraphics = [];\n    this._mapName = mapName; // Only perform parse to XML object here, which might be time\n    // consiming for large SVG.\n    // Although convert XML to zrender element is also time consiming,\n    // if we do it here, the clone of zrender elements has to be\n    // required. So we do it once for each geo instance, util real\n    // performance issues call for optimizing it.\n\n    this._parsedXML = parseXML(svg);\n  }\n\n  GeoSVGResource.prototype.load = function ()\n  /* nameMap: NameMap */\n  {\n    // In the \"load\" stage, graphic need to be built to\n    // get boundingRect for geo coordinate system.\n    var firstGraphic = this._firstGraphic; // Create the return data structure only when first graphic created.\n    // Because they will be used in geo coordinate system update stage,\n    // and `regions` will be mounted at `geo` coordinate system,\n    // in which there is no \"view\" info, so that it should better not to\n    // make references to graphic elements.\n\n    if (!firstGraphic) {\n      firstGraphic = this._firstGraphic = this._buildGraphic(this._parsedXML);\n\n      this._freedGraphics.push(firstGraphic);\n\n      this._boundingRect = this._firstGraphic.boundingRect.clone(); // PENDING: `nameMap` will not be supported until some real requirement come.\n      // if (nameMap) {\n      //     named = applyNameMap(named, nameMap);\n      // }\n\n      var _a = createRegions(firstGraphic.named),\n          regions = _a.regions,\n          regionsMap = _a.regionsMap;\n\n      this._regions = regions;\n      this._regionsMap = regionsMap;\n    }\n\n    return {\n      boundingRect: this._boundingRect,\n      regions: this._regions,\n      regionsMap: this._regionsMap\n    };\n  };\n\n  GeoSVGResource.prototype._buildGraphic = function (svgXML) {\n    var result;\n    var rootFromParse;\n\n    try {\n      result = svgXML && parseSVG(svgXML, {\n        ignoreViewBox: true,\n        ignoreRootClip: true\n      }) || {};\n      rootFromParse = result.root;\n      assert(rootFromParse != null);\n    } catch (e) {\n      throw new Error('Invalid svg format\\n' + e.message);\n    } // Note: we keep the covenant that the root has no transform. So always add an extra root.\n\n\n    var root = new Group();\n    root.add(rootFromParse);\n    root.isGeoSVGGraphicRoot = true; // [THE_RULE_OF_VIEWPORT_AND_VIEWBOX]\n    //\n    // Consider: `<svg width=\"...\" height=\"...\" viewBox=\"...\">`\n    // - the `width/height` we call it `svgWidth/svgHeight` for short.\n    // - `(0, 0, svgWidth, svgHeight)` defines the viewport of the SVG, or say,\n    //   \"viewport boundingRect\", or `boundingRect` for short.\n    // - `viewBox` defines the transform from the real content ot the viewport.\n    //   `viewBox` has the same unit as the content of SVG.\n    //   If `viewBox` exists, a transform is defined, so the unit of `svgWidth/svgHeight` become\n    //   different from the content of SVG. Otherwise, they are the same.\n    //\n    // If both `svgWidth/svgHeight/viewBox` are specified in a SVG file, the transform rule will be:\n    // 0. `boundingRect` is `(0, 0, svgWidth, svgHeight)`. Set it to Geo['_rect'] (View['_rect']).\n    // 1. Make a transform from `viewBox` to `boundingRect`.\n    //    Note: only suport `preserveAspectRatio 'xMidYMid'` here. That is, this transform will preserve\n    //    the aspect ratio.\n    // 2. Make a transform from boundingRect to Geo['_viewRect'] (View['_viewRect'])\n    //    (`Geo`/`View` will do this job).\n    //    Note: this transform might not preserve aspect radio, which depending on how users specify\n    //    viewRect in echarts option (e.g., `geo.left/top/width/height` will not preserve aspect ratio,\n    //    but `geo.layoutCenter/layoutSize` will preserve aspect ratio).\n    //\n    // If `svgWidth/svgHeight` not specified, we use `viewBox` as the `boundingRect` to make the SVG\n    // layout look good.\n    //\n    // If neither `svgWidth/svgHeight` nor `viewBox` are not specified, we calculate the boundingRect\n    // of the SVG content and use them to make SVG layout look good.\n\n    var svgWidth = result.width;\n    var svgHeight = result.height;\n    var viewBoxRect = result.viewBoxRect;\n    var boundingRect = this._boundingRect;\n\n    if (!boundingRect) {\n      var bRectX = void 0;\n      var bRectY = void 0;\n      var bRectWidth = void 0;\n      var bRectHeight = void 0;\n\n      if (svgWidth != null) {\n        bRectX = 0;\n        bRectWidth = svgWidth;\n      } else if (viewBoxRect) {\n        bRectX = viewBoxRect.x;\n        bRectWidth = viewBoxRect.width;\n      }\n\n      if (svgHeight != null) {\n        bRectY = 0;\n        bRectHeight = svgHeight;\n      } else if (viewBoxRect) {\n        bRectY = viewBoxRect.y;\n        bRectHeight = viewBoxRect.height;\n      } // If both viewBox and svgWidth/svgHeight not specified,\n      // we have to determine how to layout those element to make them look good.\n\n\n      if (bRectX == null || bRectY == null) {\n        var calculatedBoundingRect = rootFromParse.getBoundingRect();\n\n        if (bRectX == null) {\n          bRectX = calculatedBoundingRect.x;\n          bRectWidth = calculatedBoundingRect.width;\n        }\n\n        if (bRectY == null) {\n          bRectY = calculatedBoundingRect.y;\n          bRectHeight = calculatedBoundingRect.height;\n        }\n      }\n\n      boundingRect = this._boundingRect = new BoundingRect(bRectX, bRectY, bRectWidth, bRectHeight);\n    }\n\n    if (viewBoxRect) {\n      var viewBoxTransform = makeViewBoxTransform(viewBoxRect, boundingRect); // Only support `preserveAspectRatio 'xMidYMid'`\n\n      rootFromParse.scaleX = rootFromParse.scaleY = viewBoxTransform.scale;\n      rootFromParse.x = viewBoxTransform.x;\n      rootFromParse.y = viewBoxTransform.y;\n    } // SVG needs to clip based on `viewBox`. And some SVG files really rely on this feature.\n    // They do not strictly confine all of the content inside a display rect, but deliberately\n    // use a `viewBox` to define a displayable rect.\n    // PENDING:\n    // The drawback of the `setClipPath` here is: the region label (genereted by echarts) near the\n    // edge might also be clipped, because region labels are put as `textContent` of the SVG path.\n\n\n    root.setClipPath(new Rect({\n      shape: boundingRect.plain()\n    }));\n    var named = [];\n    each(result.named, function (namedItem) {\n      if (REGION_AVAILABLE_SVG_TAG_MAP.get(namedItem.svgNodeTagLower) != null) {\n        named.push(namedItem);\n        setSilent(namedItem.el);\n      }\n    });\n    return {\n      root: root,\n      boundingRect: boundingRect,\n      named: named\n    };\n  };\n  /**\r\n   * Consider:\r\n   * (1) One graphic element can not be shared by different `geoView` running simultaneously.\r\n   *     Notice, also need to consider multiple echarts instances share a `mapRecord`.\r\n   * (2) Converting SVG to graphic elements is time consuming.\r\n   * (3) In the current architecture, `load` should be called frequently to get boundingRect,\r\n   *     and it is called without view info.\r\n   * So we maintain graphic elements in this module, and enables `view` to use/return these\r\n   * graphics from/to the pool with it's uid.\r\n   */\n\n\n  GeoSVGResource.prototype.useGraphic = function (hostKey\n  /*, nameMap: NameMap */\n  ) {\n    var usedRootMap = this._usedGraphicMap;\n    var svgGraphic = usedRootMap.get(hostKey);\n\n    if (svgGraphic) {\n      return svgGraphic;\n    }\n\n    svgGraphic = this._freedGraphics.pop() // use the first boundingRect to avoid duplicated boundingRect calculation.\n    || this._buildGraphic(this._parsedXML);\n    usedRootMap.set(hostKey, svgGraphic); // PENDING: `nameMap` will not be supported until some real requirement come.\n    // `nameMap` can only be obtained from echarts option.\n    // The original `named` must not be modified.\n    // if (nameMap) {\n    //     svgGraphic = extend({}, svgGraphic);\n    //     svgGraphic.named = applyNameMap(svgGraphic.named, nameMap);\n    // }\n\n    return svgGraphic;\n  };\n\n  GeoSVGResource.prototype.freeGraphic = function (hostKey) {\n    var usedRootMap = this._usedGraphicMap;\n    var svgGraphic = usedRootMap.get(hostKey);\n\n    if (svgGraphic) {\n      usedRootMap.removeKey(hostKey);\n\n      this._freedGraphics.push(svgGraphic);\n    }\n  };\n\n  return GeoSVGResource;\n}();\n\nexport { GeoSVGResource };\n\nfunction setSilent(el) {\n  // Only named element has silent: false, other elements should\n  // act as background and has no user interaction.\n  el.silent = false; // text|tspan will be converted to group.\n\n  if (el.isGroup) {\n    el.traverse(function (child) {\n      child.silent = false;\n    });\n  }\n}\n\nfunction createRegions(named) {\n  var regions = [];\n  var regionsMap = createHashMap(); // Create resions only for the first graphic.\n\n  each(named, function (namedItem) {\n    // Region has feature to calculate center for tooltip or other features.\n    // If there is a <g name=\"xxx\">, the center should be the center of the\n    // bounding rect of the g.\n    if (namedItem.namedFrom != null) {\n      return;\n    }\n\n    var region = new GeoSVGRegion(namedItem.name, namedItem.el); // PENDING: if `nameMap` supported, this region can not be mounted on\n    // `this`, but can only be created each time `load()` called.\n\n    regions.push(region); // PENDING: if multiple tag named with the same name, only one will be\n    // found by `_regionsMap`. `_regionsMap` is used to find a coordinate\n    // by name. We use `region.getCenter()` as the coordinate.\n\n    regionsMap.set(namedItem.name, region);\n  });\n  return {\n    regions: regions,\n    regionsMap: regionsMap\n  };\n} // PENDING: `nameMap` will not be supported until some real requirement come.\n// /**\n//  * Use the alias in geoNameMap.\n//  * The input `named` must not be modified.\n//  */\n// function applyNameMap(\n//     named: GeoSVGGraphicRecord['named'],\n//     nameMap: NameMap\n// ): GeoSVGGraphicRecord['named'] {\n//     const result = [] as GeoSVGGraphicRecord['named'];\n//     for (let i = 0; i < named.length; i++) {\n//         let regionGraphic = named[i];\n//         const name = regionGraphic.name;\n//         if (nameMap && nameMap.hasOwnProperty(name)) {\n//             regionGraphic = extend({}, regionGraphic);\n//             regionGraphic.name = name;\n//         }\n//         result.push(regionGraphic);\n//     }\n//     return result;\n// }","map":{"version":3,"sources":["D:/Work/WorkSpace/GitWorkSpace/TenShop/resource/ElectronicMall/src/qingge-Market/qingge-vue/node_modules/echarts/lib/coord/geo/GeoSVGResource.js"],"names":["parseSVG","makeViewBoxTransform","Group","Rect","assert","createHashMap","each","BoundingRect","parseXML","GeoSVGRegion","REGION_AVAILABLE_SVG_TAG_MAP","GeoSVGResource","mapName","svg","type","_usedGraphicMap","_freedGraphics","_mapName","_parsedXML","prototype","load","firstGraphic","_firstGraphic","_buildGraphic","push","_boundingRect","boundingRect","clone","_a","createRegions","named","regions","regionsMap","_regions","_regionsMap","svgXML","result","rootFromParse","ignoreViewBox","ignoreRootClip","root","e","Error","message","add","isGeoSVGGraphicRoot","svgWidth","width","svgHeight","height","viewBoxRect","bRectX","bRectY","bRectWidth","bRectHeight","x","y","calculatedBoundingRect","getBoundingRect","viewBoxTransform","scaleX","scaleY","scale","setClipPath","shape","plain","namedItem","get","svgNodeTagLower","setSilent","el","useGraphic","hostKey","usedRootMap","svgGraphic","pop","set","freeGraphic","removeKey","silent","isGroup","traverse","child","namedFrom","region","name"],"mappings":"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","sourcesContent":["\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n\r\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\nimport { parseSVG, makeViewBoxTransform } from 'zrender/lib/tool/parseSVG.js';\r\nimport Group from 'zrender/lib/graphic/Group.js';\r\nimport Rect from 'zrender/lib/graphic/shape/Rect.js';\r\nimport { assert, createHashMap, each } from 'zrender/lib/core/util.js';\r\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\r\nimport { parseXML } from 'zrender/lib/tool/parseXML.js';\r\nimport { GeoSVGRegion } from './Region.js';\r\n/**\r\n * \"region available\" means that: enable users to set attribute `name=\"xxx\"` on those tags\r\n * to make it be a region.\r\n * 1. region styles and its label styles can be defined in echarts opton:\r\n * ```js\r\n * geo: {\r\n *     regions: [{\r\n *         name: 'xxx',\r\n *         itemStyle: { ... },\r\n *         label: { ... }\r\n *     }, {\r\n *         ...\r\n *     },\r\n *     ...]\r\n * };\r\n * ```\r\n * 2. name can be duplicated in different SVG tag. All of the tags with the same name share\r\n * a region option. For exampel if there are two <path> representing two lung lobes. They have\r\n * no common parents but both of them need to display label \"lung\" inside.\r\n */\r\n\r\nvar REGION_AVAILABLE_SVG_TAG_MAP = createHashMap(['rect', 'circle', 'line', 'ellipse', 'polygon', 'polyline', 'path', // <text> <tspan> are also enabled becuase some SVG might paint text itself,\r\n// but still need to trigger events or tooltip.\r\n'text', 'tspan', // <g> is also enabled because this case: if multiple tags share one name\r\n// and need label displayed, every tags will display the name, which is not\r\n// expected. So we can put them into a <g name=\"xxx\">. Thereby only one label\r\n// displayed and located based on the bounding rect of the <g>.\r\n'g']);\r\n\r\nvar GeoSVGResource =\r\n/** @class */\r\nfunction () {\r\n  function GeoSVGResource(mapName, svg) {\r\n    this.type = 'geoSVG'; // All used graphics. key: hostKey, value: root\r\n\r\n    this._usedGraphicMap = createHashMap(); // All unused graphics.\r\n\r\n    this._freedGraphics = [];\r\n    this._mapName = mapName; // Only perform parse to XML object here, which might be time\r\n    // consiming for large SVG.\r\n    // Although convert XML to zrender element is also time consiming,\r\n    // if we do it here, the clone of zrender elements has to be\r\n    // required. So we do it once for each geo instance, util real\r\n    // performance issues call for optimizing it.\r\n\r\n    this._parsedXML = parseXML(svg);\r\n  }\r\n\r\n  GeoSVGResource.prototype.load = function ()\r\n  /* nameMap: NameMap */\r\n  {\r\n    // In the \"load\" stage, graphic need to be built to\r\n    // get boundingRect for geo coordinate system.\r\n    var firstGraphic = this._firstGraphic; // Create the return data structure only when first graphic created.\r\n    // Because they will be used in geo coordinate system update stage,\r\n    // and `regions` will be mounted at `geo` coordinate system,\r\n    // in which there is no \"view\" info, so that it should better not to\r\n    // make references to graphic elements.\r\n\r\n    if (!firstGraphic) {\r\n      firstGraphic = this._firstGraphic = this._buildGraphic(this._parsedXML);\r\n\r\n      this._freedGraphics.push(firstGraphic);\r\n\r\n      this._boundingRect = this._firstGraphic.boundingRect.clone(); // PENDING: `nameMap` will not be supported until some real requirement come.\r\n      // if (nameMap) {\r\n      //     named = applyNameMap(named, nameMap);\r\n      // }\r\n\r\n      var _a = createRegions(firstGraphic.named),\r\n          regions = _a.regions,\r\n          regionsMap = _a.regionsMap;\r\n\r\n      this._regions = regions;\r\n      this._regionsMap = regionsMap;\r\n    }\r\n\r\n    return {\r\n      boundingRect: this._boundingRect,\r\n      regions: this._regions,\r\n      regionsMap: this._regionsMap\r\n    };\r\n  };\r\n\r\n  GeoSVGResource.prototype._buildGraphic = function (svgXML) {\r\n    var result;\r\n    var rootFromParse;\r\n\r\n    try {\r\n      result = svgXML && parseSVG(svgXML, {\r\n        ignoreViewBox: true,\r\n        ignoreRootClip: true\r\n      }) || {};\r\n      rootFromParse = result.root;\r\n      assert(rootFromParse != null);\r\n    } catch (e) {\r\n      throw new Error('Invalid svg format\\n' + e.message);\r\n    } // Note: we keep the covenant that the root has no transform. So always add an extra root.\r\n\r\n\r\n    var root = new Group();\r\n    root.add(rootFromParse);\r\n    root.isGeoSVGGraphicRoot = true; // [THE_RULE_OF_VIEWPORT_AND_VIEWBOX]\r\n    //\r\n    // Consider: `<svg width=\"...\" height=\"...\" viewBox=\"...\">`\r\n    // - the `width/height` we call it `svgWidth/svgHeight` for short.\r\n    // - `(0, 0, svgWidth, svgHeight)` defines the viewport of the SVG, or say,\r\n    //   \"viewport boundingRect\", or `boundingRect` for short.\r\n    // - `viewBox` defines the transform from the real content ot the viewport.\r\n    //   `viewBox` has the same unit as the content of SVG.\r\n    //   If `viewBox` exists, a transform is defined, so the unit of `svgWidth/svgHeight` become\r\n    //   different from the content of SVG. Otherwise, they are the same.\r\n    //\r\n    // If both `svgWidth/svgHeight/viewBox` are specified in a SVG file, the transform rule will be:\r\n    // 0. `boundingRect` is `(0, 0, svgWidth, svgHeight)`. Set it to Geo['_rect'] (View['_rect']).\r\n    // 1. Make a transform from `viewBox` to `boundingRect`.\r\n    //    Note: only suport `preserveAspectRatio 'xMidYMid'` here. That is, this transform will preserve\r\n    //    the aspect ratio.\r\n    // 2. Make a transform from boundingRect to Geo['_viewRect'] (View['_viewRect'])\r\n    //    (`Geo`/`View` will do this job).\r\n    //    Note: this transform might not preserve aspect radio, which depending on how users specify\r\n    //    viewRect in echarts option (e.g., `geo.left/top/width/height` will not preserve aspect ratio,\r\n    //    but `geo.layoutCenter/layoutSize` will preserve aspect ratio).\r\n    //\r\n    // If `svgWidth/svgHeight` not specified, we use `viewBox` as the `boundingRect` to make the SVG\r\n    // layout look good.\r\n    //\r\n    // If neither `svgWidth/svgHeight` nor `viewBox` are not specified, we calculate the boundingRect\r\n    // of the SVG content and use them to make SVG layout look good.\r\n\r\n    var svgWidth = result.width;\r\n    var svgHeight = result.height;\r\n    var viewBoxRect = result.viewBoxRect;\r\n    var boundingRect = this._boundingRect;\r\n\r\n    if (!boundingRect) {\r\n      var bRectX = void 0;\r\n      var bRectY = void 0;\r\n      var bRectWidth = void 0;\r\n      var bRectHeight = void 0;\r\n\r\n      if (svgWidth != null) {\r\n        bRectX = 0;\r\n        bRectWidth = svgWidth;\r\n      } else if (viewBoxRect) {\r\n        bRectX = viewBoxRect.x;\r\n        bRectWidth = viewBoxRect.width;\r\n      }\r\n\r\n      if (svgHeight != null) {\r\n        bRectY = 0;\r\n        bRectHeight = svgHeight;\r\n      } else if (viewBoxRect) {\r\n        bRectY = viewBoxRect.y;\r\n        bRectHeight = viewBoxRect.height;\r\n      } // If both viewBox and svgWidth/svgHeight not specified,\r\n      // we have to determine how to layout those element to make them look good.\r\n\r\n\r\n      if (bRectX == null || bRectY == null) {\r\n        var calculatedBoundingRect = rootFromParse.getBoundingRect();\r\n\r\n        if (bRectX == null) {\r\n          bRectX = calculatedBoundingRect.x;\r\n          bRectWidth = calculatedBoundingRect.width;\r\n        }\r\n\r\n        if (bRectY == null) {\r\n          bRectY = calculatedBoundingRect.y;\r\n          bRectHeight = calculatedBoundingRect.height;\r\n        }\r\n      }\r\n\r\n      boundingRect = this._boundingRect = new BoundingRect(bRectX, bRectY, bRectWidth, bRectHeight);\r\n    }\r\n\r\n    if (viewBoxRect) {\r\n      var viewBoxTransform = makeViewBoxTransform(viewBoxRect, boundingRect); // Only support `preserveAspectRatio 'xMidYMid'`\r\n\r\n      rootFromParse.scaleX = rootFromParse.scaleY = viewBoxTransform.scale;\r\n      rootFromParse.x = viewBoxTransform.x;\r\n      rootFromParse.y = viewBoxTransform.y;\r\n    } // SVG needs to clip based on `viewBox`. And some SVG files really rely on this feature.\r\n    // They do not strictly confine all of the content inside a display rect, but deliberately\r\n    // use a `viewBox` to define a displayable rect.\r\n    // PENDING:\r\n    // The drawback of the `setClipPath` here is: the region label (genereted by echarts) near the\r\n    // edge might also be clipped, because region labels are put as `textContent` of the SVG path.\r\n\r\n\r\n    root.setClipPath(new Rect({\r\n      shape: boundingRect.plain()\r\n    }));\r\n    var named = [];\r\n    each(result.named, function (namedItem) {\r\n      if (REGION_AVAILABLE_SVG_TAG_MAP.get(namedItem.svgNodeTagLower) != null) {\r\n        named.push(namedItem);\r\n        setSilent(namedItem.el);\r\n      }\r\n    });\r\n    return {\r\n      root: root,\r\n      boundingRect: boundingRect,\r\n      named: named\r\n    };\r\n  };\r\n  /**\r\n   * Consider:\r\n   * (1) One graphic element can not be shared by different `geoView` running simultaneously.\r\n   *     Notice, also need to consider multiple echarts instances share a `mapRecord`.\r\n   * (2) Converting SVG to graphic elements is time consuming.\r\n   * (3) In the current architecture, `load` should be called frequently to get boundingRect,\r\n   *     and it is called without view info.\r\n   * So we maintain graphic elements in this module, and enables `view` to use/return these\r\n   * graphics from/to the pool with it's uid.\r\n   */\r\n\r\n\r\n  GeoSVGResource.prototype.useGraphic = function (hostKey\r\n  /*, nameMap: NameMap */\r\n  ) {\r\n    var usedRootMap = this._usedGraphicMap;\r\n    var svgGraphic = usedRootMap.get(hostKey);\r\n\r\n    if (svgGraphic) {\r\n      return svgGraphic;\r\n    }\r\n\r\n    svgGraphic = this._freedGraphics.pop() // use the first boundingRect to avoid duplicated boundingRect calculation.\r\n    || this._buildGraphic(this._parsedXML);\r\n    usedRootMap.set(hostKey, svgGraphic); // PENDING: `nameMap` will not be supported until some real requirement come.\r\n    // `nameMap` can only be obtained from echarts option.\r\n    // The original `named` must not be modified.\r\n    // if (nameMap) {\r\n    //     svgGraphic = extend({}, svgGraphic);\r\n    //     svgGraphic.named = applyNameMap(svgGraphic.named, nameMap);\r\n    // }\r\n\r\n    return svgGraphic;\r\n  };\r\n\r\n  GeoSVGResource.prototype.freeGraphic = function (hostKey) {\r\n    var usedRootMap = this._usedGraphicMap;\r\n    var svgGraphic = usedRootMap.get(hostKey);\r\n\r\n    if (svgGraphic) {\r\n      usedRootMap.removeKey(hostKey);\r\n\r\n      this._freedGraphics.push(svgGraphic);\r\n    }\r\n  };\r\n\r\n  return GeoSVGResource;\r\n}();\r\n\r\nexport { GeoSVGResource };\r\n\r\nfunction setSilent(el) {\r\n  // Only named element has silent: false, other elements should\r\n  // act as background and has no user interaction.\r\n  el.silent = false; // text|tspan will be converted to group.\r\n\r\n  if (el.isGroup) {\r\n    el.traverse(function (child) {\r\n      child.silent = false;\r\n    });\r\n  }\r\n}\r\n\r\nfunction createRegions(named) {\r\n  var regions = [];\r\n  var regionsMap = createHashMap(); // Create resions only for the first graphic.\r\n\r\n  each(named, function (namedItem) {\r\n    // Region has feature to calculate center for tooltip or other features.\r\n    // If there is a <g name=\"xxx\">, the center should be the center of the\r\n    // bounding rect of the g.\r\n    if (namedItem.namedFrom != null) {\r\n      return;\r\n    }\r\n\r\n    var region = new GeoSVGRegion(namedItem.name, namedItem.el); // PENDING: if `nameMap` supported, this region can not be mounted on\r\n    // `this`, but can only be created each time `load()` called.\r\n\r\n    regions.push(region); // PENDING: if multiple tag named with the same name, only one will be\r\n    // found by `_regionsMap`. `_regionsMap` is used to find a coordinate\r\n    // by name. We use `region.getCenter()` as the coordinate.\r\n\r\n    regionsMap.set(namedItem.name, region);\r\n  });\r\n  return {\r\n    regions: regions,\r\n    regionsMap: regionsMap\r\n  };\r\n} // PENDING: `nameMap` will not be supported until some real requirement come.\r\n// /**\r\n//  * Use the alias in geoNameMap.\r\n//  * The input `named` must not be modified.\r\n//  */\r\n// function applyNameMap(\r\n//     named: GeoSVGGraphicRecord['named'],\r\n//     nameMap: NameMap\r\n// ): GeoSVGGraphicRecord['named'] {\r\n//     const result = [] as GeoSVGGraphicRecord['named'];\r\n//     for (let i = 0; i < named.length; i++) {\r\n//         let regionGraphic = named[i];\r\n//         const name = regionGraphic.name;\r\n//         if (nameMap && nameMap.hasOwnProperty(name)) {\r\n//             regionGraphic = extend({}, regionGraphic);\r\n//             regionGraphic.name = name;\r\n//         }\r\n//         result.push(regionGraphic);\r\n//     }\r\n//     return result;\r\n// }"]},"metadata":{},"sourceType":"module"}