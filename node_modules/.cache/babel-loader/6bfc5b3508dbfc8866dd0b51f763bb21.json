{"ast":null,"code":"import \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.int32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.concat.js\";\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Int32Array */\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport Model from '../model/Model.js';\nimport DataDiffer from './DataDiffer.js';\nimport { DefaultDataProvider } from './helper/dataProvider.js';\nimport { summarizeDimensions } from './helper/dimensionHelper.js';\nimport SeriesDimensionDefine from './SeriesDimensionDefine.js';\nimport { SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ORIGINAL } from '../util/types.js';\nimport { convertOptionIdName, isDataItemOption } from '../util/model.js';\nimport { setCommonECData } from '../util/innerStore.js';\nimport { isSourceInstance } from './Source.js';\nimport DataStore from './DataStore.js';\nimport { isSeriesDataSchema } from './helper/SeriesDataSchema.js';\nvar isObject = zrUtil.isObject;\nvar map = zrUtil.map;\nvar CtorInt32Array = typeof Int32Array === 'undefined' ? Array : Int32Array; // Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird update animation.\n\nvar ID_PREFIX = 'e\\0\\0';\nvar INDEX_NOT_FOUND = -1; // type SeriesDimensionIndex = DimensionIndex;\n\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_dimSummary', 'userOutput', '_rawData', '_dimValueGetter', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount'];\nvar CLONE_PROPERTIES = ['_approximateExtent']; // -----------------------------\n// Internal method declarations:\n// -----------------------------\n\nvar prepareInvertedIndex;\nvar getId;\nvar getIdNameFromStore;\nvar normalizeDimensions;\nvar transferProperties;\nvar cloneListForMapAndSample;\nvar makeIdFromName;\n\nvar SeriesData =\n/** @class */\nfunction () {\n  /**\n   * @param dimensionsInput.dimensions\n   *        For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n   *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n   */\n  function SeriesData(dimensionsInput, hostModel) {\n    this.type = 'list';\n    this._dimOmitted = false;\n    this._nameList = [];\n    this._idList = []; // Models of data option is stored sparse for optimizing memory cost\n    // Never used yet (not used yet).\n    // private _optionModels: Model[] = [];\n    // Global visual properties after visual coding\n\n    this._visual = {}; // Global layout properties.\n\n    this._layout = {}; // Item visual properties after visual coding\n\n    this._itemVisuals = []; // Item layout properties after layout\n\n    this._itemLayouts = []; // Graphic elements\n\n    this._graphicEls = []; // key: dim, value: extent\n\n    this._approximateExtent = {};\n    this._calculationInfo = {}; // Having detected that there is data item is non primitive type\n    // (in type `OptionDataItemObject`).\n    // Like `data: [ { value: xx, itemStyle: {...} }, ...]`\n    // At present it only happen in `SOURCE_FORMAT_ORIGINAL`.\n\n    this.hasItemOption = false; // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n\n    this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map']; // Methods that change indices of this list should be listed here.\n\n    this.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\n    this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample'];\n    var dimensions;\n    var assignStoreDimIdx = false;\n\n    if (isSeriesDataSchema(dimensionsInput)) {\n      dimensions = dimensionsInput.dimensions;\n      this._dimOmitted = dimensionsInput.isDimensionOmitted();\n      this._schema = dimensionsInput;\n    } else {\n      assignStoreDimIdx = true;\n      dimensions = dimensionsInput;\n    }\n\n    dimensions = dimensions || ['x', 'y'];\n    var dimensionInfos = {};\n    var dimensionNames = [];\n    var invertedIndicesMap = {};\n    var needsHasOwn = false;\n    var emptyObj = {};\n\n    for (var i = 0; i < dimensions.length; i++) {\n      // Use the original dimensions[i], where other flag props may exists.\n      var dimInfoInput = dimensions[i];\n      var dimensionInfo = zrUtil.isString(dimInfoInput) ? new SeriesDimensionDefine({\n        name: dimInfoInput\n      }) : !(dimInfoInput instanceof SeriesDimensionDefine) ? new SeriesDimensionDefine(dimInfoInput) : dimInfoInput;\n      var dimensionName = dimensionInfo.name;\n      dimensionInfo.type = dimensionInfo.type || 'float';\n\n      if (!dimensionInfo.coordDim) {\n        dimensionInfo.coordDim = dimensionName;\n        dimensionInfo.coordDimIndex = 0;\n      }\n\n      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n      dimensionNames.push(dimensionName);\n      dimensionInfos[dimensionName] = dimensionInfo;\n\n      if (emptyObj[dimensionName] != null) {\n        needsHasOwn = true;\n      }\n\n      if (dimensionInfo.createInvertedIndices) {\n        invertedIndicesMap[dimensionName] = [];\n      }\n\n      if (otherDims.itemName === 0) {\n        this._nameDimIdx = i;\n      }\n\n      if (otherDims.itemId === 0) {\n        this._idDimIdx = i;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        zrUtil.assert(assignStoreDimIdx || dimensionInfo.storeDimIndex >= 0);\n      }\n\n      if (assignStoreDimIdx) {\n        dimensionInfo.storeDimIndex = i;\n      }\n    }\n\n    this.dimensions = dimensionNames;\n    this._dimInfos = dimensionInfos;\n\n    this._initGetDimensionInfo(needsHasOwn);\n\n    this.hostModel = hostModel;\n    this._invertedIndicesMap = invertedIndicesMap;\n\n    if (this._dimOmitted) {\n      var dimIdxToName_1 = this._dimIdxToName = zrUtil.createHashMap();\n      zrUtil.each(dimensionNames, function (dimName) {\n        dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);\n      });\n    }\n  }\n  /**\n   *\n   * Get concrete dimension name by dimension name or dimension index.\n   * If input a dimension name, do not validate whether the dimension name exits.\n   *\n   * @caution\n   * @param dim Must make sure the dimension is `SeriesDimensionLoose`.\n   * Because only those dimensions will have auto-generated dimension names if not\n   * have a user-specified name, and other dimensions will get a return of null/undefined.\n   *\n   * @notice Because of this reason, should better use `getDimensionIndex` instead, for examples:\n   * ```js\n   * const val = data.getStore().get(data.getDimensionIndex(dim), dataIdx);\n   * ```\n   *\n   * @return Concrete dim name.\n   */\n\n\n  SeriesData.prototype.getDimension = function (dim) {\n    var dimIdx = this._recognizeDimIndex(dim);\n\n    if (dimIdx == null) {\n      return dim;\n    }\n\n    dimIdx = dim;\n\n    if (!this._dimOmitted) {\n      return this.dimensions[dimIdx];\n    } // Retrieve from series dimension definition because it probably contains\n    // generated dimension name (like 'x', 'y').\n\n\n    var dimName = this._dimIdxToName.get(dimIdx);\n\n    if (dimName != null) {\n      return dimName;\n    }\n\n    var sourceDimDef = this._schema.getSourceDimension(dimIdx);\n\n    if (sourceDimDef) {\n      return sourceDimDef.name;\n    }\n  };\n  /**\n   * Get dimension index in data store. Return -1 if not found.\n   * Can be used to index value from getRawValue.\n   */\n\n\n  SeriesData.prototype.getDimensionIndex = function (dim) {\n    var dimIdx = this._recognizeDimIndex(dim);\n\n    if (dimIdx != null) {\n      return dimIdx;\n    }\n\n    if (dim == null) {\n      return -1;\n    }\n\n    var dimInfo = this._getDimInfo(dim);\n\n    return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;\n  };\n  /**\n   * The meanings of the input parameter `dim`:\n   *\n   * + If dim is a number (e.g., `1`), it means the index of the dimension.\n   *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.\n   * + If dim is a number-like string (e.g., `\"1\"`):\n   *     + If there is the same concrete dim name defined in `series.dimensions` or `dataset.dimensions`,\n   *        it means that concrete name.\n   *     + If not, it will be converted to a number, which means the index of the dimension.\n   *        (why? because of the backward compatibility. We have been tolerating number-like string in\n   *        dimension setting, although now it seems that it is not a good idea.)\n   *     For example, `visualMap[i].dimension: \"1\"` is the same meaning as `visualMap[i].dimension: 1`,\n   *     if no dimension name is defined as `\"1\"`.\n   * + If dim is a not-number-like string, it means the concrete dim name.\n   *   For example, it can be be default name `\"x\"`, `\"y\"`, `\"z\"`, `\"lng\"`, `\"lat\"`, `\"angle\"`, `\"radius\"`,\n   *   or customized in `dimensions` property of option like `\"age\"`.\n   *\n   * @return recognized `DimensionIndex`. Otherwise return null/undefined (means that dim is `DimensionName`).\n   */\n\n\n  SeriesData.prototype._recognizeDimIndex = function (dim) {\n    if (zrUtil.isNumber(dim) // If being a number-like string but not being defined as a dimension name.\n    || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {\n      return +dim;\n    }\n  };\n\n  SeriesData.prototype._getStoreDimIndex = function (dim) {\n    var dimIdx = this.getDimensionIndex(dim);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (dimIdx == null) {\n        throw new Error('Unknown dimension ' + dim);\n      }\n    }\n\n    return dimIdx;\n  };\n  /**\n   * Get type and calculation info of particular dimension\n   * @param dim\n   *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n   *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n   */\n\n\n  SeriesData.prototype.getDimensionInfo = function (dim) {\n    // Do not clone, because there may be categories in dimInfo.\n    return this._getDimInfo(this.getDimension(dim));\n  };\n\n  SeriesData.prototype._initGetDimensionInfo = function (needsHasOwn) {\n    var dimensionInfos = this._dimInfos;\n    this._getDimInfo = needsHasOwn ? function (dimName) {\n      return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : undefined;\n    } : function (dimName) {\n      return dimensionInfos[dimName];\n    };\n  };\n  /**\n   * concrete dimension name list on coord.\n   */\n\n\n  SeriesData.prototype.getDimensionsOnCoord = function () {\n    return this._dimSummary.dataDimsOnCoord.slice();\n  };\n\n  SeriesData.prototype.mapDimension = function (coordDim, idx) {\n    var dimensionsSummary = this._dimSummary;\n\n    if (idx == null) {\n      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n    }\n\n    var dims = dimensionsSummary.encode[coordDim];\n    return dims ? dims[idx] : null;\n  };\n\n  SeriesData.prototype.mapDimensionsAll = function (coordDim) {\n    var dimensionsSummary = this._dimSummary;\n    var dims = dimensionsSummary.encode[coordDim];\n    return (dims || []).slice();\n  };\n\n  SeriesData.prototype.getStore = function () {\n    return this._store;\n  };\n  /**\n   * Initialize from data\n   * @param data source or data or data store.\n   * @param nameList The name of a datum is used on data diff and\n   *        default label/tooltip.\n   *        A name can be specified in encode.itemName,\n   *        or dataItem.name (only for series option data),\n   *        or provided in nameList from outside.\n   */\n\n\n  SeriesData.prototype.initData = function (data, nameList, dimValueGetter) {\n    var _this = this;\n\n    var store;\n\n    if (data instanceof DataStore) {\n      store = data;\n    }\n\n    if (!store) {\n      var dimensions = this.dimensions;\n      var provider = isSourceInstance(data) || zrUtil.isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data;\n      store = new DataStore();\n      var dimensionInfos = map(dimensions, function (dimName) {\n        return {\n          type: _this._dimInfos[dimName].type,\n          property: dimName\n        };\n      });\n      store.initData(provider, dimensionInfos, dimValueGetter);\n    }\n\n    this._store = store; // Reset\n\n    this._nameList = (nameList || []).slice();\n    this._idList = [];\n    this._nameRepeatCount = {};\n\n    this._doInit(0, store.count()); // Cache summary info for fast visit. See \"dimensionHelper\".\n    // Needs to be initialized after store is prepared.\n\n\n    this._dimSummary = summarizeDimensions(this, this._schema);\n    this.userOutput = this._dimSummary.userOutput;\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   */\n\n\n  SeriesData.prototype.appendData = function (data) {\n    var range = this._store.appendData(data);\n\n    this._doInit(range[0], range[1]);\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   * This method does not modify `rawData` (`dataProvider`), but only\n   * add values to store.\n   *\n   * The final count will be increased by `Math.max(values.length, names.length)`.\n   *\n   * @param values That is the SourceType: 'arrayRows', like\n   *        [\n   *            [12, 33, 44],\n   *            [NaN, 43, 1],\n   *            ['-', 'asdf', 0]\n   *        ]\n   *        Each item is exactly corresponding to a dimension.\n   */\n\n\n  SeriesData.prototype.appendValues = function (values, names) {\n    var _a = this._store.appendValues(values, names.length),\n        start = _a.start,\n        end = _a.end;\n\n    var shouldMakeIdFromName = this._shouldMakeIdFromName();\n\n    this._updateOrdinalMeta();\n\n    if (names) {\n      for (var idx = start; idx < end; idx++) {\n        var sourceIdx = idx - start;\n        this._nameList[idx] = names[sourceIdx];\n\n        if (shouldMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n  };\n\n  SeriesData.prototype._updateOrdinalMeta = function () {\n    var store = this._store;\n    var dimensions = this.dimensions;\n\n    for (var i = 0; i < dimensions.length; i++) {\n      var dimInfo = this._dimInfos[dimensions[i]];\n\n      if (dimInfo.ordinalMeta) {\n        store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);\n      }\n    }\n  };\n\n  SeriesData.prototype._shouldMakeIdFromName = function () {\n    var provider = this._store.getProvider();\n\n    return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;\n  };\n\n  SeriesData.prototype._doInit = function (start, end) {\n    if (start >= end) {\n      return;\n    }\n\n    var store = this._store;\n    var provider = store.getProvider();\n\n    this._updateOrdinalMeta();\n\n    var nameList = this._nameList;\n    var idList = this._idList;\n    var sourceFormat = provider.getSource().sourceFormat;\n    var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL; // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of category\n    // Use a tempValue to normalize the value to be a (x, y) value\n    // If dataItem is {name: ...} or {id: ...}, it has highest priority.\n    // This kind of ids and names are always stored `_nameList` and `_idList`.\n\n    if (isFormatOriginal && !provider.pure) {\n      var sharedDataItem = [];\n\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        var dataItem = provider.getItem(idx, sharedDataItem);\n\n        if (!this.hasItemOption && isDataItemOption(dataItem)) {\n          this.hasItemOption = true;\n        }\n\n        if (dataItem) {\n          var itemName = dataItem.name;\n\n          if (nameList[idx] == null && itemName != null) {\n            nameList[idx] = convertOptionIdName(itemName, null);\n          }\n\n          var itemId = dataItem.id;\n\n          if (idList[idx] == null && itemId != null) {\n            idList[idx] = convertOptionIdName(itemId, null);\n          }\n        }\n      }\n    }\n\n    if (this._shouldMakeIdFromName()) {\n      for (var idx = start; idx < end; idx++) {\n        makeIdFromName(this, idx);\n      }\n    }\n\n    prepareInvertedIndex(this);\n  };\n  /**\n   * PENDING: In fact currently this function is only used to short-circuit\n   * the calling of `scale.unionExtentFromData` when data have been filtered by modules\n   * like \"dataZoom\". `scale.unionExtentFromData` is used to calculate data extent for series on\n   * an axis, but if a \"axis related data filter module\" is used, the extent of the axis have\n   * been fixed and no need to calling `scale.unionExtentFromData` actually.\n   * But if we add \"custom data filter\" in future, which is not \"axis related\", this method may\n   * be still needed.\n   *\n   * Optimize for the scenario that data is filtered by a given extent.\n   * Consider that if data amount is more than hundreds of thousand,\n   * extent calculation will cost more than 10ms and the cache will\n   * be erased because of the filtering.\n   */\n\n\n  SeriesData.prototype.getApproximateExtent = function (dim) {\n    return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));\n  };\n  /**\n   * Calculate extent on a filtered data might be time consuming.\n   * Approximate extent is only used for: calculate extent of filtered data outside.\n   */\n\n\n  SeriesData.prototype.setApproximateExtent = function (extent, dim) {\n    dim = this.getDimension(dim);\n    this._approximateExtent[dim] = extent.slice();\n  };\n\n  SeriesData.prototype.getCalculationInfo = function (key) {\n    return this._calculationInfo[key];\n  };\n\n  SeriesData.prototype.setCalculationInfo = function (key, value) {\n    isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n  };\n  /**\n   * @return Never be null/undefined. `number` will be converted to string. Because:\n   * In most cases, name is used in display, where returning a string is more convenient.\n   * In other cases, name is used in query (see `indexOfName`), where we can keep the\n   * rule that name `2` equals to name `'2'`.\n   */\n\n\n  SeriesData.prototype.getName = function (idx) {\n    var rawIndex = this.getRawIndex(idx);\n    var name = this._nameList[rawIndex];\n\n    if (name == null && this._nameDimIdx != null) {\n      name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);\n    }\n\n    if (name == null) {\n      name = '';\n    }\n\n    return name;\n  };\n\n  SeriesData.prototype._getCategory = function (dimIdx, idx) {\n    var ordinal = this._store.get(dimIdx, idx);\n\n    var ordinalMeta = this._store.getOrdinalMeta(dimIdx);\n\n    if (ordinalMeta) {\n      return ordinalMeta.categories[ordinal];\n    }\n\n    return ordinal;\n  };\n  /**\n   * @return Never null/undefined. `number` will be converted to string. Because:\n   * In all cases having encountered at present, id is used in making diff comparison, which\n   * are usually based on hash map. We can keep the rule that the internal id are always string\n   * (treat `2` is the same as `'2'`) to make the related logic simple.\n   */\n\n\n  SeriesData.prototype.getId = function (idx) {\n    return getId(this, this.getRawIndex(idx));\n  };\n\n  SeriesData.prototype.count = function () {\n    return this._store.count();\n  };\n  /**\n   * Get value. Return NaN if idx is out of range.\n   *\n   * @notice Should better to use `data.getStore().get(dimIndex, dataIdx)` instead.\n   */\n\n\n  SeriesData.prototype.get = function (dim, idx) {\n    var store = this._store;\n    var dimInfo = this._dimInfos[dim];\n\n    if (dimInfo) {\n      return store.get(dimInfo.storeDimIndex, idx);\n    }\n  };\n  /**\n   * @notice Should better to use `data.getStore().getByRawIndex(dimIndex, dataIdx)` instead.\n   */\n\n\n  SeriesData.prototype.getByRawIndex = function (dim, rawIdx) {\n    var store = this._store;\n    var dimInfo = this._dimInfos[dim];\n\n    if (dimInfo) {\n      return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);\n    }\n  };\n\n  SeriesData.prototype.getIndices = function () {\n    return this._store.getIndices();\n  };\n\n  SeriesData.prototype.getDataExtent = function (dim) {\n    return this._store.getDataExtent(this._getStoreDimIndex(dim));\n  };\n\n  SeriesData.prototype.getSum = function (dim) {\n    return this._store.getSum(this._getStoreDimIndex(dim));\n  };\n\n  SeriesData.prototype.getMedian = function (dim) {\n    return this._store.getMedian(this._getStoreDimIndex(dim));\n  };\n\n  SeriesData.prototype.getValues = function (dimensions, idx) {\n    var _this = this;\n\n    var store = this._store;\n    return zrUtil.isArray(dimensions) ? store.getValues(map(dimensions, function (dim) {\n      return _this._getStoreDimIndex(dim);\n    }), idx) : store.getValues(dimensions);\n  };\n  /**\n   * If value is NaN. Including '-'\n   * Only check the coord dimensions.\n   */\n\n\n  SeriesData.prototype.hasValue = function (idx) {\n    var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;\n\n    for (var i = 0, len = dataDimIndicesOnCoord.length; i < len; i++) {\n      // Ordinal type originally can be string or number.\n      // But when an ordinal type is used on coord, it can\n      // not be string but only number. So we can also use isNaN.\n      if (isNaN(this._store.get(dataDimIndicesOnCoord[i], idx))) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Retrieve the index with given name\n   */\n\n\n  SeriesData.prototype.indexOfName = function (name) {\n    for (var i = 0, len = this._store.count(); i < len; i++) {\n      if (this.getName(i) === name) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  SeriesData.prototype.getRawIndex = function (idx) {\n    return this._store.getRawIndex(idx);\n  };\n\n  SeriesData.prototype.indexOfRawIndex = function (rawIndex) {\n    return this._store.indexOfRawIndex(rawIndex);\n  };\n  /**\n   * Only support the dimension which inverted index created.\n   * Do not support other cases until required.\n   * @param dim concrete dim\n   * @param value ordinal index\n   * @return rawIndex\n   */\n\n\n  SeriesData.prototype.rawIndexOf = function (dim, value) {\n    var invertedIndices = dim && this._invertedIndicesMap[dim];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!invertedIndices) {\n        throw new Error('Do not supported yet');\n      }\n    }\n\n    var rawIndex = invertedIndices[value];\n\n    if (rawIndex == null || isNaN(rawIndex)) {\n      return INDEX_NOT_FOUND;\n    }\n\n    return rawIndex;\n  };\n  /**\n   * Retrieve the index of nearest value\n   * @param dim\n   * @param value\n   * @param [maxDistance=Infinity]\n   * @return If and only if multiple indices has\n   *         the same value, they are put to the result.\n   */\n\n\n  SeriesData.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    return this._store.indicesOfNearest(this._getStoreDimIndex(dim), value, maxDistance);\n  };\n\n  SeriesData.prototype.each = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n\n    var fCtx = ctx || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n\n    this._store.each(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n  };\n\n  SeriesData.prototype.filterSelf = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n\n    var fCtx = ctx || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    this._store = this._store.filter(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n    return this;\n  };\n  /**\n   * Select data in range. (For optimization of filter)\n   * (Manually inline code, support 5 million data filtering in data zoom.)\n   */\n\n\n  SeriesData.prototype.selectRange = function (range) {\n    'use strict';\n\n    var _this = this;\n\n    var innerRange = {};\n    var dims = zrUtil.keys(range);\n    var dimIndices = [];\n    zrUtil.each(dims, function (dim) {\n      var dimIdx = _this._getStoreDimIndex(dim);\n\n      innerRange[dimIdx] = range[dim];\n      dimIndices.push(dimIdx);\n    });\n    this._store = this._store.selectRange(innerRange);\n    return this;\n  };\n  /* eslint-enable max-len */\n\n\n  SeriesData.prototype.mapArray = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n\n    ctx = ctx || this;\n    var result = [];\n    this.each(dims, function () {\n      result.push(cb && cb.apply(this, arguments));\n    }, ctx);\n    return result;\n  };\n\n  SeriesData.prototype.map = function (dims, cb, ctx, ctxCompat) {\n    'use strict'; // ctxCompat just for compat echarts3\n\n    var fCtx = ctx || ctxCompat || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.map(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n    return list;\n  };\n\n  SeriesData.prototype.modify = function (dims, cb, ctx, ctxCompat) {\n    var _this = this; // ctxCompat just for compat echarts3\n\n\n    var fCtx = ctx || ctxCompat || this;\n\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.each(normalizeDimensions(dims), function (dim) {\n        var dimInfo = _this.getDimensionInfo(dim);\n\n        if (!dimInfo.isCalculationCoord) {\n          console.error('Danger: only stack dimension can be modified');\n        }\n      });\n    }\n\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this); // If do shallow clone here, if there are too many stacked series,\n    // it still cost lots of memory, because `_store.dimensions` are not shared.\n    // We should consider there probably be shallow clone happen in each series\n    // in consequent filter/map.\n\n    this._store.modify(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n  };\n  /**\n   * Large data down sampling on given dimension\n   * @param sampleIndex Sample index for name and id\n   */\n\n\n  SeriesData.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);\n    return list;\n  };\n  /**\n   * Large data down sampling using largest-triangle-three-buckets\n   * @param {string} valueDimension\n   * @param {number} targetCount\n   */\n\n\n  SeriesData.prototype.lttbDownSample = function (valueDimension, rate) {\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);\n    return list;\n  };\n\n  SeriesData.prototype.getRawDataItem = function (idx) {\n    return this._store.getRawDataItem(idx);\n  };\n  /**\n   * Get model of one data item.\n   */\n  // TODO: Type of data item\n\n\n  SeriesData.prototype.getItemModel = function (idx) {\n    var hostModel = this.hostModel;\n    var dataItem = this.getRawDataItem(idx);\n    return new Model(dataItem, hostModel, hostModel && hostModel.ecModel);\n  };\n  /**\n   * Create a data differ\n   */\n\n\n  SeriesData.prototype.diff = function (otherList) {\n    var thisList = this;\n    return new DataDiffer(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function (idx) {\n      return getId(otherList, idx);\n    }, function (idx) {\n      return getId(thisList, idx);\n    });\n  };\n  /**\n   * Get visual property.\n   */\n\n\n  SeriesData.prototype.getVisual = function (key) {\n    var visual = this._visual;\n    return visual && visual[key];\n  };\n\n  SeriesData.prototype.setVisual = function (kvObj, val) {\n    this._visual = this._visual || {};\n\n    if (isObject(kvObj)) {\n      zrUtil.extend(this._visual, kvObj);\n    } else {\n      this._visual[kvObj] = val;\n    }\n  };\n  /**\n   * Get visual property of single data item\n   */\n  // eslint-disable-next-line\n\n\n  SeriesData.prototype.getItemVisual = function (idx, key) {\n    var itemVisual = this._itemVisuals[idx];\n    var val = itemVisual && itemVisual[key];\n\n    if (val == null) {\n      // Use global visual property\n      return this.getVisual(key);\n    }\n\n    return val;\n  };\n  /**\n   * If exists visual property of single data item\n   */\n\n\n  SeriesData.prototype.hasItemVisual = function () {\n    return this._itemVisuals.length > 0;\n  };\n  /**\n   * Make sure itemVisual property is unique\n   */\n  // TODO: use key to save visual to reduce memory.\n\n\n  SeriesData.prototype.ensureUniqueItemVisual = function (idx, key) {\n    var itemVisuals = this._itemVisuals;\n    var itemVisual = itemVisuals[idx];\n\n    if (!itemVisual) {\n      itemVisual = itemVisuals[idx] = {};\n    }\n\n    var val = itemVisual[key];\n\n    if (val == null) {\n      val = this.getVisual(key); // TODO Performance?\n\n      if (zrUtil.isArray(val)) {\n        val = val.slice();\n      } else if (isObject(val)) {\n        val = zrUtil.extend({}, val);\n      }\n\n      itemVisual[key] = val;\n    }\n\n    return val;\n  }; // eslint-disable-next-line\n\n\n  SeriesData.prototype.setItemVisual = function (idx, key, value) {\n    var itemVisual = this._itemVisuals[idx] || {};\n    this._itemVisuals[idx] = itemVisual;\n\n    if (isObject(key)) {\n      zrUtil.extend(itemVisual, key);\n    } else {\n      itemVisual[key] = value;\n    }\n  };\n  /**\n   * Clear itemVisuals and list visual.\n   */\n\n\n  SeriesData.prototype.clearAllVisual = function () {\n    this._visual = {};\n    this._itemVisuals = [];\n  };\n\n  SeriesData.prototype.setLayout = function (key, val) {\n    isObject(key) ? zrUtil.extend(this._layout, key) : this._layout[key] = val;\n  };\n  /**\n   * Get layout property.\n   */\n\n\n  SeriesData.prototype.getLayout = function (key) {\n    return this._layout[key];\n  };\n  /**\n   * Get layout of single data item\n   */\n\n\n  SeriesData.prototype.getItemLayout = function (idx) {\n    return this._itemLayouts[idx];\n  };\n  /**\n   * Set layout of single data item\n   */\n\n\n  SeriesData.prototype.setItemLayout = function (idx, layout, merge) {\n    this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n  };\n  /**\n   * Clear all layout of single data item\n   */\n\n\n  SeriesData.prototype.clearItemLayouts = function () {\n    this._itemLayouts.length = 0;\n  };\n  /**\n   * Set graphic element relative to data. It can be set as null\n   */\n\n\n  SeriesData.prototype.setItemGraphicEl = function (idx, el) {\n    var seriesIndex = this.hostModel && this.hostModel.seriesIndex;\n    setCommonECData(seriesIndex, this.dataType, idx, el);\n    this._graphicEls[idx] = el;\n  };\n\n  SeriesData.prototype.getItemGraphicEl = function (idx) {\n    return this._graphicEls[idx];\n  };\n\n  SeriesData.prototype.eachItemGraphicEl = function (cb, context) {\n    zrUtil.each(this._graphicEls, function (el, idx) {\n      if (el) {\n        cb && cb.call(context, el, idx);\n      }\n    });\n  };\n  /**\n   * Shallow clone a new list except visual and layout properties, and graph elements.\n   * New list only change the indices.\n   */\n\n\n  SeriesData.prototype.cloneShallow = function (list) {\n    if (!list) {\n      list = new SeriesData(this._schema ? this._schema : map(this.dimensions, this._getDimInfo, this), this.hostModel);\n    }\n\n    transferProperties(list, this);\n    list._store = this._store;\n    return list;\n  };\n  /**\n   * Wrap some method to add more feature\n   */\n\n\n  SeriesData.prototype.wrapMethod = function (methodName, injectFunction) {\n    var originalMethod = this[methodName];\n\n    if (!zrUtil.isFunction(originalMethod)) {\n      return;\n    }\n\n    this.__wrappedMethods = this.__wrappedMethods || [];\n\n    this.__wrappedMethods.push(methodName);\n\n    this[methodName] = function () {\n      var res = originalMethod.apply(this, arguments);\n      return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n    };\n  }; // ----------------------------------------------------------\n  // A work around for internal method visiting private member.\n  // ----------------------------------------------------------\n\n\n  SeriesData.internalField = function () {\n    prepareInvertedIndex = function prepareInvertedIndex(data) {\n      var invertedIndicesMap = data._invertedIndicesMap;\n      zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n        var dimInfo = data._dimInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.\n\n        var ordinalMeta = dimInfo.ordinalMeta;\n        var store = data._store;\n\n        if (ordinalMeta) {\n          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss\n          // mapping to 0, we should set it as INDEX_NOT_FOUND.\n\n          for (var i = 0; i < invertedIndices.length; i++) {\n            invertedIndices[i] = INDEX_NOT_FOUND;\n          }\n\n          for (var i = 0; i < store.count(); i++) {\n            // Only support the case that all values are distinct.\n            invertedIndices[store.get(dimInfo.storeDimIndex, i)] = i;\n          }\n        }\n      });\n    };\n\n    getIdNameFromStore = function getIdNameFromStore(data, dimIdx, idx) {\n      return convertOptionIdName(data._getCategory(dimIdx, idx), null);\n    };\n    /**\n     * @see the comment of `List['getId']`.\n     */\n\n\n    getId = function getId(data, rawIndex) {\n      var id = data._idList[rawIndex];\n\n      if (id == null && data._idDimIdx != null) {\n        id = getIdNameFromStore(data, data._idDimIdx, rawIndex);\n      }\n\n      if (id == null) {\n        id = ID_PREFIX + rawIndex;\n      }\n\n      return id;\n    };\n\n    normalizeDimensions = function normalizeDimensions(dimensions) {\n      if (!zrUtil.isArray(dimensions)) {\n        dimensions = dimensions != null ? [dimensions] : [];\n      }\n\n      return dimensions;\n    };\n    /**\n     * Data in excludeDimensions is copied, otherwise transferred.\n     */\n\n\n    cloneListForMapAndSample = function cloneListForMapAndSample(original) {\n      var list = new SeriesData(original._schema ? original._schema : map(original.dimensions, original._getDimInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n      transferProperties(list, original);\n      return list;\n    };\n\n    transferProperties = function transferProperties(target, source) {\n      zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n        if (source.hasOwnProperty(propName)) {\n          target[propName] = source[propName];\n        }\n      });\n      target.__wrappedMethods = source.__wrappedMethods;\n      zrUtil.each(CLONE_PROPERTIES, function (propName) {\n        target[propName] = zrUtil.clone(source[propName]);\n      });\n      target._calculationInfo = zrUtil.extend({}, source._calculationInfo);\n    };\n\n    makeIdFromName = function makeIdFromName(data, idx) {\n      var nameList = data._nameList;\n      var idList = data._idList;\n      var nameDimIdx = data._nameDimIdx;\n      var idDimIdx = data._idDimIdx;\n      var name = nameList[idx];\n      var id = idList[idx];\n\n      if (name == null && nameDimIdx != null) {\n        nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);\n      }\n\n      if (id == null && idDimIdx != null) {\n        idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);\n      }\n\n      if (id == null && name != null) {\n        var nameRepeatCount = data._nameRepeatCount;\n        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;\n        id = name;\n\n        if (nmCnt > 1) {\n          id += '__ec__' + nmCnt;\n        }\n\n        idList[idx] = id;\n      }\n    };\n  }();\n\n  return SeriesData;\n}();\n\nexport default SeriesData;","map":{"version":3,"sources":["/home/rayce/Udatabase/study/ElectronicMall/ElectronicMallVue/node_modules/echarts/lib/data/SeriesData.js"],"names":["zrUtil","Model","DataDiffer","DefaultDataProvider","summarizeDimensions","SeriesDimensionDefine","SOURCE_FORMAT_TYPED_ARRAY","SOURCE_FORMAT_ORIGINAL","convertOptionIdName","isDataItemOption","setCommonECData","isSourceInstance","DataStore","isSeriesDataSchema","isObject","map","CtorInt32Array","Int32Array","Array","ID_PREFIX","INDEX_NOT_FOUND","TRANSFERABLE_PROPERTIES","CLONE_PROPERTIES","prepareInvertedIndex","getId","getIdNameFromStore","normalizeDimensions","transferProperties","cloneListForMapAndSample","makeIdFromName","SeriesData","dimensionsInput","hostModel","type","_dimOmitted","_nameList","_idList","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_approximateExtent","_calculationInfo","hasItemOption","TRANSFERABLE_METHODS","CHANGABLE_METHODS","DOWNSAMPLE_METHODS","dimensions","assignStoreDimIdx","isDimensionOmitted","_schema","dimensionInfos","dimensionNames","invertedIndicesMap","needsHasOwn","emptyObj","i","length","dimInfoInput","dimensionInfo","isString","name","dimensionName","coordDim","coordDimIndex","otherDims","push","createInvertedIndices","itemName","_nameDimIdx","itemId","_idDimIdx","process","env","NODE_ENV","assert","storeDimIndex","_dimInfos","_initGetDimensionInfo","_invertedIndicesMap","dimIdxToName_1","_dimIdxToName","createHashMap","each","dimName","set","prototype","getDimension","dim","dimIdx","_recognizeDimIndex","get","sourceDimDef","getSourceDimension","getDimensionIndex","dimInfo","_getDimInfo","getSourceDimensionIndex","isNumber","isNaN","_getStoreDimIndex","Error","getDimensionInfo","hasOwnProperty","undefined","getDimensionsOnCoord","_dimSummary","dataDimsOnCoord","slice","mapDimension","idx","dimensionsSummary","encodeFirstDimNotExtra","dims","encode","mapDimensionsAll","getStore","_store","initData","data","nameList","dimValueGetter","_this","store","provider","isArrayLike","property","_nameRepeatCount","_doInit","count","userOutput","appendData","range","appendValues","values","names","_a","start","end","shouldMakeIdFromName","_shouldMakeIdFromName","_updateOrdinalMeta","sourceIdx","ordinalMeta","collectOrdinalMeta","getProvider","getSource","sourceFormat","fillStorage","idList","isFormatOriginal","pure","sharedDataItem","dataItem","getItem","id","getApproximateExtent","getDataExtent","setApproximateExtent","extent","getCalculationInfo","key","setCalculationInfo","value","extend","getName","rawIndex","getRawIndex","_getCategory","ordinal","getOrdinalMeta","categories","getByRawIndex","rawIdx","getIndices","getSum","getMedian","getValues","isArray","hasValue","dataDimIndicesOnCoord","len","indexOfName","indexOfRawIndex","rawIndexOf","invertedIndices","indicesOfNearest","maxDistance","cb","ctx","isFunction","fCtx","dimIndices","bind","filterSelf","filter","selectRange","innerRange","keys","mapArray","result","apply","arguments","ctxCompat","list","modify","isCalculationCoord","console","error","downSample","dimension","rate","sampleValue","sampleIndex","lttbDownSample","valueDimension","getRawDataItem","getItemModel","ecModel","diff","otherList","thisList","getVisual","visual","setVisual","kvObj","val","getItemVisual","itemVisual","hasItemVisual","ensureUniqueItemVisual","itemVisuals","setItemVisual","clearAllVisual","setLayout","getLayout","getItemLayout","setItemLayout","layout","merge","clearItemLayouts","setItemGraphicEl","el","seriesIndex","dataType","getItemGraphicEl","eachItemGraphicEl","context","call","cloneShallow","wrapMethod","methodName","injectFunction","originalMethod","__wrappedMethods","res","concat","internalField","original","target","source","propName","clone","nameDimIdx","idDimIdx","nameRepeatCount","nmCnt"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Int32Array */\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport Model from '../model/Model.js';\nimport DataDiffer from './DataDiffer.js';\nimport { DefaultDataProvider } from './helper/dataProvider.js';\nimport { summarizeDimensions } from './helper/dimensionHelper.js';\nimport SeriesDimensionDefine from './SeriesDimensionDefine.js';\nimport { SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ORIGINAL } from '../util/types.js';\nimport { convertOptionIdName, isDataItemOption } from '../util/model.js';\nimport { setCommonECData } from '../util/innerStore.js';\nimport { isSourceInstance } from './Source.js';\nimport DataStore from './DataStore.js';\nimport { isSeriesDataSchema } from './helper/SeriesDataSchema.js';\nvar isObject = zrUtil.isObject;\nvar map = zrUtil.map;\nvar CtorInt32Array = typeof Int32Array === 'undefined' ? Array : Int32Array; // Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird update animation.\n\nvar ID_PREFIX = 'e\\0\\0';\nvar INDEX_NOT_FOUND = -1; // type SeriesDimensionIndex = DimensionIndex;\n\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_dimSummary', 'userOutput', '_rawData', '_dimValueGetter', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount'];\nvar CLONE_PROPERTIES = ['_approximateExtent']; // -----------------------------\n// Internal method declarations:\n// -----------------------------\n\nvar prepareInvertedIndex;\nvar getId;\nvar getIdNameFromStore;\nvar normalizeDimensions;\nvar transferProperties;\nvar cloneListForMapAndSample;\nvar makeIdFromName;\n\nvar SeriesData =\n/** @class */\nfunction () {\n  /**\n   * @param dimensionsInput.dimensions\n   *        For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n   *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n   */\n  function SeriesData(dimensionsInput, hostModel) {\n    this.type = 'list';\n    this._dimOmitted = false;\n    this._nameList = [];\n    this._idList = []; // Models of data option is stored sparse for optimizing memory cost\n    // Never used yet (not used yet).\n    // private _optionModels: Model[] = [];\n    // Global visual properties after visual coding\n\n    this._visual = {}; // Global layout properties.\n\n    this._layout = {}; // Item visual properties after visual coding\n\n    this._itemVisuals = []; // Item layout properties after layout\n\n    this._itemLayouts = []; // Graphic elements\n\n    this._graphicEls = []; // key: dim, value: extent\n\n    this._approximateExtent = {};\n    this._calculationInfo = {}; // Having detected that there is data item is non primitive type\n    // (in type `OptionDataItemObject`).\n    // Like `data: [ { value: xx, itemStyle: {...} }, ...]`\n    // At present it only happen in `SOURCE_FORMAT_ORIGINAL`.\n\n    this.hasItemOption = false; // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n\n    this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map']; // Methods that change indices of this list should be listed here.\n\n    this.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\n    this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample'];\n    var dimensions;\n    var assignStoreDimIdx = false;\n\n    if (isSeriesDataSchema(dimensionsInput)) {\n      dimensions = dimensionsInput.dimensions;\n      this._dimOmitted = dimensionsInput.isDimensionOmitted();\n      this._schema = dimensionsInput;\n    } else {\n      assignStoreDimIdx = true;\n      dimensions = dimensionsInput;\n    }\n\n    dimensions = dimensions || ['x', 'y'];\n    var dimensionInfos = {};\n    var dimensionNames = [];\n    var invertedIndicesMap = {};\n    var needsHasOwn = false;\n    var emptyObj = {};\n\n    for (var i = 0; i < dimensions.length; i++) {\n      // Use the original dimensions[i], where other flag props may exists.\n      var dimInfoInput = dimensions[i];\n      var dimensionInfo = zrUtil.isString(dimInfoInput) ? new SeriesDimensionDefine({\n        name: dimInfoInput\n      }) : !(dimInfoInput instanceof SeriesDimensionDefine) ? new SeriesDimensionDefine(dimInfoInput) : dimInfoInput;\n      var dimensionName = dimensionInfo.name;\n      dimensionInfo.type = dimensionInfo.type || 'float';\n\n      if (!dimensionInfo.coordDim) {\n        dimensionInfo.coordDim = dimensionName;\n        dimensionInfo.coordDimIndex = 0;\n      }\n\n      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n      dimensionNames.push(dimensionName);\n      dimensionInfos[dimensionName] = dimensionInfo;\n\n      if (emptyObj[dimensionName] != null) {\n        needsHasOwn = true;\n      }\n\n      if (dimensionInfo.createInvertedIndices) {\n        invertedIndicesMap[dimensionName] = [];\n      }\n\n      if (otherDims.itemName === 0) {\n        this._nameDimIdx = i;\n      }\n\n      if (otherDims.itemId === 0) {\n        this._idDimIdx = i;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        zrUtil.assert(assignStoreDimIdx || dimensionInfo.storeDimIndex >= 0);\n      }\n\n      if (assignStoreDimIdx) {\n        dimensionInfo.storeDimIndex = i;\n      }\n    }\n\n    this.dimensions = dimensionNames;\n    this._dimInfos = dimensionInfos;\n\n    this._initGetDimensionInfo(needsHasOwn);\n\n    this.hostModel = hostModel;\n    this._invertedIndicesMap = invertedIndicesMap;\n\n    if (this._dimOmitted) {\n      var dimIdxToName_1 = this._dimIdxToName = zrUtil.createHashMap();\n      zrUtil.each(dimensionNames, function (dimName) {\n        dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);\n      });\n    }\n  }\n  /**\n   *\n   * Get concrete dimension name by dimension name or dimension index.\n   * If input a dimension name, do not validate whether the dimension name exits.\n   *\n   * @caution\n   * @param dim Must make sure the dimension is `SeriesDimensionLoose`.\n   * Because only those dimensions will have auto-generated dimension names if not\n   * have a user-specified name, and other dimensions will get a return of null/undefined.\n   *\n   * @notice Because of this reason, should better use `getDimensionIndex` instead, for examples:\n   * ```js\n   * const val = data.getStore().get(data.getDimensionIndex(dim), dataIdx);\n   * ```\n   *\n   * @return Concrete dim name.\n   */\n\n\n  SeriesData.prototype.getDimension = function (dim) {\n    var dimIdx = this._recognizeDimIndex(dim);\n\n    if (dimIdx == null) {\n      return dim;\n    }\n\n    dimIdx = dim;\n\n    if (!this._dimOmitted) {\n      return this.dimensions[dimIdx];\n    } // Retrieve from series dimension definition because it probably contains\n    // generated dimension name (like 'x', 'y').\n\n\n    var dimName = this._dimIdxToName.get(dimIdx);\n\n    if (dimName != null) {\n      return dimName;\n    }\n\n    var sourceDimDef = this._schema.getSourceDimension(dimIdx);\n\n    if (sourceDimDef) {\n      return sourceDimDef.name;\n    }\n  };\n  /**\n   * Get dimension index in data store. Return -1 if not found.\n   * Can be used to index value from getRawValue.\n   */\n\n\n  SeriesData.prototype.getDimensionIndex = function (dim) {\n    var dimIdx = this._recognizeDimIndex(dim);\n\n    if (dimIdx != null) {\n      return dimIdx;\n    }\n\n    if (dim == null) {\n      return -1;\n    }\n\n    var dimInfo = this._getDimInfo(dim);\n\n    return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;\n  };\n  /**\n   * The meanings of the input parameter `dim`:\n   *\n   * + If dim is a number (e.g., `1`), it means the index of the dimension.\n   *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.\n   * + If dim is a number-like string (e.g., `\"1\"`):\n   *     + If there is the same concrete dim name defined in `series.dimensions` or `dataset.dimensions`,\n   *        it means that concrete name.\n   *     + If not, it will be converted to a number, which means the index of the dimension.\n   *        (why? because of the backward compatibility. We have been tolerating number-like string in\n   *        dimension setting, although now it seems that it is not a good idea.)\n   *     For example, `visualMap[i].dimension: \"1\"` is the same meaning as `visualMap[i].dimension: 1`,\n   *     if no dimension name is defined as `\"1\"`.\n   * + If dim is a not-number-like string, it means the concrete dim name.\n   *   For example, it can be be default name `\"x\"`, `\"y\"`, `\"z\"`, `\"lng\"`, `\"lat\"`, `\"angle\"`, `\"radius\"`,\n   *   or customized in `dimensions` property of option like `\"age\"`.\n   *\n   * @return recognized `DimensionIndex`. Otherwise return null/undefined (means that dim is `DimensionName`).\n   */\n\n\n  SeriesData.prototype._recognizeDimIndex = function (dim) {\n    if (zrUtil.isNumber(dim) // If being a number-like string but not being defined as a dimension name.\n    || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {\n      return +dim;\n    }\n  };\n\n  SeriesData.prototype._getStoreDimIndex = function (dim) {\n    var dimIdx = this.getDimensionIndex(dim);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (dimIdx == null) {\n        throw new Error('Unknown dimension ' + dim);\n      }\n    }\n\n    return dimIdx;\n  };\n  /**\n   * Get type and calculation info of particular dimension\n   * @param dim\n   *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n   *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n   */\n\n\n  SeriesData.prototype.getDimensionInfo = function (dim) {\n    // Do not clone, because there may be categories in dimInfo.\n    return this._getDimInfo(this.getDimension(dim));\n  };\n\n  SeriesData.prototype._initGetDimensionInfo = function (needsHasOwn) {\n    var dimensionInfos = this._dimInfos;\n    this._getDimInfo = needsHasOwn ? function (dimName) {\n      return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : undefined;\n    } : function (dimName) {\n      return dimensionInfos[dimName];\n    };\n  };\n  /**\n   * concrete dimension name list on coord.\n   */\n\n\n  SeriesData.prototype.getDimensionsOnCoord = function () {\n    return this._dimSummary.dataDimsOnCoord.slice();\n  };\n\n  SeriesData.prototype.mapDimension = function (coordDim, idx) {\n    var dimensionsSummary = this._dimSummary;\n\n    if (idx == null) {\n      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n    }\n\n    var dims = dimensionsSummary.encode[coordDim];\n    return dims ? dims[idx] : null;\n  };\n\n  SeriesData.prototype.mapDimensionsAll = function (coordDim) {\n    var dimensionsSummary = this._dimSummary;\n    var dims = dimensionsSummary.encode[coordDim];\n    return (dims || []).slice();\n  };\n\n  SeriesData.prototype.getStore = function () {\n    return this._store;\n  };\n  /**\n   * Initialize from data\n   * @param data source or data or data store.\n   * @param nameList The name of a datum is used on data diff and\n   *        default label/tooltip.\n   *        A name can be specified in encode.itemName,\n   *        or dataItem.name (only for series option data),\n   *        or provided in nameList from outside.\n   */\n\n\n  SeriesData.prototype.initData = function (data, nameList, dimValueGetter) {\n    var _this = this;\n\n    var store;\n\n    if (data instanceof DataStore) {\n      store = data;\n    }\n\n    if (!store) {\n      var dimensions = this.dimensions;\n      var provider = isSourceInstance(data) || zrUtil.isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data;\n      store = new DataStore();\n      var dimensionInfos = map(dimensions, function (dimName) {\n        return {\n          type: _this._dimInfos[dimName].type,\n          property: dimName\n        };\n      });\n      store.initData(provider, dimensionInfos, dimValueGetter);\n    }\n\n    this._store = store; // Reset\n\n    this._nameList = (nameList || []).slice();\n    this._idList = [];\n    this._nameRepeatCount = {};\n\n    this._doInit(0, store.count()); // Cache summary info for fast visit. See \"dimensionHelper\".\n    // Needs to be initialized after store is prepared.\n\n\n    this._dimSummary = summarizeDimensions(this, this._schema);\n    this.userOutput = this._dimSummary.userOutput;\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   */\n\n\n  SeriesData.prototype.appendData = function (data) {\n    var range = this._store.appendData(data);\n\n    this._doInit(range[0], range[1]);\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   * This method does not modify `rawData` (`dataProvider`), but only\n   * add values to store.\n   *\n   * The final count will be increased by `Math.max(values.length, names.length)`.\n   *\n   * @param values That is the SourceType: 'arrayRows', like\n   *        [\n   *            [12, 33, 44],\n   *            [NaN, 43, 1],\n   *            ['-', 'asdf', 0]\n   *        ]\n   *        Each item is exactly corresponding to a dimension.\n   */\n\n\n  SeriesData.prototype.appendValues = function (values, names) {\n    var _a = this._store.appendValues(values, names.length),\n        start = _a.start,\n        end = _a.end;\n\n    var shouldMakeIdFromName = this._shouldMakeIdFromName();\n\n    this._updateOrdinalMeta();\n\n    if (names) {\n      for (var idx = start; idx < end; idx++) {\n        var sourceIdx = idx - start;\n        this._nameList[idx] = names[sourceIdx];\n\n        if (shouldMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n  };\n\n  SeriesData.prototype._updateOrdinalMeta = function () {\n    var store = this._store;\n    var dimensions = this.dimensions;\n\n    for (var i = 0; i < dimensions.length; i++) {\n      var dimInfo = this._dimInfos[dimensions[i]];\n\n      if (dimInfo.ordinalMeta) {\n        store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);\n      }\n    }\n  };\n\n  SeriesData.prototype._shouldMakeIdFromName = function () {\n    var provider = this._store.getProvider();\n\n    return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;\n  };\n\n  SeriesData.prototype._doInit = function (start, end) {\n    if (start >= end) {\n      return;\n    }\n\n    var store = this._store;\n    var provider = store.getProvider();\n\n    this._updateOrdinalMeta();\n\n    var nameList = this._nameList;\n    var idList = this._idList;\n    var sourceFormat = provider.getSource().sourceFormat;\n    var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL; // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of category\n    // Use a tempValue to normalize the value to be a (x, y) value\n    // If dataItem is {name: ...} or {id: ...}, it has highest priority.\n    // This kind of ids and names are always stored `_nameList` and `_idList`.\n\n    if (isFormatOriginal && !provider.pure) {\n      var sharedDataItem = [];\n\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        var dataItem = provider.getItem(idx, sharedDataItem);\n\n        if (!this.hasItemOption && isDataItemOption(dataItem)) {\n          this.hasItemOption = true;\n        }\n\n        if (dataItem) {\n          var itemName = dataItem.name;\n\n          if (nameList[idx] == null && itemName != null) {\n            nameList[idx] = convertOptionIdName(itemName, null);\n          }\n\n          var itemId = dataItem.id;\n\n          if (idList[idx] == null && itemId != null) {\n            idList[idx] = convertOptionIdName(itemId, null);\n          }\n        }\n      }\n    }\n\n    if (this._shouldMakeIdFromName()) {\n      for (var idx = start; idx < end; idx++) {\n        makeIdFromName(this, idx);\n      }\n    }\n\n    prepareInvertedIndex(this);\n  };\n  /**\n   * PENDING: In fact currently this function is only used to short-circuit\n   * the calling of `scale.unionExtentFromData` when data have been filtered by modules\n   * like \"dataZoom\". `scale.unionExtentFromData` is used to calculate data extent for series on\n   * an axis, but if a \"axis related data filter module\" is used, the extent of the axis have\n   * been fixed and no need to calling `scale.unionExtentFromData` actually.\n   * But if we add \"custom data filter\" in future, which is not \"axis related\", this method may\n   * be still needed.\n   *\n   * Optimize for the scenario that data is filtered by a given extent.\n   * Consider that if data amount is more than hundreds of thousand,\n   * extent calculation will cost more than 10ms and the cache will\n   * be erased because of the filtering.\n   */\n\n\n  SeriesData.prototype.getApproximateExtent = function (dim) {\n    return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));\n  };\n  /**\n   * Calculate extent on a filtered data might be time consuming.\n   * Approximate extent is only used for: calculate extent of filtered data outside.\n   */\n\n\n  SeriesData.prototype.setApproximateExtent = function (extent, dim) {\n    dim = this.getDimension(dim);\n    this._approximateExtent[dim] = extent.slice();\n  };\n\n  SeriesData.prototype.getCalculationInfo = function (key) {\n    return this._calculationInfo[key];\n  };\n\n  SeriesData.prototype.setCalculationInfo = function (key, value) {\n    isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n  };\n  /**\n   * @return Never be null/undefined. `number` will be converted to string. Because:\n   * In most cases, name is used in display, where returning a string is more convenient.\n   * In other cases, name is used in query (see `indexOfName`), where we can keep the\n   * rule that name `2` equals to name `'2'`.\n   */\n\n\n  SeriesData.prototype.getName = function (idx) {\n    var rawIndex = this.getRawIndex(idx);\n    var name = this._nameList[rawIndex];\n\n    if (name == null && this._nameDimIdx != null) {\n      name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);\n    }\n\n    if (name == null) {\n      name = '';\n    }\n\n    return name;\n  };\n\n  SeriesData.prototype._getCategory = function (dimIdx, idx) {\n    var ordinal = this._store.get(dimIdx, idx);\n\n    var ordinalMeta = this._store.getOrdinalMeta(dimIdx);\n\n    if (ordinalMeta) {\n      return ordinalMeta.categories[ordinal];\n    }\n\n    return ordinal;\n  };\n  /**\n   * @return Never null/undefined. `number` will be converted to string. Because:\n   * In all cases having encountered at present, id is used in making diff comparison, which\n   * are usually based on hash map. We can keep the rule that the internal id are always string\n   * (treat `2` is the same as `'2'`) to make the related logic simple.\n   */\n\n\n  SeriesData.prototype.getId = function (idx) {\n    return getId(this, this.getRawIndex(idx));\n  };\n\n  SeriesData.prototype.count = function () {\n    return this._store.count();\n  };\n  /**\n   * Get value. Return NaN if idx is out of range.\n   *\n   * @notice Should better to use `data.getStore().get(dimIndex, dataIdx)` instead.\n   */\n\n\n  SeriesData.prototype.get = function (dim, idx) {\n    var store = this._store;\n    var dimInfo = this._dimInfos[dim];\n\n    if (dimInfo) {\n      return store.get(dimInfo.storeDimIndex, idx);\n    }\n  };\n  /**\n   * @notice Should better to use `data.getStore().getByRawIndex(dimIndex, dataIdx)` instead.\n   */\n\n\n  SeriesData.prototype.getByRawIndex = function (dim, rawIdx) {\n    var store = this._store;\n    var dimInfo = this._dimInfos[dim];\n\n    if (dimInfo) {\n      return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);\n    }\n  };\n\n  SeriesData.prototype.getIndices = function () {\n    return this._store.getIndices();\n  };\n\n  SeriesData.prototype.getDataExtent = function (dim) {\n    return this._store.getDataExtent(this._getStoreDimIndex(dim));\n  };\n\n  SeriesData.prototype.getSum = function (dim) {\n    return this._store.getSum(this._getStoreDimIndex(dim));\n  };\n\n  SeriesData.prototype.getMedian = function (dim) {\n    return this._store.getMedian(this._getStoreDimIndex(dim));\n  };\n\n  SeriesData.prototype.getValues = function (dimensions, idx) {\n    var _this = this;\n\n    var store = this._store;\n    return zrUtil.isArray(dimensions) ? store.getValues(map(dimensions, function (dim) {\n      return _this._getStoreDimIndex(dim);\n    }), idx) : store.getValues(dimensions);\n  };\n  /**\n   * If value is NaN. Including '-'\n   * Only check the coord dimensions.\n   */\n\n\n  SeriesData.prototype.hasValue = function (idx) {\n    var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;\n\n    for (var i = 0, len = dataDimIndicesOnCoord.length; i < len; i++) {\n      // Ordinal type originally can be string or number.\n      // But when an ordinal type is used on coord, it can\n      // not be string but only number. So we can also use isNaN.\n      if (isNaN(this._store.get(dataDimIndicesOnCoord[i], idx))) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Retrieve the index with given name\n   */\n\n\n  SeriesData.prototype.indexOfName = function (name) {\n    for (var i = 0, len = this._store.count(); i < len; i++) {\n      if (this.getName(i) === name) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  SeriesData.prototype.getRawIndex = function (idx) {\n    return this._store.getRawIndex(idx);\n  };\n\n  SeriesData.prototype.indexOfRawIndex = function (rawIndex) {\n    return this._store.indexOfRawIndex(rawIndex);\n  };\n  /**\n   * Only support the dimension which inverted index created.\n   * Do not support other cases until required.\n   * @param dim concrete dim\n   * @param value ordinal index\n   * @return rawIndex\n   */\n\n\n  SeriesData.prototype.rawIndexOf = function (dim, value) {\n    var invertedIndices = dim && this._invertedIndicesMap[dim];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!invertedIndices) {\n        throw new Error('Do not supported yet');\n      }\n    }\n\n    var rawIndex = invertedIndices[value];\n\n    if (rawIndex == null || isNaN(rawIndex)) {\n      return INDEX_NOT_FOUND;\n    }\n\n    return rawIndex;\n  };\n  /**\n   * Retrieve the index of nearest value\n   * @param dim\n   * @param value\n   * @param [maxDistance=Infinity]\n   * @return If and only if multiple indices has\n   *         the same value, they are put to the result.\n   */\n\n\n  SeriesData.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    return this._store.indicesOfNearest(this._getStoreDimIndex(dim), value, maxDistance);\n  };\n\n  SeriesData.prototype.each = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n\n    var fCtx = ctx || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n\n    this._store.each(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n  };\n\n  SeriesData.prototype.filterSelf = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n\n    var fCtx = ctx || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    this._store = this._store.filter(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n    return this;\n  };\n  /**\n   * Select data in range. (For optimization of filter)\n   * (Manually inline code, support 5 million data filtering in data zoom.)\n   */\n\n\n  SeriesData.prototype.selectRange = function (range) {\n    'use strict';\n\n    var _this = this;\n\n    var innerRange = {};\n    var dims = zrUtil.keys(range);\n    var dimIndices = [];\n    zrUtil.each(dims, function (dim) {\n      var dimIdx = _this._getStoreDimIndex(dim);\n\n      innerRange[dimIdx] = range[dim];\n      dimIndices.push(dimIdx);\n    });\n    this._store = this._store.selectRange(innerRange);\n    return this;\n  };\n  /* eslint-enable max-len */\n\n\n  SeriesData.prototype.mapArray = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n\n    ctx = ctx || this;\n    var result = [];\n    this.each(dims, function () {\n      result.push(cb && cb.apply(this, arguments));\n    }, ctx);\n    return result;\n  };\n\n  SeriesData.prototype.map = function (dims, cb, ctx, ctxCompat) {\n    'use strict'; // ctxCompat just for compat echarts3\n\n    var fCtx = ctx || ctxCompat || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.map(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n    return list;\n  };\n\n  SeriesData.prototype.modify = function (dims, cb, ctx, ctxCompat) {\n    var _this = this; // ctxCompat just for compat echarts3\n\n\n    var fCtx = ctx || ctxCompat || this;\n\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.each(normalizeDimensions(dims), function (dim) {\n        var dimInfo = _this.getDimensionInfo(dim);\n\n        if (!dimInfo.isCalculationCoord) {\n          console.error('Danger: only stack dimension can be modified');\n        }\n      });\n    }\n\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this); // If do shallow clone here, if there are too many stacked series,\n    // it still cost lots of memory, because `_store.dimensions` are not shared.\n    // We should consider there probably be shallow clone happen in each series\n    // in consequent filter/map.\n\n    this._store.modify(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n  };\n  /**\n   * Large data down sampling on given dimension\n   * @param sampleIndex Sample index for name and id\n   */\n\n\n  SeriesData.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);\n    return list;\n  };\n  /**\n   * Large data down sampling using largest-triangle-three-buckets\n   * @param {string} valueDimension\n   * @param {number} targetCount\n   */\n\n\n  SeriesData.prototype.lttbDownSample = function (valueDimension, rate) {\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);\n    return list;\n  };\n\n  SeriesData.prototype.getRawDataItem = function (idx) {\n    return this._store.getRawDataItem(idx);\n  };\n  /**\n   * Get model of one data item.\n   */\n  // TODO: Type of data item\n\n\n  SeriesData.prototype.getItemModel = function (idx) {\n    var hostModel = this.hostModel;\n    var dataItem = this.getRawDataItem(idx);\n    return new Model(dataItem, hostModel, hostModel && hostModel.ecModel);\n  };\n  /**\n   * Create a data differ\n   */\n\n\n  SeriesData.prototype.diff = function (otherList) {\n    var thisList = this;\n    return new DataDiffer(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function (idx) {\n      return getId(otherList, idx);\n    }, function (idx) {\n      return getId(thisList, idx);\n    });\n  };\n  /**\n   * Get visual property.\n   */\n\n\n  SeriesData.prototype.getVisual = function (key) {\n    var visual = this._visual;\n    return visual && visual[key];\n  };\n\n  SeriesData.prototype.setVisual = function (kvObj, val) {\n    this._visual = this._visual || {};\n\n    if (isObject(kvObj)) {\n      zrUtil.extend(this._visual, kvObj);\n    } else {\n      this._visual[kvObj] = val;\n    }\n  };\n  /**\n   * Get visual property of single data item\n   */\n  // eslint-disable-next-line\n\n\n  SeriesData.prototype.getItemVisual = function (idx, key) {\n    var itemVisual = this._itemVisuals[idx];\n    var val = itemVisual && itemVisual[key];\n\n    if (val == null) {\n      // Use global visual property\n      return this.getVisual(key);\n    }\n\n    return val;\n  };\n  /**\n   * If exists visual property of single data item\n   */\n\n\n  SeriesData.prototype.hasItemVisual = function () {\n    return this._itemVisuals.length > 0;\n  };\n  /**\n   * Make sure itemVisual property is unique\n   */\n  // TODO: use key to save visual to reduce memory.\n\n\n  SeriesData.prototype.ensureUniqueItemVisual = function (idx, key) {\n    var itemVisuals = this._itemVisuals;\n    var itemVisual = itemVisuals[idx];\n\n    if (!itemVisual) {\n      itemVisual = itemVisuals[idx] = {};\n    }\n\n    var val = itemVisual[key];\n\n    if (val == null) {\n      val = this.getVisual(key); // TODO Performance?\n\n      if (zrUtil.isArray(val)) {\n        val = val.slice();\n      } else if (isObject(val)) {\n        val = zrUtil.extend({}, val);\n      }\n\n      itemVisual[key] = val;\n    }\n\n    return val;\n  }; // eslint-disable-next-line\n\n\n  SeriesData.prototype.setItemVisual = function (idx, key, value) {\n    var itemVisual = this._itemVisuals[idx] || {};\n    this._itemVisuals[idx] = itemVisual;\n\n    if (isObject(key)) {\n      zrUtil.extend(itemVisual, key);\n    } else {\n      itemVisual[key] = value;\n    }\n  };\n  /**\n   * Clear itemVisuals and list visual.\n   */\n\n\n  SeriesData.prototype.clearAllVisual = function () {\n    this._visual = {};\n    this._itemVisuals = [];\n  };\n\n  SeriesData.prototype.setLayout = function (key, val) {\n    isObject(key) ? zrUtil.extend(this._layout, key) : this._layout[key] = val;\n  };\n  /**\n   * Get layout property.\n   */\n\n\n  SeriesData.prototype.getLayout = function (key) {\n    return this._layout[key];\n  };\n  /**\n   * Get layout of single data item\n   */\n\n\n  SeriesData.prototype.getItemLayout = function (idx) {\n    return this._itemLayouts[idx];\n  };\n  /**\n   * Set layout of single data item\n   */\n\n\n  SeriesData.prototype.setItemLayout = function (idx, layout, merge) {\n    this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n  };\n  /**\n   * Clear all layout of single data item\n   */\n\n\n  SeriesData.prototype.clearItemLayouts = function () {\n    this._itemLayouts.length = 0;\n  };\n  /**\n   * Set graphic element relative to data. It can be set as null\n   */\n\n\n  SeriesData.prototype.setItemGraphicEl = function (idx, el) {\n    var seriesIndex = this.hostModel && this.hostModel.seriesIndex;\n    setCommonECData(seriesIndex, this.dataType, idx, el);\n    this._graphicEls[idx] = el;\n  };\n\n  SeriesData.prototype.getItemGraphicEl = function (idx) {\n    return this._graphicEls[idx];\n  };\n\n  SeriesData.prototype.eachItemGraphicEl = function (cb, context) {\n    zrUtil.each(this._graphicEls, function (el, idx) {\n      if (el) {\n        cb && cb.call(context, el, idx);\n      }\n    });\n  };\n  /**\n   * Shallow clone a new list except visual and layout properties, and graph elements.\n   * New list only change the indices.\n   */\n\n\n  SeriesData.prototype.cloneShallow = function (list) {\n    if (!list) {\n      list = new SeriesData(this._schema ? this._schema : map(this.dimensions, this._getDimInfo, this), this.hostModel);\n    }\n\n    transferProperties(list, this);\n    list._store = this._store;\n    return list;\n  };\n  /**\n   * Wrap some method to add more feature\n   */\n\n\n  SeriesData.prototype.wrapMethod = function (methodName, injectFunction) {\n    var originalMethod = this[methodName];\n\n    if (!zrUtil.isFunction(originalMethod)) {\n      return;\n    }\n\n    this.__wrappedMethods = this.__wrappedMethods || [];\n\n    this.__wrappedMethods.push(methodName);\n\n    this[methodName] = function () {\n      var res = originalMethod.apply(this, arguments);\n      return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n    };\n  }; // ----------------------------------------------------------\n  // A work around for internal method visiting private member.\n  // ----------------------------------------------------------\n\n\n  SeriesData.internalField = function () {\n    prepareInvertedIndex = function (data) {\n      var invertedIndicesMap = data._invertedIndicesMap;\n      zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n        var dimInfo = data._dimInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.\n\n        var ordinalMeta = dimInfo.ordinalMeta;\n        var store = data._store;\n\n        if (ordinalMeta) {\n          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss\n          // mapping to 0, we should set it as INDEX_NOT_FOUND.\n\n          for (var i = 0; i < invertedIndices.length; i++) {\n            invertedIndices[i] = INDEX_NOT_FOUND;\n          }\n\n          for (var i = 0; i < store.count(); i++) {\n            // Only support the case that all values are distinct.\n            invertedIndices[store.get(dimInfo.storeDimIndex, i)] = i;\n          }\n        }\n      });\n    };\n\n    getIdNameFromStore = function (data, dimIdx, idx) {\n      return convertOptionIdName(data._getCategory(dimIdx, idx), null);\n    };\n    /**\n     * @see the comment of `List['getId']`.\n     */\n\n\n    getId = function (data, rawIndex) {\n      var id = data._idList[rawIndex];\n\n      if (id == null && data._idDimIdx != null) {\n        id = getIdNameFromStore(data, data._idDimIdx, rawIndex);\n      }\n\n      if (id == null) {\n        id = ID_PREFIX + rawIndex;\n      }\n\n      return id;\n    };\n\n    normalizeDimensions = function (dimensions) {\n      if (!zrUtil.isArray(dimensions)) {\n        dimensions = dimensions != null ? [dimensions] : [];\n      }\n\n      return dimensions;\n    };\n    /**\n     * Data in excludeDimensions is copied, otherwise transferred.\n     */\n\n\n    cloneListForMapAndSample = function (original) {\n      var list = new SeriesData(original._schema ? original._schema : map(original.dimensions, original._getDimInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n      transferProperties(list, original);\n      return list;\n    };\n\n    transferProperties = function (target, source) {\n      zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n        if (source.hasOwnProperty(propName)) {\n          target[propName] = source[propName];\n        }\n      });\n      target.__wrappedMethods = source.__wrappedMethods;\n      zrUtil.each(CLONE_PROPERTIES, function (propName) {\n        target[propName] = zrUtil.clone(source[propName]);\n      });\n      target._calculationInfo = zrUtil.extend({}, source._calculationInfo);\n    };\n\n    makeIdFromName = function (data, idx) {\n      var nameList = data._nameList;\n      var idList = data._idList;\n      var nameDimIdx = data._nameDimIdx;\n      var idDimIdx = data._idDimIdx;\n      var name = nameList[idx];\n      var id = idList[idx];\n\n      if (name == null && nameDimIdx != null) {\n        nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);\n      }\n\n      if (id == null && idDimIdx != null) {\n        idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);\n      }\n\n      if (id == null && name != null) {\n        var nameRepeatCount = data._nameRepeatCount;\n        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;\n        id = name;\n\n        if (nmCnt > 1) {\n          id += '__ec__' + nmCnt;\n        }\n\n        idList[idx] = id;\n      }\n    };\n  }();\n\n  return SeriesData;\n}();\n\nexport default SeriesData;"]},"metadata":{},"sourceType":"module"}